// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: matryer

package redis

import (
	"context"
	"sync"
	"time"

	"github.com/redis/go-redis/v9"
)

// Ensure that MoqCmdable does implement Cmdable.
// If this is not the case, regenerate this file with mockery.
var _ Cmdable = &MoqCmdable{}

// MoqCmdable is a mock implementation of Cmdable.
//
//	func TestSomethingThatUsesCmdable(t *testing.T) {
//
//		// make and configure a mocked Cmdable
//		mockedCmdable := &MoqCmdable{
//			ACLCatFunc: func(ctx context.Context) *redis.StringSliceCmd {
//				panic("mock out the ACLCat method")
//			},
//			ACLCatArgsFunc: func(ctx context.Context, options *redis.ACLCatArgs) *redis.StringSliceCmd {
//				panic("mock out the ACLCatArgs method")
//			},
//			ACLDelUserFunc: func(ctx context.Context, username string) *redis.IntCmd {
//				panic("mock out the ACLDelUser method")
//			},
//			ACLDryRunFunc: func(ctx context.Context, username string, command ...interface{}) *redis.StringCmd {
//				panic("mock out the ACLDryRun method")
//			},
//			ACLGenPassFunc: func(ctx context.Context, bit int) *redis.StringCmd {
//				panic("mock out the ACLGenPass method")
//			},
//			ACLListFunc: func(ctx context.Context) *redis.StringSliceCmd {
//				panic("mock out the ACLList method")
//			},
//			ACLLogFunc: func(ctx context.Context, count int64) *redis.ACLLogCmd {
//				panic("mock out the ACLLog method")
//			},
//			ACLLogResetFunc: func(ctx context.Context) *redis.StatusCmd {
//				panic("mock out the ACLLogReset method")
//			},
//			ACLSetUserFunc: func(ctx context.Context, username string, rules ...string) *redis.StatusCmd {
//				panic("mock out the ACLSetUser method")
//			},
//			ACLUsersFunc: func(ctx context.Context) *redis.StringSliceCmd {
//				panic("mock out the ACLUsers method")
//			},
//			ACLWhoAmIFunc: func(ctx context.Context) *redis.StringCmd {
//				panic("mock out the ACLWhoAmI method")
//			},
//			AppendFunc: func(ctx context.Context, key string, value string) *redis.IntCmd {
//				panic("mock out the Append method")
//			},
//			BFAddFunc: func(ctx context.Context, key string, element interface{}) *redis.BoolCmd {
//				panic("mock out the BFAdd method")
//			},
//			BFCardFunc: func(ctx context.Context, key string) *redis.IntCmd {
//				panic("mock out the BFCard method")
//			},
//			BFExistsFunc: func(ctx context.Context, key string, element interface{}) *redis.BoolCmd {
//				panic("mock out the BFExists method")
//			},
//			BFInfoFunc: func(ctx context.Context, key string) *redis.BFInfoCmd {
//				panic("mock out the BFInfo method")
//			},
//			BFInfoArgFunc: func(ctx context.Context, key string, option string) *redis.BFInfoCmd {
//				panic("mock out the BFInfoArg method")
//			},
//			BFInfoCapacityFunc: func(ctx context.Context, key string) *redis.BFInfoCmd {
//				panic("mock out the BFInfoCapacity method")
//			},
//			BFInfoExpansionFunc: func(ctx context.Context, key string) *redis.BFInfoCmd {
//				panic("mock out the BFInfoExpansion method")
//			},
//			BFInfoFiltersFunc: func(ctx context.Context, key string) *redis.BFInfoCmd {
//				panic("mock out the BFInfoFilters method")
//			},
//			BFInfoItemsFunc: func(ctx context.Context, key string) *redis.BFInfoCmd {
//				panic("mock out the BFInfoItems method")
//			},
//			BFInfoSizeFunc: func(ctx context.Context, key string) *redis.BFInfoCmd {
//				panic("mock out the BFInfoSize method")
//			},
//			BFInsertFunc: func(ctx context.Context, key string, options *redis.BFInsertOptions, elements ...interface{}) *redis.BoolSliceCmd {
//				panic("mock out the BFInsert method")
//			},
//			BFLoadChunkFunc: func(ctx context.Context, key string, iterator int64, data interface{}) *redis.StatusCmd {
//				panic("mock out the BFLoadChunk method")
//			},
//			BFMAddFunc: func(ctx context.Context, key string, elements ...interface{}) *redis.BoolSliceCmd {
//				panic("mock out the BFMAdd method")
//			},
//			BFMExistsFunc: func(ctx context.Context, key string, elements ...interface{}) *redis.BoolSliceCmd {
//				panic("mock out the BFMExists method")
//			},
//			BFReserveFunc: func(ctx context.Context, key string, errorRate float64, capacity int64) *redis.StatusCmd {
//				panic("mock out the BFReserve method")
//			},
//			BFReserveExpansionFunc: func(ctx context.Context, key string, errorRate float64, capacity int64, expansion int64) *redis.StatusCmd {
//				panic("mock out the BFReserveExpansion method")
//			},
//			BFReserveNonScalingFunc: func(ctx context.Context, key string, errorRate float64, capacity int64) *redis.StatusCmd {
//				panic("mock out the BFReserveNonScaling method")
//			},
//			BFReserveWithArgsFunc: func(ctx context.Context, key string, options *redis.BFReserveOptions) *redis.StatusCmd {
//				panic("mock out the BFReserveWithArgs method")
//			},
//			BFScanDumpFunc: func(ctx context.Context, key string, iterator int64) *redis.ScanDumpCmd {
//				panic("mock out the BFScanDump method")
//			},
//			BLMPopFunc: func(ctx context.Context, timeout time.Duration, direction string, count int64, keys ...string) *redis.KeyValuesCmd {
//				panic("mock out the BLMPop method")
//			},
//			BLMoveFunc: func(ctx context.Context, source string, destination string, srcpos string, destpos string, timeout time.Duration) *redis.StringCmd {
//				panic("mock out the BLMove method")
//			},
//			BLPopFunc: func(ctx context.Context, timeout time.Duration, keys ...string) *redis.StringSliceCmd {
//				panic("mock out the BLPop method")
//			},
//			BRPopFunc: func(ctx context.Context, timeout time.Duration, keys ...string) *redis.StringSliceCmd {
//				panic("mock out the BRPop method")
//			},
//			BRPopLPushFunc: func(ctx context.Context, source string, destination string, timeout time.Duration) *redis.StringCmd {
//				panic("mock out the BRPopLPush method")
//			},
//			BZMPopFunc: func(ctx context.Context, timeout time.Duration, order string, count int64, keys ...string) *redis.ZSliceWithKeyCmd {
//				panic("mock out the BZMPop method")
//			},
//			BZPopMaxFunc: func(ctx context.Context, timeout time.Duration, keys ...string) *redis.ZWithKeyCmd {
//				panic("mock out the BZPopMax method")
//			},
//			BZPopMinFunc: func(ctx context.Context, timeout time.Duration, keys ...string) *redis.ZWithKeyCmd {
//				panic("mock out the BZPopMin method")
//			},
//			BgRewriteAOFFunc: func(ctx context.Context) *redis.StatusCmd {
//				panic("mock out the BgRewriteAOF method")
//			},
//			BgSaveFunc: func(ctx context.Context) *redis.StatusCmd {
//				panic("mock out the BgSave method")
//			},
//			BitCountFunc: func(ctx context.Context, key string, bitCount *redis.BitCount) *redis.IntCmd {
//				panic("mock out the BitCount method")
//			},
//			BitFieldFunc: func(ctx context.Context, key string, values ...interface{}) *redis.IntSliceCmd {
//				panic("mock out the BitField method")
//			},
//			BitFieldROFunc: func(ctx context.Context, key string, values ...interface{}) *redis.IntSliceCmd {
//				panic("mock out the BitFieldRO method")
//			},
//			BitOpAndFunc: func(ctx context.Context, destKey string, keys ...string) *redis.IntCmd {
//				panic("mock out the BitOpAnd method")
//			},
//			BitOpAndOrFunc: func(ctx context.Context, destKey string, keys ...string) *redis.IntCmd {
//				panic("mock out the BitOpAndOr method")
//			},
//			BitOpDiffFunc: func(ctx context.Context, destKey string, keys ...string) *redis.IntCmd {
//				panic("mock out the BitOpDiff method")
//			},
//			BitOpDiff1Func: func(ctx context.Context, destKey string, keys ...string) *redis.IntCmd {
//				panic("mock out the BitOpDiff1 method")
//			},
//			BitOpNotFunc: func(ctx context.Context, destKey string, key string) *redis.IntCmd {
//				panic("mock out the BitOpNot method")
//			},
//			BitOpOneFunc: func(ctx context.Context, destKey string, keys ...string) *redis.IntCmd {
//				panic("mock out the BitOpOne method")
//			},
//			BitOpOrFunc: func(ctx context.Context, destKey string, keys ...string) *redis.IntCmd {
//				panic("mock out the BitOpOr method")
//			},
//			BitOpXorFunc: func(ctx context.Context, destKey string, keys ...string) *redis.IntCmd {
//				panic("mock out the BitOpXor method")
//			},
//			BitPosFunc: func(ctx context.Context, key string, bit int64, pos ...int64) *redis.IntCmd {
//				panic("mock out the BitPos method")
//			},
//			BitPosSpanFunc: func(ctx context.Context, key string, bit int8, start int64, end int64, span string) *redis.IntCmd {
//				panic("mock out the BitPosSpan method")
//			},
//			CFAddFunc: func(ctx context.Context, key string, element interface{}) *redis.BoolCmd {
//				panic("mock out the CFAdd method")
//			},
//			CFAddNXFunc: func(ctx context.Context, key string, element interface{}) *redis.BoolCmd {
//				panic("mock out the CFAddNX method")
//			},
//			CFCountFunc: func(ctx context.Context, key string, element interface{}) *redis.IntCmd {
//				panic("mock out the CFCount method")
//			},
//			CFDelFunc: func(ctx context.Context, key string, element interface{}) *redis.BoolCmd {
//				panic("mock out the CFDel method")
//			},
//			CFExistsFunc: func(ctx context.Context, key string, element interface{}) *redis.BoolCmd {
//				panic("mock out the CFExists method")
//			},
//			CFInfoFunc: func(ctx context.Context, key string) *redis.CFInfoCmd {
//				panic("mock out the CFInfo method")
//			},
//			CFInsertFunc: func(ctx context.Context, key string, options *redis.CFInsertOptions, elements ...interface{}) *redis.BoolSliceCmd {
//				panic("mock out the CFInsert method")
//			},
//			CFInsertNXFunc: func(ctx context.Context, key string, options *redis.CFInsertOptions, elements ...interface{}) *redis.IntSliceCmd {
//				panic("mock out the CFInsertNX method")
//			},
//			CFLoadChunkFunc: func(ctx context.Context, key string, iterator int64, data interface{}) *redis.StatusCmd {
//				panic("mock out the CFLoadChunk method")
//			},
//			CFMExistsFunc: func(ctx context.Context, key string, elements ...interface{}) *redis.BoolSliceCmd {
//				panic("mock out the CFMExists method")
//			},
//			CFReserveFunc: func(ctx context.Context, key string, capacity int64) *redis.StatusCmd {
//				panic("mock out the CFReserve method")
//			},
//			CFReserveBucketSizeFunc: func(ctx context.Context, key string, capacity int64, bucketsize int64) *redis.StatusCmd {
//				panic("mock out the CFReserveBucketSize method")
//			},
//			CFReserveExpansionFunc: func(ctx context.Context, key string, capacity int64, expansion int64) *redis.StatusCmd {
//				panic("mock out the CFReserveExpansion method")
//			},
//			CFReserveMaxIterationsFunc: func(ctx context.Context, key string, capacity int64, maxiterations int64) *redis.StatusCmd {
//				panic("mock out the CFReserveMaxIterations method")
//			},
//			CFReserveWithArgsFunc: func(ctx context.Context, key string, options *redis.CFReserveOptions) *redis.StatusCmd {
//				panic("mock out the CFReserveWithArgs method")
//			},
//			CFScanDumpFunc: func(ctx context.Context, key string, iterator int64) *redis.ScanDumpCmd {
//				panic("mock out the CFScanDump method")
//			},
//			CMSIncrByFunc: func(ctx context.Context, key string, elements ...interface{}) *redis.IntSliceCmd {
//				panic("mock out the CMSIncrBy method")
//			},
//			CMSInfoFunc: func(ctx context.Context, key string) *redis.CMSInfoCmd {
//				panic("mock out the CMSInfo method")
//			},
//			CMSInitByDimFunc: func(ctx context.Context, key string, width int64, height int64) *redis.StatusCmd {
//				panic("mock out the CMSInitByDim method")
//			},
//			CMSInitByProbFunc: func(ctx context.Context, key string, errorRate float64, probability float64) *redis.StatusCmd {
//				panic("mock out the CMSInitByProb method")
//			},
//			CMSMergeFunc: func(ctx context.Context, destKey string, sourceKeys ...string) *redis.StatusCmd {
//				panic("mock out the CMSMerge method")
//			},
//			CMSMergeWithWeightFunc: func(ctx context.Context, destKey string, sourceKeys map[string]int64) *redis.StatusCmd {
//				panic("mock out the CMSMergeWithWeight method")
//			},
//			CMSQueryFunc: func(ctx context.Context, key string, elements ...interface{}) *redis.IntSliceCmd {
//				panic("mock out the CMSQuery method")
//			},
//			ClientGetNameFunc: func(ctx context.Context) *redis.StringCmd {
//				panic("mock out the ClientGetName method")
//			},
//			ClientIDFunc: func(ctx context.Context) *redis.IntCmd {
//				panic("mock out the ClientID method")
//			},
//			ClientInfoFunc: func(ctx context.Context) *redis.ClientInfoCmd {
//				panic("mock out the ClientInfo method")
//			},
//			ClientKillFunc: func(ctx context.Context, ipPort string) *redis.StatusCmd {
//				panic("mock out the ClientKill method")
//			},
//			ClientKillByFilterFunc: func(ctx context.Context, keys ...string) *redis.IntCmd {
//				panic("mock out the ClientKillByFilter method")
//			},
//			ClientListFunc: func(ctx context.Context) *redis.StringCmd {
//				panic("mock out the ClientList method")
//			},
//			ClientMaintNotificationsFunc: func(ctx context.Context, enabled bool, endpointType string) *redis.StatusCmd {
//				panic("mock out the ClientMaintNotifications method")
//			},
//			ClientPauseFunc: func(ctx context.Context, dur time.Duration) *redis.BoolCmd {
//				panic("mock out the ClientPause method")
//			},
//			ClientUnblockFunc: func(ctx context.Context, id int64) *redis.IntCmd {
//				panic("mock out the ClientUnblock method")
//			},
//			ClientUnblockWithErrorFunc: func(ctx context.Context, id int64) *redis.IntCmd {
//				panic("mock out the ClientUnblockWithError method")
//			},
//			ClientUnpauseFunc: func(ctx context.Context) *redis.BoolCmd {
//				panic("mock out the ClientUnpause method")
//			},
//			ClusterAddSlotsFunc: func(ctx context.Context, slots ...int) *redis.StatusCmd {
//				panic("mock out the ClusterAddSlots method")
//			},
//			ClusterAddSlotsRangeFunc: func(ctx context.Context, min int, max int) *redis.StatusCmd {
//				panic("mock out the ClusterAddSlotsRange method")
//			},
//			ClusterCountFailureReportsFunc: func(ctx context.Context, nodeID string) *redis.IntCmd {
//				panic("mock out the ClusterCountFailureReports method")
//			},
//			ClusterCountKeysInSlotFunc: func(ctx context.Context, slot int) *redis.IntCmd {
//				panic("mock out the ClusterCountKeysInSlot method")
//			},
//			ClusterDelSlotsFunc: func(ctx context.Context, slots ...int) *redis.StatusCmd {
//				panic("mock out the ClusterDelSlots method")
//			},
//			ClusterDelSlotsRangeFunc: func(ctx context.Context, min int, max int) *redis.StatusCmd {
//				panic("mock out the ClusterDelSlotsRange method")
//			},
//			ClusterFailoverFunc: func(ctx context.Context) *redis.StatusCmd {
//				panic("mock out the ClusterFailover method")
//			},
//			ClusterForgetFunc: func(ctx context.Context, nodeID string) *redis.StatusCmd {
//				panic("mock out the ClusterForget method")
//			},
//			ClusterGetKeysInSlotFunc: func(ctx context.Context, slot int, count int) *redis.StringSliceCmd {
//				panic("mock out the ClusterGetKeysInSlot method")
//			},
//			ClusterInfoFunc: func(ctx context.Context) *redis.StringCmd {
//				panic("mock out the ClusterInfo method")
//			},
//			ClusterKeySlotFunc: func(ctx context.Context, key string) *redis.IntCmd {
//				panic("mock out the ClusterKeySlot method")
//			},
//			ClusterLinksFunc: func(ctx context.Context) *redis.ClusterLinksCmd {
//				panic("mock out the ClusterLinks method")
//			},
//			ClusterMeetFunc: func(ctx context.Context, host string, port string) *redis.StatusCmd {
//				panic("mock out the ClusterMeet method")
//			},
//			ClusterMyIDFunc: func(ctx context.Context) *redis.StringCmd {
//				panic("mock out the ClusterMyID method")
//			},
//			ClusterMyShardIDFunc: func(ctx context.Context) *redis.StringCmd {
//				panic("mock out the ClusterMyShardID method")
//			},
//			ClusterNodesFunc: func(ctx context.Context) *redis.StringCmd {
//				panic("mock out the ClusterNodes method")
//			},
//			ClusterReplicateFunc: func(ctx context.Context, nodeID string) *redis.StatusCmd {
//				panic("mock out the ClusterReplicate method")
//			},
//			ClusterResetHardFunc: func(ctx context.Context) *redis.StatusCmd {
//				panic("mock out the ClusterResetHard method")
//			},
//			ClusterResetSoftFunc: func(ctx context.Context) *redis.StatusCmd {
//				panic("mock out the ClusterResetSoft method")
//			},
//			ClusterSaveConfigFunc: func(ctx context.Context) *redis.StatusCmd {
//				panic("mock out the ClusterSaveConfig method")
//			},
//			ClusterShardsFunc: func(ctx context.Context) *redis.ClusterShardsCmd {
//				panic("mock out the ClusterShards method")
//			},
//			ClusterSlavesFunc: func(ctx context.Context, nodeID string) *redis.StringSliceCmd {
//				panic("mock out the ClusterSlaves method")
//			},
//			ClusterSlotsFunc: func(ctx context.Context) *redis.ClusterSlotsCmd {
//				panic("mock out the ClusterSlots method")
//			},
//			CommandFunc: func(ctx context.Context) *redis.CommandsInfoCmd {
//				panic("mock out the Command method")
//			},
//			CommandGetKeysFunc: func(ctx context.Context, commands ...interface{}) *redis.StringSliceCmd {
//				panic("mock out the CommandGetKeys method")
//			},
//			CommandGetKeysAndFlagsFunc: func(ctx context.Context, commands ...interface{}) *redis.KeyFlagsCmd {
//				panic("mock out the CommandGetKeysAndFlags method")
//			},
//			CommandListFunc: func(ctx context.Context, filter *redis.FilterBy) *redis.StringSliceCmd {
//				panic("mock out the CommandList method")
//			},
//			ConfigGetFunc: func(ctx context.Context, parameter string) *redis.MapStringStringCmd {
//				panic("mock out the ConfigGet method")
//			},
//			ConfigResetStatFunc: func(ctx context.Context) *redis.StatusCmd {
//				panic("mock out the ConfigResetStat method")
//			},
//			ConfigRewriteFunc: func(ctx context.Context) *redis.StatusCmd {
//				panic("mock out the ConfigRewrite method")
//			},
//			ConfigSetFunc: func(ctx context.Context, parameter string, value string) *redis.StatusCmd {
//				panic("mock out the ConfigSet method")
//			},
//			CopyFunc: func(ctx context.Context, sourceKey string, destKey string, db int, replace bool) *redis.IntCmd {
//				panic("mock out the Copy method")
//			},
//			DBSizeFunc: func(ctx context.Context) *redis.IntCmd {
//				panic("mock out the DBSize method")
//			},
//			DebugObjectFunc: func(ctx context.Context, key string) *redis.StringCmd {
//				panic("mock out the DebugObject method")
//			},
//			DecrFunc: func(ctx context.Context, key string) *redis.IntCmd {
//				panic("mock out the Decr method")
//			},
//			DecrByFunc: func(ctx context.Context, key string, decrement int64) *redis.IntCmd {
//				panic("mock out the DecrBy method")
//			},
//			DelFunc: func(ctx context.Context, keys ...string) *redis.IntCmd {
//				panic("mock out the Del method")
//			},
//			DelExArgsFunc: func(ctx context.Context, key string, a redis.DelExArgs) *redis.IntCmd {
//				panic("mock out the DelExArgs method")
//			},
//			DigestFunc: func(ctx context.Context, key string) *redis.DigestCmd {
//				panic("mock out the Digest method")
//			},
//			DumpFunc: func(ctx context.Context, key string) *redis.StringCmd {
//				panic("mock out the Dump method")
//			},
//			EchoFunc: func(ctx context.Context, message interface{}) *redis.StringCmd {
//				panic("mock out the Echo method")
//			},
//			EvalFunc: func(ctx context.Context, script string, keys []string, args ...interface{}) *redis.Cmd {
//				panic("mock out the Eval method")
//			},
//			EvalROFunc: func(ctx context.Context, script string, keys []string, args ...interface{}) *redis.Cmd {
//				panic("mock out the EvalRO method")
//			},
//			EvalShaFunc: func(ctx context.Context, sha1 string, keys []string, args ...interface{}) *redis.Cmd {
//				panic("mock out the EvalSha method")
//			},
//			EvalShaROFunc: func(ctx context.Context, sha1 string, keys []string, args ...interface{}) *redis.Cmd {
//				panic("mock out the EvalShaRO method")
//			},
//			ExistsFunc: func(ctx context.Context, keys ...string) *redis.IntCmd {
//				panic("mock out the Exists method")
//			},
//			ExpireFunc: func(ctx context.Context, key string, expiration time.Duration) *redis.BoolCmd {
//				panic("mock out the Expire method")
//			},
//			ExpireAtFunc: func(ctx context.Context, key string, tm time.Time) *redis.BoolCmd {
//				panic("mock out the ExpireAt method")
//			},
//			ExpireGTFunc: func(ctx context.Context, key string, expiration time.Duration) *redis.BoolCmd {
//				panic("mock out the ExpireGT method")
//			},
//			ExpireLTFunc: func(ctx context.Context, key string, expiration time.Duration) *redis.BoolCmd {
//				panic("mock out the ExpireLT method")
//			},
//			ExpireNXFunc: func(ctx context.Context, key string, expiration time.Duration) *redis.BoolCmd {
//				panic("mock out the ExpireNX method")
//			},
//			ExpireTimeFunc: func(ctx context.Context, key string) *redis.DurationCmd {
//				panic("mock out the ExpireTime method")
//			},
//			ExpireXXFunc: func(ctx context.Context, key string, expiration time.Duration) *redis.BoolCmd {
//				panic("mock out the ExpireXX method")
//			},
//			FCallFunc: func(ctx context.Context, function string, keys []string, args ...interface{}) *redis.Cmd {
//				panic("mock out the FCall method")
//			},
//			FCallROFunc: func(ctx context.Context, function string, keys []string, args ...interface{}) *redis.Cmd {
//				panic("mock out the FCallRO method")
//			},
//			FCallRoFunc: func(ctx context.Context, function string, keys []string, args ...interface{}) *redis.Cmd {
//				panic("mock out the FCallRo method")
//			},
//			FTAggregateFunc: func(ctx context.Context, index string, query string) *redis.MapStringInterfaceCmd {
//				panic("mock out the FTAggregate method")
//			},
//			FTAggregateWithArgsFunc: func(ctx context.Context, index string, query string, options *redis.FTAggregateOptions) *redis.AggregateCmd {
//				panic("mock out the FTAggregateWithArgs method")
//			},
//			FTAliasAddFunc: func(ctx context.Context, index string, alias string) *redis.StatusCmd {
//				panic("mock out the FTAliasAdd method")
//			},
//			FTAliasDelFunc: func(ctx context.Context, alias string) *redis.StatusCmd {
//				panic("mock out the FTAliasDel method")
//			},
//			FTAliasUpdateFunc: func(ctx context.Context, index string, alias string) *redis.StatusCmd {
//				panic("mock out the FTAliasUpdate method")
//			},
//			FTAlterFunc: func(ctx context.Context, index string, skipInitialScan bool, definition []interface{}) *redis.StatusCmd {
//				panic("mock out the FTAlter method")
//			},
//			FTConfigGetFunc: func(ctx context.Context, option string) *redis.MapMapStringInterfaceCmd {
//				panic("mock out the FTConfigGet method")
//			},
//			FTConfigSetFunc: func(ctx context.Context, option string, value interface{}) *redis.StatusCmd {
//				panic("mock out the FTConfigSet method")
//			},
//			FTCreateFunc: func(ctx context.Context, index string, options *redis.FTCreateOptions, schema ...*redis.FieldSchema) *redis.StatusCmd {
//				panic("mock out the FTCreate method")
//			},
//			FTCursorDelFunc: func(ctx context.Context, index string, cursorId int) *redis.StatusCmd {
//				panic("mock out the FTCursorDel method")
//			},
//			FTCursorReadFunc: func(ctx context.Context, index string, cursorId int, count int) *redis.MapStringInterfaceCmd {
//				panic("mock out the FTCursorRead method")
//			},
//			FTDictAddFunc: func(ctx context.Context, dict string, term ...interface{}) *redis.IntCmd {
//				panic("mock out the FTDictAdd method")
//			},
//			FTDictDelFunc: func(ctx context.Context, dict string, term ...interface{}) *redis.IntCmd {
//				panic("mock out the FTDictDel method")
//			},
//			FTDictDumpFunc: func(ctx context.Context, dict string) *redis.StringSliceCmd {
//				panic("mock out the FTDictDump method")
//			},
//			FTDropIndexFunc: func(ctx context.Context, index string) *redis.StatusCmd {
//				panic("mock out the FTDropIndex method")
//			},
//			FTDropIndexWithArgsFunc: func(ctx context.Context, index string, options *redis.FTDropIndexOptions) *redis.StatusCmd {
//				panic("mock out the FTDropIndexWithArgs method")
//			},
//			FTExplainFunc: func(ctx context.Context, index string, query string) *redis.StringCmd {
//				panic("mock out the FTExplain method")
//			},
//			FTExplainWithArgsFunc: func(ctx context.Context, index string, query string, options *redis.FTExplainOptions) *redis.StringCmd {
//				panic("mock out the FTExplainWithArgs method")
//			},
//			FTHybridFunc: func(ctx context.Context, index string, searchExpr string, vectorField string, vectorData redis.Vector) *redis.FTHybridCmd {
//				panic("mock out the FTHybrid method")
//			},
//			FTHybridWithArgsFunc: func(ctx context.Context, index string, options *redis.FTHybridOptions) *redis.FTHybridCmd {
//				panic("mock out the FTHybridWithArgs method")
//			},
//			FTInfoFunc: func(ctx context.Context, index string) *redis.FTInfoCmd {
//				panic("mock out the FTInfo method")
//			},
//			FTSearchFunc: func(ctx context.Context, index string, query string) *redis.FTSearchCmd {
//				panic("mock out the FTSearch method")
//			},
//			FTSearchWithArgsFunc: func(ctx context.Context, index string, query string, options *redis.FTSearchOptions) *redis.FTSearchCmd {
//				panic("mock out the FTSearchWithArgs method")
//			},
//			FTSpellCheckFunc: func(ctx context.Context, index string, query string) *redis.FTSpellCheckCmd {
//				panic("mock out the FTSpellCheck method")
//			},
//			FTSpellCheckWithArgsFunc: func(ctx context.Context, index string, query string, options *redis.FTSpellCheckOptions) *redis.FTSpellCheckCmd {
//				panic("mock out the FTSpellCheckWithArgs method")
//			},
//			FTSynDumpFunc: func(ctx context.Context, index string) *redis.FTSynDumpCmd {
//				panic("mock out the FTSynDump method")
//			},
//			FTSynUpdateFunc: func(ctx context.Context, index string, synGroupId interface{}, terms []interface{}) *redis.StatusCmd {
//				panic("mock out the FTSynUpdate method")
//			},
//			FTSynUpdateWithArgsFunc: func(ctx context.Context, index string, synGroupId interface{}, options *redis.FTSynUpdateOptions, terms []interface{}) *redis.StatusCmd {
//				panic("mock out the FTSynUpdateWithArgs method")
//			},
//			FTTagValsFunc: func(ctx context.Context, index string, field string) *redis.StringSliceCmd {
//				panic("mock out the FTTagVals method")
//			},
//			FT_ListFunc: func(ctx context.Context) *redis.StringSliceCmd {
//				panic("mock out the FT_List method")
//			},
//			FlushAllFunc: func(ctx context.Context) *redis.StatusCmd {
//				panic("mock out the FlushAll method")
//			},
//			FlushAllAsyncFunc: func(ctx context.Context) *redis.StatusCmd {
//				panic("mock out the FlushAllAsync method")
//			},
//			FlushDBFunc: func(ctx context.Context) *redis.StatusCmd {
//				panic("mock out the FlushDB method")
//			},
//			FlushDBAsyncFunc: func(ctx context.Context) *redis.StatusCmd {
//				panic("mock out the FlushDBAsync method")
//			},
//			FunctionDeleteFunc: func(ctx context.Context, libName string) *redis.StringCmd {
//				panic("mock out the FunctionDelete method")
//			},
//			FunctionDumpFunc: func(ctx context.Context) *redis.StringCmd {
//				panic("mock out the FunctionDump method")
//			},
//			FunctionFlushFunc: func(ctx context.Context) *redis.StringCmd {
//				panic("mock out the FunctionFlush method")
//			},
//			FunctionFlushAsyncFunc: func(ctx context.Context) *redis.StringCmd {
//				panic("mock out the FunctionFlushAsync method")
//			},
//			FunctionKillFunc: func(ctx context.Context) *redis.StringCmd {
//				panic("mock out the FunctionKill method")
//			},
//			FunctionListFunc: func(ctx context.Context, q redis.FunctionListQuery) *redis.FunctionListCmd {
//				panic("mock out the FunctionList method")
//			},
//			FunctionLoadFunc: func(ctx context.Context, code string) *redis.StringCmd {
//				panic("mock out the FunctionLoad method")
//			},
//			FunctionLoadReplaceFunc: func(ctx context.Context, code string) *redis.StringCmd {
//				panic("mock out the FunctionLoadReplace method")
//			},
//			FunctionRestoreFunc: func(ctx context.Context, libDump string) *redis.StringCmd {
//				panic("mock out the FunctionRestore method")
//			},
//			FunctionStatsFunc: func(ctx context.Context) *redis.FunctionStatsCmd {
//				panic("mock out the FunctionStats method")
//			},
//			GeoAddFunc: func(ctx context.Context, key string, geoLocation ...*redis.GeoLocation) *redis.IntCmd {
//				panic("mock out the GeoAdd method")
//			},
//			GeoDistFunc: func(ctx context.Context, key string, member1 string, member2 string, unit string) *redis.FloatCmd {
//				panic("mock out the GeoDist method")
//			},
//			GeoHashFunc: func(ctx context.Context, key string, members ...string) *redis.StringSliceCmd {
//				panic("mock out the GeoHash method")
//			},
//			GeoPosFunc: func(ctx context.Context, key string, members ...string) *redis.GeoPosCmd {
//				panic("mock out the GeoPos method")
//			},
//			GeoRadiusFunc: func(ctx context.Context, key string, longitude float64, latitude float64, query *redis.GeoRadiusQuery) *redis.GeoLocationCmd {
//				panic("mock out the GeoRadius method")
//			},
//			GeoRadiusByMemberFunc: func(ctx context.Context, key string, member string, query *redis.GeoRadiusQuery) *redis.GeoLocationCmd {
//				panic("mock out the GeoRadiusByMember method")
//			},
//			GeoRadiusByMemberStoreFunc: func(ctx context.Context, key string, member string, query *redis.GeoRadiusQuery) *redis.IntCmd {
//				panic("mock out the GeoRadiusByMemberStore method")
//			},
//			GeoRadiusStoreFunc: func(ctx context.Context, key string, longitude float64, latitude float64, query *redis.GeoRadiusQuery) *redis.IntCmd {
//				panic("mock out the GeoRadiusStore method")
//			},
//			GeoSearchFunc: func(ctx context.Context, key string, q *redis.GeoSearchQuery) *redis.StringSliceCmd {
//				panic("mock out the GeoSearch method")
//			},
//			GeoSearchLocationFunc: func(ctx context.Context, key string, q *redis.GeoSearchLocationQuery) *redis.GeoSearchLocationCmd {
//				panic("mock out the GeoSearchLocation method")
//			},
//			GeoSearchStoreFunc: func(ctx context.Context, key string, store string, q *redis.GeoSearchStoreQuery) *redis.IntCmd {
//				panic("mock out the GeoSearchStore method")
//			},
//			GetFunc: func(ctx context.Context, key string) *redis.StringCmd {
//				panic("mock out the Get method")
//			},
//			GetBitFunc: func(ctx context.Context, key string, offset int64) *redis.IntCmd {
//				panic("mock out the GetBit method")
//			},
//			GetDelFunc: func(ctx context.Context, key string) *redis.StringCmd {
//				panic("mock out the GetDel method")
//			},
//			GetExFunc: func(ctx context.Context, key string, expiration time.Duration) *redis.StringCmd {
//				panic("mock out the GetEx method")
//			},
//			GetRangeFunc: func(ctx context.Context, key string, start int64, end int64) *redis.StringCmd {
//				panic("mock out the GetRange method")
//			},
//			GetSetFunc: func(ctx context.Context, key string, value interface{}) *redis.StringCmd {
//				panic("mock out the GetSet method")
//			},
//			HDelFunc: func(ctx context.Context, key string, fields ...string) *redis.IntCmd {
//				panic("mock out the HDel method")
//			},
//			HExistsFunc: func(ctx context.Context, key string, field string) *redis.BoolCmd {
//				panic("mock out the HExists method")
//			},
//			HExpireFunc: func(ctx context.Context, key string, expiration time.Duration, fields ...string) *redis.IntSliceCmd {
//				panic("mock out the HExpire method")
//			},
//			HExpireAtFunc: func(ctx context.Context, key string, tm time.Time, fields ...string) *redis.IntSliceCmd {
//				panic("mock out the HExpireAt method")
//			},
//			HExpireAtWithArgsFunc: func(ctx context.Context, key string, tm time.Time, expirationArgs redis.HExpireArgs, fields ...string) *redis.IntSliceCmd {
//				panic("mock out the HExpireAtWithArgs method")
//			},
//			HExpireTimeFunc: func(ctx context.Context, key string, fields ...string) *redis.IntSliceCmd {
//				panic("mock out the HExpireTime method")
//			},
//			HExpireWithArgsFunc: func(ctx context.Context, key string, expiration time.Duration, expirationArgs redis.HExpireArgs, fields ...string) *redis.IntSliceCmd {
//				panic("mock out the HExpireWithArgs method")
//			},
//			HGetFunc: func(ctx context.Context, key string, field string) *redis.StringCmd {
//				panic("mock out the HGet method")
//			},
//			HGetAllFunc: func(ctx context.Context, key string) *redis.MapStringStringCmd {
//				panic("mock out the HGetAll method")
//			},
//			HGetDelFunc: func(ctx context.Context, key string, fields ...string) *redis.StringSliceCmd {
//				panic("mock out the HGetDel method")
//			},
//			HGetEXFunc: func(ctx context.Context, key string, fields ...string) *redis.StringSliceCmd {
//				panic("mock out the HGetEX method")
//			},
//			HGetEXWithArgsFunc: func(ctx context.Context, key string, options *redis.HGetEXOptions, fields ...string) *redis.StringSliceCmd {
//				panic("mock out the HGetEXWithArgs method")
//			},
//			HIncrByFunc: func(ctx context.Context, key string, field string, incr int64) *redis.IntCmd {
//				panic("mock out the HIncrBy method")
//			},
//			HIncrByFloatFunc: func(ctx context.Context, key string, field string, incr float64) *redis.FloatCmd {
//				panic("mock out the HIncrByFloat method")
//			},
//			HKeysFunc: func(ctx context.Context, key string) *redis.StringSliceCmd {
//				panic("mock out the HKeys method")
//			},
//			HLenFunc: func(ctx context.Context, key string) *redis.IntCmd {
//				panic("mock out the HLen method")
//			},
//			HMGetFunc: func(ctx context.Context, key string, fields ...string) *redis.SliceCmd {
//				panic("mock out the HMGet method")
//			},
//			HMSetFunc: func(ctx context.Context, key string, values ...interface{}) *redis.BoolCmd {
//				panic("mock out the HMSet method")
//			},
//			HPExpireFunc: func(ctx context.Context, key string, expiration time.Duration, fields ...string) *redis.IntSliceCmd {
//				panic("mock out the HPExpire method")
//			},
//			HPExpireAtFunc: func(ctx context.Context, key string, tm time.Time, fields ...string) *redis.IntSliceCmd {
//				panic("mock out the HPExpireAt method")
//			},
//			HPExpireAtWithArgsFunc: func(ctx context.Context, key string, tm time.Time, expirationArgs redis.HExpireArgs, fields ...string) *redis.IntSliceCmd {
//				panic("mock out the HPExpireAtWithArgs method")
//			},
//			HPExpireTimeFunc: func(ctx context.Context, key string, fields ...string) *redis.IntSliceCmd {
//				panic("mock out the HPExpireTime method")
//			},
//			HPExpireWithArgsFunc: func(ctx context.Context, key string, expiration time.Duration, expirationArgs redis.HExpireArgs, fields ...string) *redis.IntSliceCmd {
//				panic("mock out the HPExpireWithArgs method")
//			},
//			HPTTLFunc: func(ctx context.Context, key string, fields ...string) *redis.IntSliceCmd {
//				panic("mock out the HPTTL method")
//			},
//			HPersistFunc: func(ctx context.Context, key string, fields ...string) *redis.IntSliceCmd {
//				panic("mock out the HPersist method")
//			},
//			HRandFieldFunc: func(ctx context.Context, key string, count int) *redis.StringSliceCmd {
//				panic("mock out the HRandField method")
//			},
//			HRandFieldWithValuesFunc: func(ctx context.Context, key string, count int) *redis.KeyValueSliceCmd {
//				panic("mock out the HRandFieldWithValues method")
//			},
//			HScanFunc: func(ctx context.Context, key string, cursor uint64, match string, count int64) *redis.ScanCmd {
//				panic("mock out the HScan method")
//			},
//			HScanNoValuesFunc: func(ctx context.Context, key string, cursor uint64, match string, count int64) *redis.ScanCmd {
//				panic("mock out the HScanNoValues method")
//			},
//			HSetFunc: func(ctx context.Context, key string, values ...interface{}) *redis.IntCmd {
//				panic("mock out the HSet method")
//			},
//			HSetEXFunc: func(ctx context.Context, key string, fieldsAndValues ...string) *redis.IntCmd {
//				panic("mock out the HSetEX method")
//			},
//			HSetEXWithArgsFunc: func(ctx context.Context, key string, options *redis.HSetEXOptions, fieldsAndValues ...string) *redis.IntCmd {
//				panic("mock out the HSetEXWithArgs method")
//			},
//			HSetNXFunc: func(ctx context.Context, key string, field string, value interface{}) *redis.BoolCmd {
//				panic("mock out the HSetNX method")
//			},
//			HStrLenFunc: func(ctx context.Context, key string, field string) *redis.IntCmd {
//				panic("mock out the HStrLen method")
//			},
//			HTTLFunc: func(ctx context.Context, key string, fields ...string) *redis.IntSliceCmd {
//				panic("mock out the HTTL method")
//			},
//			HValsFunc: func(ctx context.Context, key string) *redis.StringSliceCmd {
//				panic("mock out the HVals method")
//			},
//			IncrFunc: func(ctx context.Context, key string) *redis.IntCmd {
//				panic("mock out the Incr method")
//			},
//			IncrByFunc: func(ctx context.Context, key string, value int64) *redis.IntCmd {
//				panic("mock out the IncrBy method")
//			},
//			IncrByFloatFunc: func(ctx context.Context, key string, value float64) *redis.FloatCmd {
//				panic("mock out the IncrByFloat method")
//			},
//			InfoFunc: func(ctx context.Context, section ...string) *redis.StringCmd {
//				panic("mock out the Info method")
//			},
//			JSONArrAppendFunc: func(ctx context.Context, key string, path string, values ...interface{}) *redis.IntSliceCmd {
//				panic("mock out the JSONArrAppend method")
//			},
//			JSONArrIndexFunc: func(ctx context.Context, key string, path string, value ...interface{}) *redis.IntSliceCmd {
//				panic("mock out the JSONArrIndex method")
//			},
//			JSONArrIndexWithArgsFunc: func(ctx context.Context, key string, path string, options *redis.JSONArrIndexArgs, value ...interface{}) *redis.IntSliceCmd {
//				panic("mock out the JSONArrIndexWithArgs method")
//			},
//			JSONArrInsertFunc: func(ctx context.Context, key string, path string, index int64, values ...interface{}) *redis.IntSliceCmd {
//				panic("mock out the JSONArrInsert method")
//			},
//			JSONArrLenFunc: func(ctx context.Context, key string, path string) *redis.IntSliceCmd {
//				panic("mock out the JSONArrLen method")
//			},
//			JSONArrPopFunc: func(ctx context.Context, key string, path string, index int) *redis.StringSliceCmd {
//				panic("mock out the JSONArrPop method")
//			},
//			JSONArrTrimFunc: func(ctx context.Context, key string, path string) *redis.IntSliceCmd {
//				panic("mock out the JSONArrTrim method")
//			},
//			JSONArrTrimWithArgsFunc: func(ctx context.Context, key string, path string, options *redis.JSONArrTrimArgs) *redis.IntSliceCmd {
//				panic("mock out the JSONArrTrimWithArgs method")
//			},
//			JSONClearFunc: func(ctx context.Context, key string, path string) *redis.IntCmd {
//				panic("mock out the JSONClear method")
//			},
//			JSONDebugMemoryFunc: func(ctx context.Context, key string, path string) *redis.IntCmd {
//				panic("mock out the JSONDebugMemory method")
//			},
//			JSONDelFunc: func(ctx context.Context, key string, path string) *redis.IntCmd {
//				panic("mock out the JSONDel method")
//			},
//			JSONForgetFunc: func(ctx context.Context, key string, path string) *redis.IntCmd {
//				panic("mock out the JSONForget method")
//			},
//			JSONGetFunc: func(ctx context.Context, key string, paths ...string) *redis.JSONCmd {
//				panic("mock out the JSONGet method")
//			},
//			JSONGetWithArgsFunc: func(ctx context.Context, key string, options *redis.JSONGetArgs, paths ...string) *redis.JSONCmd {
//				panic("mock out the JSONGetWithArgs method")
//			},
//			JSONMGetFunc: func(ctx context.Context, path string, keys ...string) *redis.JSONSliceCmd {
//				panic("mock out the JSONMGet method")
//			},
//			JSONMSetFunc: func(ctx context.Context, params ...interface{}) *redis.StatusCmd {
//				panic("mock out the JSONMSet method")
//			},
//			JSONMSetArgsFunc: func(ctx context.Context, docs []redis.JSONSetArgs) *redis.StatusCmd {
//				panic("mock out the JSONMSetArgs method")
//			},
//			JSONMergeFunc: func(ctx context.Context, key string, path string, value string) *redis.StatusCmd {
//				panic("mock out the JSONMerge method")
//			},
//			JSONNumIncrByFunc: func(ctx context.Context, key string, path string, value float64) *redis.JSONCmd {
//				panic("mock out the JSONNumIncrBy method")
//			},
//			JSONObjKeysFunc: func(ctx context.Context, key string, path string) *redis.SliceCmd {
//				panic("mock out the JSONObjKeys method")
//			},
//			JSONObjLenFunc: func(ctx context.Context, key string, path string) *redis.IntPointerSliceCmd {
//				panic("mock out the JSONObjLen method")
//			},
//			JSONSetFunc: func(ctx context.Context, key string, path string, value interface{}) *redis.StatusCmd {
//				panic("mock out the JSONSet method")
//			},
//			JSONSetModeFunc: func(ctx context.Context, key string, path string, value interface{}, mode string) *redis.StatusCmd {
//				panic("mock out the JSONSetMode method")
//			},
//			JSONStrAppendFunc: func(ctx context.Context, key string, path string, value string) *redis.IntPointerSliceCmd {
//				panic("mock out the JSONStrAppend method")
//			},
//			JSONStrLenFunc: func(ctx context.Context, key string, path string) *redis.IntPointerSliceCmd {
//				panic("mock out the JSONStrLen method")
//			},
//			JSONToggleFunc: func(ctx context.Context, key string, path string) *redis.IntPointerSliceCmd {
//				panic("mock out the JSONToggle method")
//			},
//			JSONTypeFunc: func(ctx context.Context, key string, path string) *redis.JSONSliceCmd {
//				panic("mock out the JSONType method")
//			},
//			KeysFunc: func(ctx context.Context, pattern string) *redis.StringSliceCmd {
//				panic("mock out the Keys method")
//			},
//			LCSFunc: func(ctx context.Context, q *redis.LCSQuery) *redis.LCSCmd {
//				panic("mock out the LCS method")
//			},
//			LIndexFunc: func(ctx context.Context, key string, index int64) *redis.StringCmd {
//				panic("mock out the LIndex method")
//			},
//			LInsertFunc: func(ctx context.Context, key string, op string, pivot interface{}, value interface{}) *redis.IntCmd {
//				panic("mock out the LInsert method")
//			},
//			LInsertAfterFunc: func(ctx context.Context, key string, pivot interface{}, value interface{}) *redis.IntCmd {
//				panic("mock out the LInsertAfter method")
//			},
//			LInsertBeforeFunc: func(ctx context.Context, key string, pivot interface{}, value interface{}) *redis.IntCmd {
//				panic("mock out the LInsertBefore method")
//			},
//			LLenFunc: func(ctx context.Context, key string) *redis.IntCmd {
//				panic("mock out the LLen method")
//			},
//			LMPopFunc: func(ctx context.Context, direction string, count int64, keys ...string) *redis.KeyValuesCmd {
//				panic("mock out the LMPop method")
//			},
//			LMoveFunc: func(ctx context.Context, source string, destination string, srcpos string, destpos string) *redis.StringCmd {
//				panic("mock out the LMove method")
//			},
//			LPopFunc: func(ctx context.Context, key string) *redis.StringCmd {
//				panic("mock out the LPop method")
//			},
//			LPopCountFunc: func(ctx context.Context, key string, count int) *redis.StringSliceCmd {
//				panic("mock out the LPopCount method")
//			},
//			LPosFunc: func(ctx context.Context, key string, value string, args redis.LPosArgs) *redis.IntCmd {
//				panic("mock out the LPos method")
//			},
//			LPosCountFunc: func(ctx context.Context, key string, value string, count int64, args redis.LPosArgs) *redis.IntSliceCmd {
//				panic("mock out the LPosCount method")
//			},
//			LPushFunc: func(ctx context.Context, key string, values ...interface{}) *redis.IntCmd {
//				panic("mock out the LPush method")
//			},
//			LPushXFunc: func(ctx context.Context, key string, values ...interface{}) *redis.IntCmd {
//				panic("mock out the LPushX method")
//			},
//			LRangeFunc: func(ctx context.Context, key string, start int64, stop int64) *redis.StringSliceCmd {
//				panic("mock out the LRange method")
//			},
//			LRemFunc: func(ctx context.Context, key string, count int64, value interface{}) *redis.IntCmd {
//				panic("mock out the LRem method")
//			},
//			LSetFunc: func(ctx context.Context, key string, index int64, value interface{}) *redis.StatusCmd {
//				panic("mock out the LSet method")
//			},
//			LTrimFunc: func(ctx context.Context, key string, start int64, stop int64) *redis.StatusCmd {
//				panic("mock out the LTrim method")
//			},
//			LastSaveFunc: func(ctx context.Context) *redis.IntCmd {
//				panic("mock out the LastSave method")
//			},
//			LatencyFunc: func(ctx context.Context) *redis.LatencyCmd {
//				panic("mock out the Latency method")
//			},
//			LatencyResetFunc: func(ctx context.Context, events ...interface{}) *redis.StatusCmd {
//				panic("mock out the LatencyReset method")
//			},
//			MGetFunc: func(ctx context.Context, keys ...string) *redis.SliceCmd {
//				panic("mock out the MGet method")
//			},
//			MSetFunc: func(ctx context.Context, values ...interface{}) *redis.StatusCmd {
//				panic("mock out the MSet method")
//			},
//			MSetEXFunc: func(ctx context.Context, args redis.MSetEXArgs, values ...interface{}) *redis.IntCmd {
//				panic("mock out the MSetEX method")
//			},
//			MSetNXFunc: func(ctx context.Context, values ...interface{}) *redis.BoolCmd {
//				panic("mock out the MSetNX method")
//			},
//			MemoryUsageFunc: func(ctx context.Context, key string, samples ...int) *redis.IntCmd {
//				panic("mock out the MemoryUsage method")
//			},
//			MigrateFunc: func(ctx context.Context, host string, port string, key string, db int, timeout time.Duration) *redis.StatusCmd {
//				panic("mock out the Migrate method")
//			},
//			ModuleLoadexFunc: func(ctx context.Context, conf *redis.ModuleLoadexConfig) *redis.StringCmd {
//				panic("mock out the ModuleLoadex method")
//			},
//			MoveFunc: func(ctx context.Context, key string, db int) *redis.BoolCmd {
//				panic("mock out the Move method")
//			},
//			ObjectEncodingFunc: func(ctx context.Context, key string) *redis.StringCmd {
//				panic("mock out the ObjectEncoding method")
//			},
//			ObjectFreqFunc: func(ctx context.Context, key string) *redis.IntCmd {
//				panic("mock out the ObjectFreq method")
//			},
//			ObjectIdleTimeFunc: func(ctx context.Context, key string) *redis.DurationCmd {
//				panic("mock out the ObjectIdleTime method")
//			},
//			ObjectRefCountFunc: func(ctx context.Context, key string) *redis.IntCmd {
//				panic("mock out the ObjectRefCount method")
//			},
//			PExpireFunc: func(ctx context.Context, key string, expiration time.Duration) *redis.BoolCmd {
//				panic("mock out the PExpire method")
//			},
//			PExpireAtFunc: func(ctx context.Context, key string, tm time.Time) *redis.BoolCmd {
//				panic("mock out the PExpireAt method")
//			},
//			PExpireTimeFunc: func(ctx context.Context, key string) *redis.DurationCmd {
//				panic("mock out the PExpireTime method")
//			},
//			PFAddFunc: func(ctx context.Context, key string, els ...interface{}) *redis.IntCmd {
//				panic("mock out the PFAdd method")
//			},
//			PFCountFunc: func(ctx context.Context, keys ...string) *redis.IntCmd {
//				panic("mock out the PFCount method")
//			},
//			PFMergeFunc: func(ctx context.Context, dest string, keys ...string) *redis.StatusCmd {
//				panic("mock out the PFMerge method")
//			},
//			PTTLFunc: func(ctx context.Context, key string) *redis.DurationCmd {
//				panic("mock out the PTTL method")
//			},
//			PersistFunc: func(ctx context.Context, key string) *redis.BoolCmd {
//				panic("mock out the Persist method")
//			},
//			PingFunc: func(ctx context.Context) *redis.StatusCmd {
//				panic("mock out the Ping method")
//			},
//			PipelineFunc: func() redis.Pipeliner {
//				panic("mock out the Pipeline method")
//			},
//			PipelinedFunc: func(ctx context.Context, fn func(redis.Pipeliner) error) ([]redis.Cmder, error) {
//				panic("mock out the Pipelined method")
//			},
//			PubSubChannelsFunc: func(ctx context.Context, pattern string) *redis.StringSliceCmd {
//				panic("mock out the PubSubChannels method")
//			},
//			PubSubNumPatFunc: func(ctx context.Context) *redis.IntCmd {
//				panic("mock out the PubSubNumPat method")
//			},
//			PubSubNumSubFunc: func(ctx context.Context, channels ...string) *redis.MapStringIntCmd {
//				panic("mock out the PubSubNumSub method")
//			},
//			PubSubShardChannelsFunc: func(ctx context.Context, pattern string) *redis.StringSliceCmd {
//				panic("mock out the PubSubShardChannels method")
//			},
//			PubSubShardNumSubFunc: func(ctx context.Context, channels ...string) *redis.MapStringIntCmd {
//				panic("mock out the PubSubShardNumSub method")
//			},
//			PublishFunc: func(ctx context.Context, channel string, message interface{}) *redis.IntCmd {
//				panic("mock out the Publish method")
//			},
//			QuitFunc: func(ctx context.Context) *redis.StatusCmd {
//				panic("mock out the Quit method")
//			},
//			RPopFunc: func(ctx context.Context, key string) *redis.StringCmd {
//				panic("mock out the RPop method")
//			},
//			RPopCountFunc: func(ctx context.Context, key string, count int) *redis.StringSliceCmd {
//				panic("mock out the RPopCount method")
//			},
//			RPopLPushFunc: func(ctx context.Context, source string, destination string) *redis.StringCmd {
//				panic("mock out the RPopLPush method")
//			},
//			RPushFunc: func(ctx context.Context, key string, values ...interface{}) *redis.IntCmd {
//				panic("mock out the RPush method")
//			},
//			RPushXFunc: func(ctx context.Context, key string, values ...interface{}) *redis.IntCmd {
//				panic("mock out the RPushX method")
//			},
//			RandomKeyFunc: func(ctx context.Context) *redis.StringCmd {
//				panic("mock out the RandomKey method")
//			},
//			ReadOnlyFunc: func(ctx context.Context) *redis.StatusCmd {
//				panic("mock out the ReadOnly method")
//			},
//			ReadWriteFunc: func(ctx context.Context) *redis.StatusCmd {
//				panic("mock out the ReadWrite method")
//			},
//			RenameFunc: func(ctx context.Context, key string, newkey string) *redis.StatusCmd {
//				panic("mock out the Rename method")
//			},
//			RenameNXFunc: func(ctx context.Context, key string, newkey string) *redis.BoolCmd {
//				panic("mock out the RenameNX method")
//			},
//			RestoreFunc: func(ctx context.Context, key string, ttl time.Duration, value string) *redis.StatusCmd {
//				panic("mock out the Restore method")
//			},
//			RestoreReplaceFunc: func(ctx context.Context, key string, ttl time.Duration, value string) *redis.StatusCmd {
//				panic("mock out the RestoreReplace method")
//			},
//			SAddFunc: func(ctx context.Context, key string, members ...interface{}) *redis.IntCmd {
//				panic("mock out the SAdd method")
//			},
//			SCardFunc: func(ctx context.Context, key string) *redis.IntCmd {
//				panic("mock out the SCard method")
//			},
//			SDiffFunc: func(ctx context.Context, keys ...string) *redis.StringSliceCmd {
//				panic("mock out the SDiff method")
//			},
//			SDiffStoreFunc: func(ctx context.Context, destination string, keys ...string) *redis.IntCmd {
//				panic("mock out the SDiffStore method")
//			},
//			SInterFunc: func(ctx context.Context, keys ...string) *redis.StringSliceCmd {
//				panic("mock out the SInter method")
//			},
//			SInterCardFunc: func(ctx context.Context, limit int64, keys ...string) *redis.IntCmd {
//				panic("mock out the SInterCard method")
//			},
//			SInterStoreFunc: func(ctx context.Context, destination string, keys ...string) *redis.IntCmd {
//				panic("mock out the SInterStore method")
//			},
//			SIsMemberFunc: func(ctx context.Context, key string, member interface{}) *redis.BoolCmd {
//				panic("mock out the SIsMember method")
//			},
//			SMIsMemberFunc: func(ctx context.Context, key string, members ...interface{}) *redis.BoolSliceCmd {
//				panic("mock out the SMIsMember method")
//			},
//			SMembersFunc: func(ctx context.Context, key string) *redis.StringSliceCmd {
//				panic("mock out the SMembers method")
//			},
//			SMembersMapFunc: func(ctx context.Context, key string) *redis.StringStructMapCmd {
//				panic("mock out the SMembersMap method")
//			},
//			SMoveFunc: func(ctx context.Context, source string, destination string, member interface{}) *redis.BoolCmd {
//				panic("mock out the SMove method")
//			},
//			SPopFunc: func(ctx context.Context, key string) *redis.StringCmd {
//				panic("mock out the SPop method")
//			},
//			SPopNFunc: func(ctx context.Context, key string, count int64) *redis.StringSliceCmd {
//				panic("mock out the SPopN method")
//			},
//			SPublishFunc: func(ctx context.Context, channel string, message interface{}) *redis.IntCmd {
//				panic("mock out the SPublish method")
//			},
//			SRandMemberFunc: func(ctx context.Context, key string) *redis.StringCmd {
//				panic("mock out the SRandMember method")
//			},
//			SRandMemberNFunc: func(ctx context.Context, key string, count int64) *redis.StringSliceCmd {
//				panic("mock out the SRandMemberN method")
//			},
//			SRemFunc: func(ctx context.Context, key string, members ...interface{}) *redis.IntCmd {
//				panic("mock out the SRem method")
//			},
//			SScanFunc: func(ctx context.Context, key string, cursor uint64, match string, count int64) *redis.ScanCmd {
//				panic("mock out the SScan method")
//			},
//			SUnionFunc: func(ctx context.Context, keys ...string) *redis.StringSliceCmd {
//				panic("mock out the SUnion method")
//			},
//			SUnionStoreFunc: func(ctx context.Context, destination string, keys ...string) *redis.IntCmd {
//				panic("mock out the SUnionStore method")
//			},
//			SaveFunc: func(ctx context.Context) *redis.StatusCmd {
//				panic("mock out the Save method")
//			},
//			ScanFunc: func(ctx context.Context, cursor uint64, match string, count int64) *redis.ScanCmd {
//				panic("mock out the Scan method")
//			},
//			ScanTypeFunc: func(ctx context.Context, cursor uint64, match string, count int64, keyType string) *redis.ScanCmd {
//				panic("mock out the ScanType method")
//			},
//			ScriptExistsFunc: func(ctx context.Context, hashes ...string) *redis.BoolSliceCmd {
//				panic("mock out the ScriptExists method")
//			},
//			ScriptFlushFunc: func(ctx context.Context) *redis.StatusCmd {
//				panic("mock out the ScriptFlush method")
//			},
//			ScriptKillFunc: func(ctx context.Context) *redis.StatusCmd {
//				panic("mock out the ScriptKill method")
//			},
//			ScriptLoadFunc: func(ctx context.Context, script string) *redis.StringCmd {
//				panic("mock out the ScriptLoad method")
//			},
//			SetFunc: func(ctx context.Context, key string, value interface{}, expiration time.Duration) *redis.StatusCmd {
//				panic("mock out the Set method")
//			},
//			SetArgsFunc: func(ctx context.Context, key string, value interface{}, a redis.SetArgs) *redis.StatusCmd {
//				panic("mock out the SetArgs method")
//			},
//			SetBitFunc: func(ctx context.Context, key string, offset int64, value int) *redis.IntCmd {
//				panic("mock out the SetBit method")
//			},
//			SetExFunc: func(ctx context.Context, key string, value interface{}, expiration time.Duration) *redis.StatusCmd {
//				panic("mock out the SetEx method")
//			},
//			SetIFDEQFunc: func(ctx context.Context, key string, value interface{}, matchDigest uint64, expiration time.Duration) *redis.StatusCmd {
//				panic("mock out the SetIFDEQ method")
//			},
//			SetIFDEQGetFunc: func(ctx context.Context, key string, value interface{}, matchDigest uint64, expiration time.Duration) *redis.StringCmd {
//				panic("mock out the SetIFDEQGet method")
//			},
//			SetIFDNEFunc: func(ctx context.Context, key string, value interface{}, matchDigest uint64, expiration time.Duration) *redis.StatusCmd {
//				panic("mock out the SetIFDNE method")
//			},
//			SetIFDNEGetFunc: func(ctx context.Context, key string, value interface{}, matchDigest uint64, expiration time.Duration) *redis.StringCmd {
//				panic("mock out the SetIFDNEGet method")
//			},
//			SetIFEQFunc: func(ctx context.Context, key string, value interface{}, matchValue interface{}, expiration time.Duration) *redis.StatusCmd {
//				panic("mock out the SetIFEQ method")
//			},
//			SetIFEQGetFunc: func(ctx context.Context, key string, value interface{}, matchValue interface{}, expiration time.Duration) *redis.StringCmd {
//				panic("mock out the SetIFEQGet method")
//			},
//			SetIFNEFunc: func(ctx context.Context, key string, value interface{}, matchValue interface{}, expiration time.Duration) *redis.StatusCmd {
//				panic("mock out the SetIFNE method")
//			},
//			SetIFNEGetFunc: func(ctx context.Context, key string, value interface{}, matchValue interface{}, expiration time.Duration) *redis.StringCmd {
//				panic("mock out the SetIFNEGet method")
//			},
//			SetNXFunc: func(ctx context.Context, key string, value interface{}, expiration time.Duration) *redis.BoolCmd {
//				panic("mock out the SetNX method")
//			},
//			SetRangeFunc: func(ctx context.Context, key string, offset int64, value string) *redis.IntCmd {
//				panic("mock out the SetRange method")
//			},
//			SetXXFunc: func(ctx context.Context, key string, value interface{}, expiration time.Duration) *redis.BoolCmd {
//				panic("mock out the SetXX method")
//			},
//			ShutdownFunc: func(ctx context.Context) *redis.StatusCmd {
//				panic("mock out the Shutdown method")
//			},
//			ShutdownNoSaveFunc: func(ctx context.Context) *redis.StatusCmd {
//				panic("mock out the ShutdownNoSave method")
//			},
//			ShutdownSaveFunc: func(ctx context.Context) *redis.StatusCmd {
//				panic("mock out the ShutdownSave method")
//			},
//			SlaveOfFunc: func(ctx context.Context, host string, port string) *redis.StatusCmd {
//				panic("mock out the SlaveOf method")
//			},
//			SlowLogGetFunc: func(ctx context.Context, num int64) *redis.SlowLogCmd {
//				panic("mock out the SlowLogGet method")
//			},
//			SlowLogLenFunc: func(ctx context.Context) *redis.IntCmd {
//				panic("mock out the SlowLogLen method")
//			},
//			SlowLogResetFunc: func(ctx context.Context) *redis.StatusCmd {
//				panic("mock out the SlowLogReset method")
//			},
//			SortFunc: func(ctx context.Context, key string, sort *redis.Sort) *redis.StringSliceCmd {
//				panic("mock out the Sort method")
//			},
//			SortInterfacesFunc: func(ctx context.Context, key string, sort *redis.Sort) *redis.SliceCmd {
//				panic("mock out the SortInterfaces method")
//			},
//			SortROFunc: func(ctx context.Context, key string, sort *redis.Sort) *redis.StringSliceCmd {
//				panic("mock out the SortRO method")
//			},
//			SortStoreFunc: func(ctx context.Context, key string, store string, sort *redis.Sort) *redis.IntCmd {
//				panic("mock out the SortStore method")
//			},
//			StrLenFunc: func(ctx context.Context, key string) *redis.IntCmd {
//				panic("mock out the StrLen method")
//			},
//			SubscribeFunc: func(ctx context.Context, channels ...string) *redis.PubSub {
//				panic("mock out the Subscribe method")
//			},
//			TDigestAddFunc: func(ctx context.Context, key string, elements ...float64) *redis.StatusCmd {
//				panic("mock out the TDigestAdd method")
//			},
//			TDigestByRankFunc: func(ctx context.Context, key string, rank ...uint64) *redis.FloatSliceCmd {
//				panic("mock out the TDigestByRank method")
//			},
//			TDigestByRevRankFunc: func(ctx context.Context, key string, rank ...uint64) *redis.FloatSliceCmd {
//				panic("mock out the TDigestByRevRank method")
//			},
//			TDigestCDFFunc: func(ctx context.Context, key string, elements ...float64) *redis.FloatSliceCmd {
//				panic("mock out the TDigestCDF method")
//			},
//			TDigestCreateFunc: func(ctx context.Context, key string) *redis.StatusCmd {
//				panic("mock out the TDigestCreate method")
//			},
//			TDigestCreateWithCompressionFunc: func(ctx context.Context, key string, compression int64) *redis.StatusCmd {
//				panic("mock out the TDigestCreateWithCompression method")
//			},
//			TDigestInfoFunc: func(ctx context.Context, key string) *redis.TDigestInfoCmd {
//				panic("mock out the TDigestInfo method")
//			},
//			TDigestMaxFunc: func(ctx context.Context, key string) *redis.FloatCmd {
//				panic("mock out the TDigestMax method")
//			},
//			TDigestMergeFunc: func(ctx context.Context, destKey string, options *redis.TDigestMergeOptions, sourceKeys ...string) *redis.StatusCmd {
//				panic("mock out the TDigestMerge method")
//			},
//			TDigestMinFunc: func(ctx context.Context, key string) *redis.FloatCmd {
//				panic("mock out the TDigestMin method")
//			},
//			TDigestQuantileFunc: func(ctx context.Context, key string, elements ...float64) *redis.FloatSliceCmd {
//				panic("mock out the TDigestQuantile method")
//			},
//			TDigestRankFunc: func(ctx context.Context, key string, values ...float64) *redis.IntSliceCmd {
//				panic("mock out the TDigestRank method")
//			},
//			TDigestResetFunc: func(ctx context.Context, key string) *redis.StatusCmd {
//				panic("mock out the TDigestReset method")
//			},
//			TDigestRevRankFunc: func(ctx context.Context, key string, values ...float64) *redis.IntSliceCmd {
//				panic("mock out the TDigestRevRank method")
//			},
//			TDigestTrimmedMeanFunc: func(ctx context.Context, key string, lowCutQuantile float64, highCutQuantile float64) *redis.FloatCmd {
//				panic("mock out the TDigestTrimmedMean method")
//			},
//			TSAddFunc: func(ctx context.Context, key string, timestamp interface{}, value float64) *redis.IntCmd {
//				panic("mock out the TSAdd method")
//			},
//			TSAddWithArgsFunc: func(ctx context.Context, key string, timestamp interface{}, value float64, options *redis.TSOptions) *redis.IntCmd {
//				panic("mock out the TSAddWithArgs method")
//			},
//			TSAlterFunc: func(ctx context.Context, key string, options *redis.TSAlterOptions) *redis.StatusCmd {
//				panic("mock out the TSAlter method")
//			},
//			TSCreateFunc: func(ctx context.Context, key string) *redis.StatusCmd {
//				panic("mock out the TSCreate method")
//			},
//			TSCreateRuleFunc: func(ctx context.Context, sourceKey string, destKey string, aggregator redis.Aggregator, bucketDuration int) *redis.StatusCmd {
//				panic("mock out the TSCreateRule method")
//			},
//			TSCreateRuleWithArgsFunc: func(ctx context.Context, sourceKey string, destKey string, aggregator redis.Aggregator, bucketDuration int, options *redis.TSCreateRuleOptions) *redis.StatusCmd {
//				panic("mock out the TSCreateRuleWithArgs method")
//			},
//			TSCreateWithArgsFunc: func(ctx context.Context, key string, options *redis.TSOptions) *redis.StatusCmd {
//				panic("mock out the TSCreateWithArgs method")
//			},
//			TSDecrByFunc: func(ctx context.Context, Key string, timestamp float64) *redis.IntCmd {
//				panic("mock out the TSDecrBy method")
//			},
//			TSDecrByWithArgsFunc: func(ctx context.Context, key string, timestamp float64, options *redis.TSIncrDecrOptions) *redis.IntCmd {
//				panic("mock out the TSDecrByWithArgs method")
//			},
//			TSDelFunc: func(ctx context.Context, Key string, fromTimestamp int, toTimestamp int) *redis.IntCmd {
//				panic("mock out the TSDel method")
//			},
//			TSDeleteRuleFunc: func(ctx context.Context, sourceKey string, destKey string) *redis.StatusCmd {
//				panic("mock out the TSDeleteRule method")
//			},
//			TSGetFunc: func(ctx context.Context, key string) *redis.TSTimestampValueCmd {
//				panic("mock out the TSGet method")
//			},
//			TSGetWithArgsFunc: func(ctx context.Context, key string, options *redis.TSGetOptions) *redis.TSTimestampValueCmd {
//				panic("mock out the TSGetWithArgs method")
//			},
//			TSIncrByFunc: func(ctx context.Context, Key string, timestamp float64) *redis.IntCmd {
//				panic("mock out the TSIncrBy method")
//			},
//			TSIncrByWithArgsFunc: func(ctx context.Context, key string, timestamp float64, options *redis.TSIncrDecrOptions) *redis.IntCmd {
//				panic("mock out the TSIncrByWithArgs method")
//			},
//			TSInfoFunc: func(ctx context.Context, key string) *redis.MapStringInterfaceCmd {
//				panic("mock out the TSInfo method")
//			},
//			TSInfoWithArgsFunc: func(ctx context.Context, key string, options *redis.TSInfoOptions) *redis.MapStringInterfaceCmd {
//				panic("mock out the TSInfoWithArgs method")
//			},
//			TSMAddFunc: func(ctx context.Context, ktvSlices [][]interface{}) *redis.IntSliceCmd {
//				panic("mock out the TSMAdd method")
//			},
//			TSMGetFunc: func(ctx context.Context, filters []string) *redis.MapStringSliceInterfaceCmd {
//				panic("mock out the TSMGet method")
//			},
//			TSMGetWithArgsFunc: func(ctx context.Context, filters []string, options *redis.TSMGetOptions) *redis.MapStringSliceInterfaceCmd {
//				panic("mock out the TSMGetWithArgs method")
//			},
//			TSMRangeFunc: func(ctx context.Context, fromTimestamp int, toTimestamp int, filterExpr []string) *redis.MapStringSliceInterfaceCmd {
//				panic("mock out the TSMRange method")
//			},
//			TSMRangeWithArgsFunc: func(ctx context.Context, fromTimestamp int, toTimestamp int, filterExpr []string, options *redis.TSMRangeOptions) *redis.MapStringSliceInterfaceCmd {
//				panic("mock out the TSMRangeWithArgs method")
//			},
//			TSMRevRangeFunc: func(ctx context.Context, fromTimestamp int, toTimestamp int, filterExpr []string) *redis.MapStringSliceInterfaceCmd {
//				panic("mock out the TSMRevRange method")
//			},
//			TSMRevRangeWithArgsFunc: func(ctx context.Context, fromTimestamp int, toTimestamp int, filterExpr []string, options *redis.TSMRevRangeOptions) *redis.MapStringSliceInterfaceCmd {
//				panic("mock out the TSMRevRangeWithArgs method")
//			},
//			TSQueryIndexFunc: func(ctx context.Context, filterExpr []string) *redis.StringSliceCmd {
//				panic("mock out the TSQueryIndex method")
//			},
//			TSRangeFunc: func(ctx context.Context, key string, fromTimestamp int, toTimestamp int) *redis.TSTimestampValueSliceCmd {
//				panic("mock out the TSRange method")
//			},
//			TSRangeWithArgsFunc: func(ctx context.Context, key string, fromTimestamp int, toTimestamp int, options *redis.TSRangeOptions) *redis.TSTimestampValueSliceCmd {
//				panic("mock out the TSRangeWithArgs method")
//			},
//			TSRevRangeFunc: func(ctx context.Context, key string, fromTimestamp int, toTimestamp int) *redis.TSTimestampValueSliceCmd {
//				panic("mock out the TSRevRange method")
//			},
//			TSRevRangeWithArgsFunc: func(ctx context.Context, key string, fromTimestamp int, toTimestamp int, options *redis.TSRevRangeOptions) *redis.TSTimestampValueSliceCmd {
//				panic("mock out the TSRevRangeWithArgs method")
//			},
//			TTLFunc: func(ctx context.Context, key string) *redis.DurationCmd {
//				panic("mock out the TTL method")
//			},
//			TimeFunc: func(ctx context.Context) *redis.TimeCmd {
//				panic("mock out the Time method")
//			},
//			TopKAddFunc: func(ctx context.Context, key string, elements ...interface{}) *redis.StringSliceCmd {
//				panic("mock out the TopKAdd method")
//			},
//			TopKCountFunc: func(ctx context.Context, key string, elements ...interface{}) *redis.IntSliceCmd {
//				panic("mock out the TopKCount method")
//			},
//			TopKIncrByFunc: func(ctx context.Context, key string, elements ...interface{}) *redis.StringSliceCmd {
//				panic("mock out the TopKIncrBy method")
//			},
//			TopKInfoFunc: func(ctx context.Context, key string) *redis.TopKInfoCmd {
//				panic("mock out the TopKInfo method")
//			},
//			TopKListFunc: func(ctx context.Context, key string) *redis.StringSliceCmd {
//				panic("mock out the TopKList method")
//			},
//			TopKListWithCountFunc: func(ctx context.Context, key string) *redis.MapStringIntCmd {
//				panic("mock out the TopKListWithCount method")
//			},
//			TopKQueryFunc: func(ctx context.Context, key string, elements ...interface{}) *redis.BoolSliceCmd {
//				panic("mock out the TopKQuery method")
//			},
//			TopKReserveFunc: func(ctx context.Context, key string, k int64) *redis.StatusCmd {
//				panic("mock out the TopKReserve method")
//			},
//			TopKReserveWithOptionsFunc: func(ctx context.Context, key string, k int64, width int64, depth int64, decay float64) *redis.StatusCmd {
//				panic("mock out the TopKReserveWithOptions method")
//			},
//			TouchFunc: func(ctx context.Context, keys ...string) *redis.IntCmd {
//				panic("mock out the Touch method")
//			},
//			TxPipelineFunc: func() redis.Pipeliner {
//				panic("mock out the TxPipeline method")
//			},
//			TxPipelinedFunc: func(ctx context.Context, fn func(redis.Pipeliner) error) ([]redis.Cmder, error) {
//				panic("mock out the TxPipelined method")
//			},
//			TypeFunc: func(ctx context.Context, key string) *redis.StatusCmd {
//				panic("mock out the Type method")
//			},
//			UnlinkFunc: func(ctx context.Context, keys ...string) *redis.IntCmd {
//				panic("mock out the Unlink method")
//			},
//			VAddFunc: func(ctx context.Context, key string, element string, val redis.Vector) *redis.BoolCmd {
//				panic("mock out the VAdd method")
//			},
//			VAddWithArgsFunc: func(ctx context.Context, key string, element string, val redis.Vector, addArgs *redis.VAddArgs) *redis.BoolCmd {
//				panic("mock out the VAddWithArgs method")
//			},
//			VCardFunc: func(ctx context.Context, key string) *redis.IntCmd {
//				panic("mock out the VCard method")
//			},
//			VClearAttributesFunc: func(ctx context.Context, key string, element string) *redis.BoolCmd {
//				panic("mock out the VClearAttributes method")
//			},
//			VDimFunc: func(ctx context.Context, key string) *redis.IntCmd {
//				panic("mock out the VDim method")
//			},
//			VEmbFunc: func(ctx context.Context, key string, element string, raw bool) *redis.SliceCmd {
//				panic("mock out the VEmb method")
//			},
//			VGetAttrFunc: func(ctx context.Context, key string, element string) *redis.StringCmd {
//				panic("mock out the VGetAttr method")
//			},
//			VInfoFunc: func(ctx context.Context, key string) *redis.MapStringInterfaceCmd {
//				panic("mock out the VInfo method")
//			},
//			VLinksFunc: func(ctx context.Context, key string, element string) *redis.StringSliceCmd {
//				panic("mock out the VLinks method")
//			},
//			VLinksWithScoresFunc: func(ctx context.Context, key string, element string) *redis.VectorScoreSliceCmd {
//				panic("mock out the VLinksWithScores method")
//			},
//			VRandMemberFunc: func(ctx context.Context, key string) *redis.StringCmd {
//				panic("mock out the VRandMember method")
//			},
//			VRandMemberCountFunc: func(ctx context.Context, key string, count int) *redis.StringSliceCmd {
//				panic("mock out the VRandMemberCount method")
//			},
//			VRangeFunc: func(ctx context.Context, key string, start string, end string, count int64) *redis.StringSliceCmd {
//				panic("mock out the VRange method")
//			},
//			VRemFunc: func(ctx context.Context, key string, element string) *redis.BoolCmd {
//				panic("mock out the VRem method")
//			},
//			VSetAttrFunc: func(ctx context.Context, key string, element string, attr interface{}) *redis.BoolCmd {
//				panic("mock out the VSetAttr method")
//			},
//			VSimFunc: func(ctx context.Context, key string, val redis.Vector) *redis.StringSliceCmd {
//				panic("mock out the VSim method")
//			},
//			VSimWithArgsFunc: func(ctx context.Context, key string, val redis.Vector, args *redis.VSimArgs) *redis.StringSliceCmd {
//				panic("mock out the VSimWithArgs method")
//			},
//			VSimWithArgsWithScoresFunc: func(ctx context.Context, key string, val redis.Vector, args *redis.VSimArgs) *redis.VectorScoreSliceCmd {
//				panic("mock out the VSimWithArgsWithScores method")
//			},
//			VSimWithScoresFunc: func(ctx context.Context, key string, val redis.Vector) *redis.VectorScoreSliceCmd {
//				panic("mock out the VSimWithScores method")
//			},
//			XAckFunc: func(ctx context.Context, stream string, group string, ids ...string) *redis.IntCmd {
//				panic("mock out the XAck method")
//			},
//			XAckDelFunc: func(ctx context.Context, stream string, group string, mode string, ids ...string) *redis.SliceCmd {
//				panic("mock out the XAckDel method")
//			},
//			XAddFunc: func(ctx context.Context, a *redis.XAddArgs) *redis.StringCmd {
//				panic("mock out the XAdd method")
//			},
//			XAutoClaimFunc: func(ctx context.Context, a *redis.XAutoClaimArgs) *redis.XAutoClaimCmd {
//				panic("mock out the XAutoClaim method")
//			},
//			XAutoClaimJustIDFunc: func(ctx context.Context, a *redis.XAutoClaimArgs) *redis.XAutoClaimJustIDCmd {
//				panic("mock out the XAutoClaimJustID method")
//			},
//			XCfgSetFunc: func(ctx context.Context, a *redis.XCfgSetArgs) *redis.StatusCmd {
//				panic("mock out the XCfgSet method")
//			},
//			XClaimFunc: func(ctx context.Context, a *redis.XClaimArgs) *redis.XMessageSliceCmd {
//				panic("mock out the XClaim method")
//			},
//			XClaimJustIDFunc: func(ctx context.Context, a *redis.XClaimArgs) *redis.StringSliceCmd {
//				panic("mock out the XClaimJustID method")
//			},
//			XDelFunc: func(ctx context.Context, stream string, ids ...string) *redis.IntCmd {
//				panic("mock out the XDel method")
//			},
//			XDelExFunc: func(ctx context.Context, stream string, mode string, ids ...string) *redis.SliceCmd {
//				panic("mock out the XDelEx method")
//			},
//			XGroupCreateFunc: func(ctx context.Context, stream string, group string, start string) *redis.StatusCmd {
//				panic("mock out the XGroupCreate method")
//			},
//			XGroupCreateConsumerFunc: func(ctx context.Context, stream string, group string, consumer string) *redis.IntCmd {
//				panic("mock out the XGroupCreateConsumer method")
//			},
//			XGroupCreateMkStreamFunc: func(ctx context.Context, stream string, group string, start string) *redis.StatusCmd {
//				panic("mock out the XGroupCreateMkStream method")
//			},
//			XGroupDelConsumerFunc: func(ctx context.Context, stream string, group string, consumer string) *redis.IntCmd {
//				panic("mock out the XGroupDelConsumer method")
//			},
//			XGroupDestroyFunc: func(ctx context.Context, stream string, group string) *redis.IntCmd {
//				panic("mock out the XGroupDestroy method")
//			},
//			XGroupSetIDFunc: func(ctx context.Context, stream string, group string, start string) *redis.StatusCmd {
//				panic("mock out the XGroupSetID method")
//			},
//			XInfoConsumersFunc: func(ctx context.Context, key string, group string) *redis.XInfoConsumersCmd {
//				panic("mock out the XInfoConsumers method")
//			},
//			XInfoGroupsFunc: func(ctx context.Context, key string) *redis.XInfoGroupsCmd {
//				panic("mock out the XInfoGroups method")
//			},
//			XInfoStreamFunc: func(ctx context.Context, key string) *redis.XInfoStreamCmd {
//				panic("mock out the XInfoStream method")
//			},
//			XInfoStreamFullFunc: func(ctx context.Context, key string, count int) *redis.XInfoStreamFullCmd {
//				panic("mock out the XInfoStreamFull method")
//			},
//			XLenFunc: func(ctx context.Context, stream string) *redis.IntCmd {
//				panic("mock out the XLen method")
//			},
//			XPendingFunc: func(ctx context.Context, stream string, group string) *redis.XPendingCmd {
//				panic("mock out the XPending method")
//			},
//			XPendingExtFunc: func(ctx context.Context, a *redis.XPendingExtArgs) *redis.XPendingExtCmd {
//				panic("mock out the XPendingExt method")
//			},
//			XRangeFunc: func(ctx context.Context, stream string, start string, stop string) *redis.XMessageSliceCmd {
//				panic("mock out the XRange method")
//			},
//			XRangeNFunc: func(ctx context.Context, stream string, start string, stop string, count int64) *redis.XMessageSliceCmd {
//				panic("mock out the XRangeN method")
//			},
//			XReadFunc: func(ctx context.Context, a *redis.XReadArgs) *redis.XStreamSliceCmd {
//				panic("mock out the XRead method")
//			},
//			XReadGroupFunc: func(ctx context.Context, a *redis.XReadGroupArgs) *redis.XStreamSliceCmd {
//				panic("mock out the XReadGroup method")
//			},
//			XReadStreamsFunc: func(ctx context.Context, streams ...string) *redis.XStreamSliceCmd {
//				panic("mock out the XReadStreams method")
//			},
//			XRevRangeFunc: func(ctx context.Context, stream string, start string, stop string) *redis.XMessageSliceCmd {
//				panic("mock out the XRevRange method")
//			},
//			XRevRangeNFunc: func(ctx context.Context, stream string, start string, stop string, count int64) *redis.XMessageSliceCmd {
//				panic("mock out the XRevRangeN method")
//			},
//			XTrimMaxLenFunc: func(ctx context.Context, key string, maxLen int64) *redis.IntCmd {
//				panic("mock out the XTrimMaxLen method")
//			},
//			XTrimMaxLenApproxFunc: func(ctx context.Context, key string, maxLen int64, limit int64) *redis.IntCmd {
//				panic("mock out the XTrimMaxLenApprox method")
//			},
//			XTrimMaxLenApproxModeFunc: func(ctx context.Context, key string, maxLen int64, limit int64, mode string) *redis.IntCmd {
//				panic("mock out the XTrimMaxLenApproxMode method")
//			},
//			XTrimMaxLenModeFunc: func(ctx context.Context, key string, maxLen int64, mode string) *redis.IntCmd {
//				panic("mock out the XTrimMaxLenMode method")
//			},
//			XTrimMinIDFunc: func(ctx context.Context, key string, minID string) *redis.IntCmd {
//				panic("mock out the XTrimMinID method")
//			},
//			XTrimMinIDApproxFunc: func(ctx context.Context, key string, minID string, limit int64) *redis.IntCmd {
//				panic("mock out the XTrimMinIDApprox method")
//			},
//			XTrimMinIDApproxModeFunc: func(ctx context.Context, key string, minID string, limit int64, mode string) *redis.IntCmd {
//				panic("mock out the XTrimMinIDApproxMode method")
//			},
//			XTrimMinIDModeFunc: func(ctx context.Context, key string, minID string, mode string) *redis.IntCmd {
//				panic("mock out the XTrimMinIDMode method")
//			},
//			ZAddFunc: func(ctx context.Context, key string, members ...redis.Z) *redis.IntCmd {
//				panic("mock out the ZAdd method")
//			},
//			ZAddArgsFunc: func(ctx context.Context, key string, args redis.ZAddArgs) *redis.IntCmd {
//				panic("mock out the ZAddArgs method")
//			},
//			ZAddArgsIncrFunc: func(ctx context.Context, key string, args redis.ZAddArgs) *redis.FloatCmd {
//				panic("mock out the ZAddArgsIncr method")
//			},
//			ZAddGTFunc: func(ctx context.Context, key string, members ...redis.Z) *redis.IntCmd {
//				panic("mock out the ZAddGT method")
//			},
//			ZAddLTFunc: func(ctx context.Context, key string, members ...redis.Z) *redis.IntCmd {
//				panic("mock out the ZAddLT method")
//			},
//			ZAddNXFunc: func(ctx context.Context, key string, members ...redis.Z) *redis.IntCmd {
//				panic("mock out the ZAddNX method")
//			},
//			ZAddXXFunc: func(ctx context.Context, key string, members ...redis.Z) *redis.IntCmd {
//				panic("mock out the ZAddXX method")
//			},
//			ZCardFunc: func(ctx context.Context, key string) *redis.IntCmd {
//				panic("mock out the ZCard method")
//			},
//			ZCountFunc: func(ctx context.Context, key string, min string, max string) *redis.IntCmd {
//				panic("mock out the ZCount method")
//			},
//			ZDiffFunc: func(ctx context.Context, keys ...string) *redis.StringSliceCmd {
//				panic("mock out the ZDiff method")
//			},
//			ZDiffStoreFunc: func(ctx context.Context, destination string, keys ...string) *redis.IntCmd {
//				panic("mock out the ZDiffStore method")
//			},
//			ZDiffWithScoresFunc: func(ctx context.Context, keys ...string) *redis.ZSliceCmd {
//				panic("mock out the ZDiffWithScores method")
//			},
//			ZIncrByFunc: func(ctx context.Context, key string, increment float64, member string) *redis.FloatCmd {
//				panic("mock out the ZIncrBy method")
//			},
//			ZInterFunc: func(ctx context.Context, store *redis.ZStore) *redis.StringSliceCmd {
//				panic("mock out the ZInter method")
//			},
//			ZInterCardFunc: func(ctx context.Context, limit int64, keys ...string) *redis.IntCmd {
//				panic("mock out the ZInterCard method")
//			},
//			ZInterStoreFunc: func(ctx context.Context, destination string, store *redis.ZStore) *redis.IntCmd {
//				panic("mock out the ZInterStore method")
//			},
//			ZInterWithScoresFunc: func(ctx context.Context, store *redis.ZStore) *redis.ZSliceCmd {
//				panic("mock out the ZInterWithScores method")
//			},
//			ZLexCountFunc: func(ctx context.Context, key string, min string, max string) *redis.IntCmd {
//				panic("mock out the ZLexCount method")
//			},
//			ZMPopFunc: func(ctx context.Context, order string, count int64, keys ...string) *redis.ZSliceWithKeyCmd {
//				panic("mock out the ZMPop method")
//			},
//			ZMScoreFunc: func(ctx context.Context, key string, members ...string) *redis.FloatSliceCmd {
//				panic("mock out the ZMScore method")
//			},
//			ZPopMaxFunc: func(ctx context.Context, key string, count ...int64) *redis.ZSliceCmd {
//				panic("mock out the ZPopMax method")
//			},
//			ZPopMinFunc: func(ctx context.Context, key string, count ...int64) *redis.ZSliceCmd {
//				panic("mock out the ZPopMin method")
//			},
//			ZRandMemberFunc: func(ctx context.Context, key string, count int) *redis.StringSliceCmd {
//				panic("mock out the ZRandMember method")
//			},
//			ZRandMemberWithScoresFunc: func(ctx context.Context, key string, count int) *redis.ZSliceCmd {
//				panic("mock out the ZRandMemberWithScores method")
//			},
//			ZRangeFunc: func(ctx context.Context, key string, start int64, stop int64) *redis.StringSliceCmd {
//				panic("mock out the ZRange method")
//			},
//			ZRangeArgsFunc: func(ctx context.Context, z redis.ZRangeArgs) *redis.StringSliceCmd {
//				panic("mock out the ZRangeArgs method")
//			},
//			ZRangeArgsWithScoresFunc: func(ctx context.Context, z redis.ZRangeArgs) *redis.ZSliceCmd {
//				panic("mock out the ZRangeArgsWithScores method")
//			},
//			ZRangeByLexFunc: func(ctx context.Context, key string, opt *redis.ZRangeBy) *redis.StringSliceCmd {
//				panic("mock out the ZRangeByLex method")
//			},
//			ZRangeByScoreFunc: func(ctx context.Context, key string, opt *redis.ZRangeBy) *redis.StringSliceCmd {
//				panic("mock out the ZRangeByScore method")
//			},
//			ZRangeByScoreWithScoresFunc: func(ctx context.Context, key string, opt *redis.ZRangeBy) *redis.ZSliceCmd {
//				panic("mock out the ZRangeByScoreWithScores method")
//			},
//			ZRangeStoreFunc: func(ctx context.Context, dst string, z redis.ZRangeArgs) *redis.IntCmd {
//				panic("mock out the ZRangeStore method")
//			},
//			ZRangeWithScoresFunc: func(ctx context.Context, key string, start int64, stop int64) *redis.ZSliceCmd {
//				panic("mock out the ZRangeWithScores method")
//			},
//			ZRankFunc: func(ctx context.Context, key string, member string) *redis.IntCmd {
//				panic("mock out the ZRank method")
//			},
//			ZRankWithScoreFunc: func(ctx context.Context, key string, member string) *redis.RankWithScoreCmd {
//				panic("mock out the ZRankWithScore method")
//			},
//			ZRemFunc: func(ctx context.Context, key string, members ...interface{}) *redis.IntCmd {
//				panic("mock out the ZRem method")
//			},
//			ZRemRangeByLexFunc: func(ctx context.Context, key string, min string, max string) *redis.IntCmd {
//				panic("mock out the ZRemRangeByLex method")
//			},
//			ZRemRangeByRankFunc: func(ctx context.Context, key string, start int64, stop int64) *redis.IntCmd {
//				panic("mock out the ZRemRangeByRank method")
//			},
//			ZRemRangeByScoreFunc: func(ctx context.Context, key string, min string, max string) *redis.IntCmd {
//				panic("mock out the ZRemRangeByScore method")
//			},
//			ZRevRangeFunc: func(ctx context.Context, key string, start int64, stop int64) *redis.StringSliceCmd {
//				panic("mock out the ZRevRange method")
//			},
//			ZRevRangeByLexFunc: func(ctx context.Context, key string, opt *redis.ZRangeBy) *redis.StringSliceCmd {
//				panic("mock out the ZRevRangeByLex method")
//			},
//			ZRevRangeByScoreFunc: func(ctx context.Context, key string, opt *redis.ZRangeBy) *redis.StringSliceCmd {
//				panic("mock out the ZRevRangeByScore method")
//			},
//			ZRevRangeByScoreWithScoresFunc: func(ctx context.Context, key string, opt *redis.ZRangeBy) *redis.ZSliceCmd {
//				panic("mock out the ZRevRangeByScoreWithScores method")
//			},
//			ZRevRangeWithScoresFunc: func(ctx context.Context, key string, start int64, stop int64) *redis.ZSliceCmd {
//				panic("mock out the ZRevRangeWithScores method")
//			},
//			ZRevRankFunc: func(ctx context.Context, key string, member string) *redis.IntCmd {
//				panic("mock out the ZRevRank method")
//			},
//			ZRevRankWithScoreFunc: func(ctx context.Context, key string, member string) *redis.RankWithScoreCmd {
//				panic("mock out the ZRevRankWithScore method")
//			},
//			ZScanFunc: func(ctx context.Context, key string, cursor uint64, match string, count int64) *redis.ScanCmd {
//				panic("mock out the ZScan method")
//			},
//			ZScoreFunc: func(ctx context.Context, key string, member string) *redis.FloatCmd {
//				panic("mock out the ZScore method")
//			},
//			ZUnionFunc: func(ctx context.Context, store redis.ZStore) *redis.StringSliceCmd {
//				panic("mock out the ZUnion method")
//			},
//			ZUnionStoreFunc: func(ctx context.Context, dest string, store *redis.ZStore) *redis.IntCmd {
//				panic("mock out the ZUnionStore method")
//			},
//			ZUnionWithScoresFunc: func(ctx context.Context, store redis.ZStore) *redis.ZSliceCmd {
//				panic("mock out the ZUnionWithScores method")
//			},
//		}
//
//		// use mockedCmdable in code that requires Cmdable
//		// and then make assertions.
//
//	}
type MoqCmdable struct {
	// ACLCatFunc mocks the ACLCat method.
	ACLCatFunc func(ctx context.Context) *redis.StringSliceCmd

	// ACLCatArgsFunc mocks the ACLCatArgs method.
	ACLCatArgsFunc func(ctx context.Context, options *redis.ACLCatArgs) *redis.StringSliceCmd

	// ACLDelUserFunc mocks the ACLDelUser method.
	ACLDelUserFunc func(ctx context.Context, username string) *redis.IntCmd

	// ACLDryRunFunc mocks the ACLDryRun method.
	ACLDryRunFunc func(ctx context.Context, username string, command ...interface{}) *redis.StringCmd

	// ACLGenPassFunc mocks the ACLGenPass method.
	ACLGenPassFunc func(ctx context.Context, bit int) *redis.StringCmd

	// ACLListFunc mocks the ACLList method.
	ACLListFunc func(ctx context.Context) *redis.StringSliceCmd

	// ACLLogFunc mocks the ACLLog method.
	ACLLogFunc func(ctx context.Context, count int64) *redis.ACLLogCmd

	// ACLLogResetFunc mocks the ACLLogReset method.
	ACLLogResetFunc func(ctx context.Context) *redis.StatusCmd

	// ACLSetUserFunc mocks the ACLSetUser method.
	ACLSetUserFunc func(ctx context.Context, username string, rules ...string) *redis.StatusCmd

	// ACLUsersFunc mocks the ACLUsers method.
	ACLUsersFunc func(ctx context.Context) *redis.StringSliceCmd

	// ACLWhoAmIFunc mocks the ACLWhoAmI method.
	ACLWhoAmIFunc func(ctx context.Context) *redis.StringCmd

	// AppendFunc mocks the Append method.
	AppendFunc func(ctx context.Context, key string, value string) *redis.IntCmd

	// BFAddFunc mocks the BFAdd method.
	BFAddFunc func(ctx context.Context, key string, element interface{}) *redis.BoolCmd

	// BFCardFunc mocks the BFCard method.
	BFCardFunc func(ctx context.Context, key string) *redis.IntCmd

	// BFExistsFunc mocks the BFExists method.
	BFExistsFunc func(ctx context.Context, key string, element interface{}) *redis.BoolCmd

	// BFInfoFunc mocks the BFInfo method.
	BFInfoFunc func(ctx context.Context, key string) *redis.BFInfoCmd

	// BFInfoArgFunc mocks the BFInfoArg method.
	BFInfoArgFunc func(ctx context.Context, key string, option string) *redis.BFInfoCmd

	// BFInfoCapacityFunc mocks the BFInfoCapacity method.
	BFInfoCapacityFunc func(ctx context.Context, key string) *redis.BFInfoCmd

	// BFInfoExpansionFunc mocks the BFInfoExpansion method.
	BFInfoExpansionFunc func(ctx context.Context, key string) *redis.BFInfoCmd

	// BFInfoFiltersFunc mocks the BFInfoFilters method.
	BFInfoFiltersFunc func(ctx context.Context, key string) *redis.BFInfoCmd

	// BFInfoItemsFunc mocks the BFInfoItems method.
	BFInfoItemsFunc func(ctx context.Context, key string) *redis.BFInfoCmd

	// BFInfoSizeFunc mocks the BFInfoSize method.
	BFInfoSizeFunc func(ctx context.Context, key string) *redis.BFInfoCmd

	// BFInsertFunc mocks the BFInsert method.
	BFInsertFunc func(ctx context.Context, key string, options *redis.BFInsertOptions, elements ...interface{}) *redis.BoolSliceCmd

	// BFLoadChunkFunc mocks the BFLoadChunk method.
	BFLoadChunkFunc func(ctx context.Context, key string, iterator int64, data interface{}) *redis.StatusCmd

	// BFMAddFunc mocks the BFMAdd method.
	BFMAddFunc func(ctx context.Context, key string, elements ...interface{}) *redis.BoolSliceCmd

	// BFMExistsFunc mocks the BFMExists method.
	BFMExistsFunc func(ctx context.Context, key string, elements ...interface{}) *redis.BoolSliceCmd

	// BFReserveFunc mocks the BFReserve method.
	BFReserveFunc func(ctx context.Context, key string, errorRate float64, capacity int64) *redis.StatusCmd

	// BFReserveExpansionFunc mocks the BFReserveExpansion method.
	BFReserveExpansionFunc func(ctx context.Context, key string, errorRate float64, capacity int64, expansion int64) *redis.StatusCmd

	// BFReserveNonScalingFunc mocks the BFReserveNonScaling method.
	BFReserveNonScalingFunc func(ctx context.Context, key string, errorRate float64, capacity int64) *redis.StatusCmd

	// BFReserveWithArgsFunc mocks the BFReserveWithArgs method.
	BFReserveWithArgsFunc func(ctx context.Context, key string, options *redis.BFReserveOptions) *redis.StatusCmd

	// BFScanDumpFunc mocks the BFScanDump method.
	BFScanDumpFunc func(ctx context.Context, key string, iterator int64) *redis.ScanDumpCmd

	// BLMPopFunc mocks the BLMPop method.
	BLMPopFunc func(ctx context.Context, timeout time.Duration, direction string, count int64, keys ...string) *redis.KeyValuesCmd

	// BLMoveFunc mocks the BLMove method.
	BLMoveFunc func(ctx context.Context, source string, destination string, srcpos string, destpos string, timeout time.Duration) *redis.StringCmd

	// BLPopFunc mocks the BLPop method.
	BLPopFunc func(ctx context.Context, timeout time.Duration, keys ...string) *redis.StringSliceCmd

	// BRPopFunc mocks the BRPop method.
	BRPopFunc func(ctx context.Context, timeout time.Duration, keys ...string) *redis.StringSliceCmd

	// BRPopLPushFunc mocks the BRPopLPush method.
	BRPopLPushFunc func(ctx context.Context, source string, destination string, timeout time.Duration) *redis.StringCmd

	// BZMPopFunc mocks the BZMPop method.
	BZMPopFunc func(ctx context.Context, timeout time.Duration, order string, count int64, keys ...string) *redis.ZSliceWithKeyCmd

	// BZPopMaxFunc mocks the BZPopMax method.
	BZPopMaxFunc func(ctx context.Context, timeout time.Duration, keys ...string) *redis.ZWithKeyCmd

	// BZPopMinFunc mocks the BZPopMin method.
	BZPopMinFunc func(ctx context.Context, timeout time.Duration, keys ...string) *redis.ZWithKeyCmd

	// BgRewriteAOFFunc mocks the BgRewriteAOF method.
	BgRewriteAOFFunc func(ctx context.Context) *redis.StatusCmd

	// BgSaveFunc mocks the BgSave method.
	BgSaveFunc func(ctx context.Context) *redis.StatusCmd

	// BitCountFunc mocks the BitCount method.
	BitCountFunc func(ctx context.Context, key string, bitCount *redis.BitCount) *redis.IntCmd

	// BitFieldFunc mocks the BitField method.
	BitFieldFunc func(ctx context.Context, key string, values ...interface{}) *redis.IntSliceCmd

	// BitFieldROFunc mocks the BitFieldRO method.
	BitFieldROFunc func(ctx context.Context, key string, values ...interface{}) *redis.IntSliceCmd

	// BitOpAndFunc mocks the BitOpAnd method.
	BitOpAndFunc func(ctx context.Context, destKey string, keys ...string) *redis.IntCmd

	// BitOpAndOrFunc mocks the BitOpAndOr method.
	BitOpAndOrFunc func(ctx context.Context, destKey string, keys ...string) *redis.IntCmd

	// BitOpDiffFunc mocks the BitOpDiff method.
	BitOpDiffFunc func(ctx context.Context, destKey string, keys ...string) *redis.IntCmd

	// BitOpDiff1Func mocks the BitOpDiff1 method.
	BitOpDiff1Func func(ctx context.Context, destKey string, keys ...string) *redis.IntCmd

	// BitOpNotFunc mocks the BitOpNot method.
	BitOpNotFunc func(ctx context.Context, destKey string, key string) *redis.IntCmd

	// BitOpOneFunc mocks the BitOpOne method.
	BitOpOneFunc func(ctx context.Context, destKey string, keys ...string) *redis.IntCmd

	// BitOpOrFunc mocks the BitOpOr method.
	BitOpOrFunc func(ctx context.Context, destKey string, keys ...string) *redis.IntCmd

	// BitOpXorFunc mocks the BitOpXor method.
	BitOpXorFunc func(ctx context.Context, destKey string, keys ...string) *redis.IntCmd

	// BitPosFunc mocks the BitPos method.
	BitPosFunc func(ctx context.Context, key string, bit int64, pos ...int64) *redis.IntCmd

	// BitPosSpanFunc mocks the BitPosSpan method.
	BitPosSpanFunc func(ctx context.Context, key string, bit int8, start int64, end int64, span string) *redis.IntCmd

	// CFAddFunc mocks the CFAdd method.
	CFAddFunc func(ctx context.Context, key string, element interface{}) *redis.BoolCmd

	// CFAddNXFunc mocks the CFAddNX method.
	CFAddNXFunc func(ctx context.Context, key string, element interface{}) *redis.BoolCmd

	// CFCountFunc mocks the CFCount method.
	CFCountFunc func(ctx context.Context, key string, element interface{}) *redis.IntCmd

	// CFDelFunc mocks the CFDel method.
	CFDelFunc func(ctx context.Context, key string, element interface{}) *redis.BoolCmd

	// CFExistsFunc mocks the CFExists method.
	CFExistsFunc func(ctx context.Context, key string, element interface{}) *redis.BoolCmd

	// CFInfoFunc mocks the CFInfo method.
	CFInfoFunc func(ctx context.Context, key string) *redis.CFInfoCmd

	// CFInsertFunc mocks the CFInsert method.
	CFInsertFunc func(ctx context.Context, key string, options *redis.CFInsertOptions, elements ...interface{}) *redis.BoolSliceCmd

	// CFInsertNXFunc mocks the CFInsertNX method.
	CFInsertNXFunc func(ctx context.Context, key string, options *redis.CFInsertOptions, elements ...interface{}) *redis.IntSliceCmd

	// CFLoadChunkFunc mocks the CFLoadChunk method.
	CFLoadChunkFunc func(ctx context.Context, key string, iterator int64, data interface{}) *redis.StatusCmd

	// CFMExistsFunc mocks the CFMExists method.
	CFMExistsFunc func(ctx context.Context, key string, elements ...interface{}) *redis.BoolSliceCmd

	// CFReserveFunc mocks the CFReserve method.
	CFReserveFunc func(ctx context.Context, key string, capacity int64) *redis.StatusCmd

	// CFReserveBucketSizeFunc mocks the CFReserveBucketSize method.
	CFReserveBucketSizeFunc func(ctx context.Context, key string, capacity int64, bucketsize int64) *redis.StatusCmd

	// CFReserveExpansionFunc mocks the CFReserveExpansion method.
	CFReserveExpansionFunc func(ctx context.Context, key string, capacity int64, expansion int64) *redis.StatusCmd

	// CFReserveMaxIterationsFunc mocks the CFReserveMaxIterations method.
	CFReserveMaxIterationsFunc func(ctx context.Context, key string, capacity int64, maxiterations int64) *redis.StatusCmd

	// CFReserveWithArgsFunc mocks the CFReserveWithArgs method.
	CFReserveWithArgsFunc func(ctx context.Context, key string, options *redis.CFReserveOptions) *redis.StatusCmd

	// CFScanDumpFunc mocks the CFScanDump method.
	CFScanDumpFunc func(ctx context.Context, key string, iterator int64) *redis.ScanDumpCmd

	// CMSIncrByFunc mocks the CMSIncrBy method.
	CMSIncrByFunc func(ctx context.Context, key string, elements ...interface{}) *redis.IntSliceCmd

	// CMSInfoFunc mocks the CMSInfo method.
	CMSInfoFunc func(ctx context.Context, key string) *redis.CMSInfoCmd

	// CMSInitByDimFunc mocks the CMSInitByDim method.
	CMSInitByDimFunc func(ctx context.Context, key string, width int64, height int64) *redis.StatusCmd

	// CMSInitByProbFunc mocks the CMSInitByProb method.
	CMSInitByProbFunc func(ctx context.Context, key string, errorRate float64, probability float64) *redis.StatusCmd

	// CMSMergeFunc mocks the CMSMerge method.
	CMSMergeFunc func(ctx context.Context, destKey string, sourceKeys ...string) *redis.StatusCmd

	// CMSMergeWithWeightFunc mocks the CMSMergeWithWeight method.
	CMSMergeWithWeightFunc func(ctx context.Context, destKey string, sourceKeys map[string]int64) *redis.StatusCmd

	// CMSQueryFunc mocks the CMSQuery method.
	CMSQueryFunc func(ctx context.Context, key string, elements ...interface{}) *redis.IntSliceCmd

	// ClientGetNameFunc mocks the ClientGetName method.
	ClientGetNameFunc func(ctx context.Context) *redis.StringCmd

	// ClientIDFunc mocks the ClientID method.
	ClientIDFunc func(ctx context.Context) *redis.IntCmd

	// ClientInfoFunc mocks the ClientInfo method.
	ClientInfoFunc func(ctx context.Context) *redis.ClientInfoCmd

	// ClientKillFunc mocks the ClientKill method.
	ClientKillFunc func(ctx context.Context, ipPort string) *redis.StatusCmd

	// ClientKillByFilterFunc mocks the ClientKillByFilter method.
	ClientKillByFilterFunc func(ctx context.Context, keys ...string) *redis.IntCmd

	// ClientListFunc mocks the ClientList method.
	ClientListFunc func(ctx context.Context) *redis.StringCmd

	// ClientMaintNotificationsFunc mocks the ClientMaintNotifications method.
	ClientMaintNotificationsFunc func(ctx context.Context, enabled bool, endpointType string) *redis.StatusCmd

	// ClientPauseFunc mocks the ClientPause method.
	ClientPauseFunc func(ctx context.Context, dur time.Duration) *redis.BoolCmd

	// ClientUnblockFunc mocks the ClientUnblock method.
	ClientUnblockFunc func(ctx context.Context, id int64) *redis.IntCmd

	// ClientUnblockWithErrorFunc mocks the ClientUnblockWithError method.
	ClientUnblockWithErrorFunc func(ctx context.Context, id int64) *redis.IntCmd

	// ClientUnpauseFunc mocks the ClientUnpause method.
	ClientUnpauseFunc func(ctx context.Context) *redis.BoolCmd

	// ClusterAddSlotsFunc mocks the ClusterAddSlots method.
	ClusterAddSlotsFunc func(ctx context.Context, slots ...int) *redis.StatusCmd

	// ClusterAddSlotsRangeFunc mocks the ClusterAddSlotsRange method.
	ClusterAddSlotsRangeFunc func(ctx context.Context, min int, max int) *redis.StatusCmd

	// ClusterCountFailureReportsFunc mocks the ClusterCountFailureReports method.
	ClusterCountFailureReportsFunc func(ctx context.Context, nodeID string) *redis.IntCmd

	// ClusterCountKeysInSlotFunc mocks the ClusterCountKeysInSlot method.
	ClusterCountKeysInSlotFunc func(ctx context.Context, slot int) *redis.IntCmd

	// ClusterDelSlotsFunc mocks the ClusterDelSlots method.
	ClusterDelSlotsFunc func(ctx context.Context, slots ...int) *redis.StatusCmd

	// ClusterDelSlotsRangeFunc mocks the ClusterDelSlotsRange method.
	ClusterDelSlotsRangeFunc func(ctx context.Context, min int, max int) *redis.StatusCmd

	// ClusterFailoverFunc mocks the ClusterFailover method.
	ClusterFailoverFunc func(ctx context.Context) *redis.StatusCmd

	// ClusterForgetFunc mocks the ClusterForget method.
	ClusterForgetFunc func(ctx context.Context, nodeID string) *redis.StatusCmd

	// ClusterGetKeysInSlotFunc mocks the ClusterGetKeysInSlot method.
	ClusterGetKeysInSlotFunc func(ctx context.Context, slot int, count int) *redis.StringSliceCmd

	// ClusterInfoFunc mocks the ClusterInfo method.
	ClusterInfoFunc func(ctx context.Context) *redis.StringCmd

	// ClusterKeySlotFunc mocks the ClusterKeySlot method.
	ClusterKeySlotFunc func(ctx context.Context, key string) *redis.IntCmd

	// ClusterLinksFunc mocks the ClusterLinks method.
	ClusterLinksFunc func(ctx context.Context) *redis.ClusterLinksCmd

	// ClusterMeetFunc mocks the ClusterMeet method.
	ClusterMeetFunc func(ctx context.Context, host string, port string) *redis.StatusCmd

	// ClusterMyIDFunc mocks the ClusterMyID method.
	ClusterMyIDFunc func(ctx context.Context) *redis.StringCmd

	// ClusterMyShardIDFunc mocks the ClusterMyShardID method.
	ClusterMyShardIDFunc func(ctx context.Context) *redis.StringCmd

	// ClusterNodesFunc mocks the ClusterNodes method.
	ClusterNodesFunc func(ctx context.Context) *redis.StringCmd

	// ClusterReplicateFunc mocks the ClusterReplicate method.
	ClusterReplicateFunc func(ctx context.Context, nodeID string) *redis.StatusCmd

	// ClusterResetHardFunc mocks the ClusterResetHard method.
	ClusterResetHardFunc func(ctx context.Context) *redis.StatusCmd

	// ClusterResetSoftFunc mocks the ClusterResetSoft method.
	ClusterResetSoftFunc func(ctx context.Context) *redis.StatusCmd

	// ClusterSaveConfigFunc mocks the ClusterSaveConfig method.
	ClusterSaveConfigFunc func(ctx context.Context) *redis.StatusCmd

	// ClusterShardsFunc mocks the ClusterShards method.
	ClusterShardsFunc func(ctx context.Context) *redis.ClusterShardsCmd

	// ClusterSlavesFunc mocks the ClusterSlaves method.
	ClusterSlavesFunc func(ctx context.Context, nodeID string) *redis.StringSliceCmd

	// ClusterSlotsFunc mocks the ClusterSlots method.
	ClusterSlotsFunc func(ctx context.Context) *redis.ClusterSlotsCmd

	// CommandFunc mocks the Command method.
	CommandFunc func(ctx context.Context) *redis.CommandsInfoCmd

	// CommandGetKeysFunc mocks the CommandGetKeys method.
	CommandGetKeysFunc func(ctx context.Context, commands ...interface{}) *redis.StringSliceCmd

	// CommandGetKeysAndFlagsFunc mocks the CommandGetKeysAndFlags method.
	CommandGetKeysAndFlagsFunc func(ctx context.Context, commands ...interface{}) *redis.KeyFlagsCmd

	// CommandListFunc mocks the CommandList method.
	CommandListFunc func(ctx context.Context, filter *redis.FilterBy) *redis.StringSliceCmd

	// ConfigGetFunc mocks the ConfigGet method.
	ConfigGetFunc func(ctx context.Context, parameter string) *redis.MapStringStringCmd

	// ConfigResetStatFunc mocks the ConfigResetStat method.
	ConfigResetStatFunc func(ctx context.Context) *redis.StatusCmd

	// ConfigRewriteFunc mocks the ConfigRewrite method.
	ConfigRewriteFunc func(ctx context.Context) *redis.StatusCmd

	// ConfigSetFunc mocks the ConfigSet method.
	ConfigSetFunc func(ctx context.Context, parameter string, value string) *redis.StatusCmd

	// CopyFunc mocks the Copy method.
	CopyFunc func(ctx context.Context, sourceKey string, destKey string, db int, replace bool) *redis.IntCmd

	// DBSizeFunc mocks the DBSize method.
	DBSizeFunc func(ctx context.Context) *redis.IntCmd

	// DebugObjectFunc mocks the DebugObject method.
	DebugObjectFunc func(ctx context.Context, key string) *redis.StringCmd

	// DecrFunc mocks the Decr method.
	DecrFunc func(ctx context.Context, key string) *redis.IntCmd

	// DecrByFunc mocks the DecrBy method.
	DecrByFunc func(ctx context.Context, key string, decrement int64) *redis.IntCmd

	// DelFunc mocks the Del method.
	DelFunc func(ctx context.Context, keys ...string) *redis.IntCmd

	// DelExArgsFunc mocks the DelExArgs method.
	DelExArgsFunc func(ctx context.Context, key string, a redis.DelExArgs) *redis.IntCmd

	// DigestFunc mocks the Digest method.
	DigestFunc func(ctx context.Context, key string) *redis.DigestCmd

	// DumpFunc mocks the Dump method.
	DumpFunc func(ctx context.Context, key string) *redis.StringCmd

	// EchoFunc mocks the Echo method.
	EchoFunc func(ctx context.Context, message interface{}) *redis.StringCmd

	// EvalFunc mocks the Eval method.
	EvalFunc func(ctx context.Context, script string, keys []string, args ...interface{}) *redis.Cmd

	// EvalROFunc mocks the EvalRO method.
	EvalROFunc func(ctx context.Context, script string, keys []string, args ...interface{}) *redis.Cmd

	// EvalShaFunc mocks the EvalSha method.
	EvalShaFunc func(ctx context.Context, sha1 string, keys []string, args ...interface{}) *redis.Cmd

	// EvalShaROFunc mocks the EvalShaRO method.
	EvalShaROFunc func(ctx context.Context, sha1 string, keys []string, args ...interface{}) *redis.Cmd

	// ExistsFunc mocks the Exists method.
	ExistsFunc func(ctx context.Context, keys ...string) *redis.IntCmd

	// ExpireFunc mocks the Expire method.
	ExpireFunc func(ctx context.Context, key string, expiration time.Duration) *redis.BoolCmd

	// ExpireAtFunc mocks the ExpireAt method.
	ExpireAtFunc func(ctx context.Context, key string, tm time.Time) *redis.BoolCmd

	// ExpireGTFunc mocks the ExpireGT method.
	ExpireGTFunc func(ctx context.Context, key string, expiration time.Duration) *redis.BoolCmd

	// ExpireLTFunc mocks the ExpireLT method.
	ExpireLTFunc func(ctx context.Context, key string, expiration time.Duration) *redis.BoolCmd

	// ExpireNXFunc mocks the ExpireNX method.
	ExpireNXFunc func(ctx context.Context, key string, expiration time.Duration) *redis.BoolCmd

	// ExpireTimeFunc mocks the ExpireTime method.
	ExpireTimeFunc func(ctx context.Context, key string) *redis.DurationCmd

	// ExpireXXFunc mocks the ExpireXX method.
	ExpireXXFunc func(ctx context.Context, key string, expiration time.Duration) *redis.BoolCmd

	// FCallFunc mocks the FCall method.
	FCallFunc func(ctx context.Context, function string, keys []string, args ...interface{}) *redis.Cmd

	// FCallROFunc mocks the FCallRO method.
	FCallROFunc func(ctx context.Context, function string, keys []string, args ...interface{}) *redis.Cmd

	// FCallRoFunc mocks the FCallRo method.
	FCallRoFunc func(ctx context.Context, function string, keys []string, args ...interface{}) *redis.Cmd

	// FTAggregateFunc mocks the FTAggregate method.
	FTAggregateFunc func(ctx context.Context, index string, query string) *redis.MapStringInterfaceCmd

	// FTAggregateWithArgsFunc mocks the FTAggregateWithArgs method.
	FTAggregateWithArgsFunc func(ctx context.Context, index string, query string, options *redis.FTAggregateOptions) *redis.AggregateCmd

	// FTAliasAddFunc mocks the FTAliasAdd method.
	FTAliasAddFunc func(ctx context.Context, index string, alias string) *redis.StatusCmd

	// FTAliasDelFunc mocks the FTAliasDel method.
	FTAliasDelFunc func(ctx context.Context, alias string) *redis.StatusCmd

	// FTAliasUpdateFunc mocks the FTAliasUpdate method.
	FTAliasUpdateFunc func(ctx context.Context, index string, alias string) *redis.StatusCmd

	// FTAlterFunc mocks the FTAlter method.
	FTAlterFunc func(ctx context.Context, index string, skipInitialScan bool, definition []interface{}) *redis.StatusCmd

	// FTConfigGetFunc mocks the FTConfigGet method.
	FTConfigGetFunc func(ctx context.Context, option string) *redis.MapMapStringInterfaceCmd

	// FTConfigSetFunc mocks the FTConfigSet method.
	FTConfigSetFunc func(ctx context.Context, option string, value interface{}) *redis.StatusCmd

	// FTCreateFunc mocks the FTCreate method.
	FTCreateFunc func(ctx context.Context, index string, options *redis.FTCreateOptions, schema ...*redis.FieldSchema) *redis.StatusCmd

	// FTCursorDelFunc mocks the FTCursorDel method.
	FTCursorDelFunc func(ctx context.Context, index string, cursorId int) *redis.StatusCmd

	// FTCursorReadFunc mocks the FTCursorRead method.
	FTCursorReadFunc func(ctx context.Context, index string, cursorId int, count int) *redis.MapStringInterfaceCmd

	// FTDictAddFunc mocks the FTDictAdd method.
	FTDictAddFunc func(ctx context.Context, dict string, term ...interface{}) *redis.IntCmd

	// FTDictDelFunc mocks the FTDictDel method.
	FTDictDelFunc func(ctx context.Context, dict string, term ...interface{}) *redis.IntCmd

	// FTDictDumpFunc mocks the FTDictDump method.
	FTDictDumpFunc func(ctx context.Context, dict string) *redis.StringSliceCmd

	// FTDropIndexFunc mocks the FTDropIndex method.
	FTDropIndexFunc func(ctx context.Context, index string) *redis.StatusCmd

	// FTDropIndexWithArgsFunc mocks the FTDropIndexWithArgs method.
	FTDropIndexWithArgsFunc func(ctx context.Context, index string, options *redis.FTDropIndexOptions) *redis.StatusCmd

	// FTExplainFunc mocks the FTExplain method.
	FTExplainFunc func(ctx context.Context, index string, query string) *redis.StringCmd

	// FTExplainWithArgsFunc mocks the FTExplainWithArgs method.
	FTExplainWithArgsFunc func(ctx context.Context, index string, query string, options *redis.FTExplainOptions) *redis.StringCmd

	// FTHybridFunc mocks the FTHybrid method.
	FTHybridFunc func(ctx context.Context, index string, searchExpr string, vectorField string, vectorData redis.Vector) *redis.FTHybridCmd

	// FTHybridWithArgsFunc mocks the FTHybridWithArgs method.
	FTHybridWithArgsFunc func(ctx context.Context, index string, options *redis.FTHybridOptions) *redis.FTHybridCmd

	// FTInfoFunc mocks the FTInfo method.
	FTInfoFunc func(ctx context.Context, index string) *redis.FTInfoCmd

	// FTSearchFunc mocks the FTSearch method.
	FTSearchFunc func(ctx context.Context, index string, query string) *redis.FTSearchCmd

	// FTSearchWithArgsFunc mocks the FTSearchWithArgs method.
	FTSearchWithArgsFunc func(ctx context.Context, index string, query string, options *redis.FTSearchOptions) *redis.FTSearchCmd

	// FTSpellCheckFunc mocks the FTSpellCheck method.
	FTSpellCheckFunc func(ctx context.Context, index string, query string) *redis.FTSpellCheckCmd

	// FTSpellCheckWithArgsFunc mocks the FTSpellCheckWithArgs method.
	FTSpellCheckWithArgsFunc func(ctx context.Context, index string, query string, options *redis.FTSpellCheckOptions) *redis.FTSpellCheckCmd

	// FTSynDumpFunc mocks the FTSynDump method.
	FTSynDumpFunc func(ctx context.Context, index string) *redis.FTSynDumpCmd

	// FTSynUpdateFunc mocks the FTSynUpdate method.
	FTSynUpdateFunc func(ctx context.Context, index string, synGroupId interface{}, terms []interface{}) *redis.StatusCmd

	// FTSynUpdateWithArgsFunc mocks the FTSynUpdateWithArgs method.
	FTSynUpdateWithArgsFunc func(ctx context.Context, index string, synGroupId interface{}, options *redis.FTSynUpdateOptions, terms []interface{}) *redis.StatusCmd

	// FTTagValsFunc mocks the FTTagVals method.
	FTTagValsFunc func(ctx context.Context, index string, field string) *redis.StringSliceCmd

	// FT_ListFunc mocks the FT_List method.
	FT_ListFunc func(ctx context.Context) *redis.StringSliceCmd

	// FlushAllFunc mocks the FlushAll method.
	FlushAllFunc func(ctx context.Context) *redis.StatusCmd

	// FlushAllAsyncFunc mocks the FlushAllAsync method.
	FlushAllAsyncFunc func(ctx context.Context) *redis.StatusCmd

	// FlushDBFunc mocks the FlushDB method.
	FlushDBFunc func(ctx context.Context) *redis.StatusCmd

	// FlushDBAsyncFunc mocks the FlushDBAsync method.
	FlushDBAsyncFunc func(ctx context.Context) *redis.StatusCmd

	// FunctionDeleteFunc mocks the FunctionDelete method.
	FunctionDeleteFunc func(ctx context.Context, libName string) *redis.StringCmd

	// FunctionDumpFunc mocks the FunctionDump method.
	FunctionDumpFunc func(ctx context.Context) *redis.StringCmd

	// FunctionFlushFunc mocks the FunctionFlush method.
	FunctionFlushFunc func(ctx context.Context) *redis.StringCmd

	// FunctionFlushAsyncFunc mocks the FunctionFlushAsync method.
	FunctionFlushAsyncFunc func(ctx context.Context) *redis.StringCmd

	// FunctionKillFunc mocks the FunctionKill method.
	FunctionKillFunc func(ctx context.Context) *redis.StringCmd

	// FunctionListFunc mocks the FunctionList method.
	FunctionListFunc func(ctx context.Context, q redis.FunctionListQuery) *redis.FunctionListCmd

	// FunctionLoadFunc mocks the FunctionLoad method.
	FunctionLoadFunc func(ctx context.Context, code string) *redis.StringCmd

	// FunctionLoadReplaceFunc mocks the FunctionLoadReplace method.
	FunctionLoadReplaceFunc func(ctx context.Context, code string) *redis.StringCmd

	// FunctionRestoreFunc mocks the FunctionRestore method.
	FunctionRestoreFunc func(ctx context.Context, libDump string) *redis.StringCmd

	// FunctionStatsFunc mocks the FunctionStats method.
	FunctionStatsFunc func(ctx context.Context) *redis.FunctionStatsCmd

	// GeoAddFunc mocks the GeoAdd method.
	GeoAddFunc func(ctx context.Context, key string, geoLocation ...*redis.GeoLocation) *redis.IntCmd

	// GeoDistFunc mocks the GeoDist method.
	GeoDistFunc func(ctx context.Context, key string, member1 string, member2 string, unit string) *redis.FloatCmd

	// GeoHashFunc mocks the GeoHash method.
	GeoHashFunc func(ctx context.Context, key string, members ...string) *redis.StringSliceCmd

	// GeoPosFunc mocks the GeoPos method.
	GeoPosFunc func(ctx context.Context, key string, members ...string) *redis.GeoPosCmd

	// GeoRadiusFunc mocks the GeoRadius method.
	GeoRadiusFunc func(ctx context.Context, key string, longitude float64, latitude float64, query *redis.GeoRadiusQuery) *redis.GeoLocationCmd

	// GeoRadiusByMemberFunc mocks the GeoRadiusByMember method.
	GeoRadiusByMemberFunc func(ctx context.Context, key string, member string, query *redis.GeoRadiusQuery) *redis.GeoLocationCmd

	// GeoRadiusByMemberStoreFunc mocks the GeoRadiusByMemberStore method.
	GeoRadiusByMemberStoreFunc func(ctx context.Context, key string, member string, query *redis.GeoRadiusQuery) *redis.IntCmd

	// GeoRadiusStoreFunc mocks the GeoRadiusStore method.
	GeoRadiusStoreFunc func(ctx context.Context, key string, longitude float64, latitude float64, query *redis.GeoRadiusQuery) *redis.IntCmd

	// GeoSearchFunc mocks the GeoSearch method.
	GeoSearchFunc func(ctx context.Context, key string, q *redis.GeoSearchQuery) *redis.StringSliceCmd

	// GeoSearchLocationFunc mocks the GeoSearchLocation method.
	GeoSearchLocationFunc func(ctx context.Context, key string, q *redis.GeoSearchLocationQuery) *redis.GeoSearchLocationCmd

	// GeoSearchStoreFunc mocks the GeoSearchStore method.
	GeoSearchStoreFunc func(ctx context.Context, key string, store string, q *redis.GeoSearchStoreQuery) *redis.IntCmd

	// GetFunc mocks the Get method.
	GetFunc func(ctx context.Context, key string) *redis.StringCmd

	// GetBitFunc mocks the GetBit method.
	GetBitFunc func(ctx context.Context, key string, offset int64) *redis.IntCmd

	// GetDelFunc mocks the GetDel method.
	GetDelFunc func(ctx context.Context, key string) *redis.StringCmd

	// GetExFunc mocks the GetEx method.
	GetExFunc func(ctx context.Context, key string, expiration time.Duration) *redis.StringCmd

	// GetRangeFunc mocks the GetRange method.
	GetRangeFunc func(ctx context.Context, key string, start int64, end int64) *redis.StringCmd

	// GetSetFunc mocks the GetSet method.
	GetSetFunc func(ctx context.Context, key string, value interface{}) *redis.StringCmd

	// HDelFunc mocks the HDel method.
	HDelFunc func(ctx context.Context, key string, fields ...string) *redis.IntCmd

	// HExistsFunc mocks the HExists method.
	HExistsFunc func(ctx context.Context, key string, field string) *redis.BoolCmd

	// HExpireFunc mocks the HExpire method.
	HExpireFunc func(ctx context.Context, key string, expiration time.Duration, fields ...string) *redis.IntSliceCmd

	// HExpireAtFunc mocks the HExpireAt method.
	HExpireAtFunc func(ctx context.Context, key string, tm time.Time, fields ...string) *redis.IntSliceCmd

	// HExpireAtWithArgsFunc mocks the HExpireAtWithArgs method.
	HExpireAtWithArgsFunc func(ctx context.Context, key string, tm time.Time, expirationArgs redis.HExpireArgs, fields ...string) *redis.IntSliceCmd

	// HExpireTimeFunc mocks the HExpireTime method.
	HExpireTimeFunc func(ctx context.Context, key string, fields ...string) *redis.IntSliceCmd

	// HExpireWithArgsFunc mocks the HExpireWithArgs method.
	HExpireWithArgsFunc func(ctx context.Context, key string, expiration time.Duration, expirationArgs redis.HExpireArgs, fields ...string) *redis.IntSliceCmd

	// HGetFunc mocks the HGet method.
	HGetFunc func(ctx context.Context, key string, field string) *redis.StringCmd

	// HGetAllFunc mocks the HGetAll method.
	HGetAllFunc func(ctx context.Context, key string) *redis.MapStringStringCmd

	// HGetDelFunc mocks the HGetDel method.
	HGetDelFunc func(ctx context.Context, key string, fields ...string) *redis.StringSliceCmd

	// HGetEXFunc mocks the HGetEX method.
	HGetEXFunc func(ctx context.Context, key string, fields ...string) *redis.StringSliceCmd

	// HGetEXWithArgsFunc mocks the HGetEXWithArgs method.
	HGetEXWithArgsFunc func(ctx context.Context, key string, options *redis.HGetEXOptions, fields ...string) *redis.StringSliceCmd

	// HIncrByFunc mocks the HIncrBy method.
	HIncrByFunc func(ctx context.Context, key string, field string, incr int64) *redis.IntCmd

	// HIncrByFloatFunc mocks the HIncrByFloat method.
	HIncrByFloatFunc func(ctx context.Context, key string, field string, incr float64) *redis.FloatCmd

	// HKeysFunc mocks the HKeys method.
	HKeysFunc func(ctx context.Context, key string) *redis.StringSliceCmd

	// HLenFunc mocks the HLen method.
	HLenFunc func(ctx context.Context, key string) *redis.IntCmd

	// HMGetFunc mocks the HMGet method.
	HMGetFunc func(ctx context.Context, key string, fields ...string) *redis.SliceCmd

	// HMSetFunc mocks the HMSet method.
	HMSetFunc func(ctx context.Context, key string, values ...interface{}) *redis.BoolCmd

	// HPExpireFunc mocks the HPExpire method.
	HPExpireFunc func(ctx context.Context, key string, expiration time.Duration, fields ...string) *redis.IntSliceCmd

	// HPExpireAtFunc mocks the HPExpireAt method.
	HPExpireAtFunc func(ctx context.Context, key string, tm time.Time, fields ...string) *redis.IntSliceCmd

	// HPExpireAtWithArgsFunc mocks the HPExpireAtWithArgs method.
	HPExpireAtWithArgsFunc func(ctx context.Context, key string, tm time.Time, expirationArgs redis.HExpireArgs, fields ...string) *redis.IntSliceCmd

	// HPExpireTimeFunc mocks the HPExpireTime method.
	HPExpireTimeFunc func(ctx context.Context, key string, fields ...string) *redis.IntSliceCmd

	// HPExpireWithArgsFunc mocks the HPExpireWithArgs method.
	HPExpireWithArgsFunc func(ctx context.Context, key string, expiration time.Duration, expirationArgs redis.HExpireArgs, fields ...string) *redis.IntSliceCmd

	// HPTTLFunc mocks the HPTTL method.
	HPTTLFunc func(ctx context.Context, key string, fields ...string) *redis.IntSliceCmd

	// HPersistFunc mocks the HPersist method.
	HPersistFunc func(ctx context.Context, key string, fields ...string) *redis.IntSliceCmd

	// HRandFieldFunc mocks the HRandField method.
	HRandFieldFunc func(ctx context.Context, key string, count int) *redis.StringSliceCmd

	// HRandFieldWithValuesFunc mocks the HRandFieldWithValues method.
	HRandFieldWithValuesFunc func(ctx context.Context, key string, count int) *redis.KeyValueSliceCmd

	// HScanFunc mocks the HScan method.
	HScanFunc func(ctx context.Context, key string, cursor uint64, match string, count int64) *redis.ScanCmd

	// HScanNoValuesFunc mocks the HScanNoValues method.
	HScanNoValuesFunc func(ctx context.Context, key string, cursor uint64, match string, count int64) *redis.ScanCmd

	// HSetFunc mocks the HSet method.
	HSetFunc func(ctx context.Context, key string, values ...interface{}) *redis.IntCmd

	// HSetEXFunc mocks the HSetEX method.
	HSetEXFunc func(ctx context.Context, key string, fieldsAndValues ...string) *redis.IntCmd

	// HSetEXWithArgsFunc mocks the HSetEXWithArgs method.
	HSetEXWithArgsFunc func(ctx context.Context, key string, options *redis.HSetEXOptions, fieldsAndValues ...string) *redis.IntCmd

	// HSetNXFunc mocks the HSetNX method.
	HSetNXFunc func(ctx context.Context, key string, field string, value interface{}) *redis.BoolCmd

	// HStrLenFunc mocks the HStrLen method.
	HStrLenFunc func(ctx context.Context, key string, field string) *redis.IntCmd

	// HTTLFunc mocks the HTTL method.
	HTTLFunc func(ctx context.Context, key string, fields ...string) *redis.IntSliceCmd

	// HValsFunc mocks the HVals method.
	HValsFunc func(ctx context.Context, key string) *redis.StringSliceCmd

	// IncrFunc mocks the Incr method.
	IncrFunc func(ctx context.Context, key string) *redis.IntCmd

	// IncrByFunc mocks the IncrBy method.
	IncrByFunc func(ctx context.Context, key string, value int64) *redis.IntCmd

	// IncrByFloatFunc mocks the IncrByFloat method.
	IncrByFloatFunc func(ctx context.Context, key string, value float64) *redis.FloatCmd

	// InfoFunc mocks the Info method.
	InfoFunc func(ctx context.Context, section ...string) *redis.StringCmd

	// JSONArrAppendFunc mocks the JSONArrAppend method.
	JSONArrAppendFunc func(ctx context.Context, key string, path string, values ...interface{}) *redis.IntSliceCmd

	// JSONArrIndexFunc mocks the JSONArrIndex method.
	JSONArrIndexFunc func(ctx context.Context, key string, path string, value ...interface{}) *redis.IntSliceCmd

	// JSONArrIndexWithArgsFunc mocks the JSONArrIndexWithArgs method.
	JSONArrIndexWithArgsFunc func(ctx context.Context, key string, path string, options *redis.JSONArrIndexArgs, value ...interface{}) *redis.IntSliceCmd

	// JSONArrInsertFunc mocks the JSONArrInsert method.
	JSONArrInsertFunc func(ctx context.Context, key string, path string, index int64, values ...interface{}) *redis.IntSliceCmd

	// JSONArrLenFunc mocks the JSONArrLen method.
	JSONArrLenFunc func(ctx context.Context, key string, path string) *redis.IntSliceCmd

	// JSONArrPopFunc mocks the JSONArrPop method.
	JSONArrPopFunc func(ctx context.Context, key string, path string, index int) *redis.StringSliceCmd

	// JSONArrTrimFunc mocks the JSONArrTrim method.
	JSONArrTrimFunc func(ctx context.Context, key string, path string) *redis.IntSliceCmd

	// JSONArrTrimWithArgsFunc mocks the JSONArrTrimWithArgs method.
	JSONArrTrimWithArgsFunc func(ctx context.Context, key string, path string, options *redis.JSONArrTrimArgs) *redis.IntSliceCmd

	// JSONClearFunc mocks the JSONClear method.
	JSONClearFunc func(ctx context.Context, key string, path string) *redis.IntCmd

	// JSONDebugMemoryFunc mocks the JSONDebugMemory method.
	JSONDebugMemoryFunc func(ctx context.Context, key string, path string) *redis.IntCmd

	// JSONDelFunc mocks the JSONDel method.
	JSONDelFunc func(ctx context.Context, key string, path string) *redis.IntCmd

	// JSONForgetFunc mocks the JSONForget method.
	JSONForgetFunc func(ctx context.Context, key string, path string) *redis.IntCmd

	// JSONGetFunc mocks the JSONGet method.
	JSONGetFunc func(ctx context.Context, key string, paths ...string) *redis.JSONCmd

	// JSONGetWithArgsFunc mocks the JSONGetWithArgs method.
	JSONGetWithArgsFunc func(ctx context.Context, key string, options *redis.JSONGetArgs, paths ...string) *redis.JSONCmd

	// JSONMGetFunc mocks the JSONMGet method.
	JSONMGetFunc func(ctx context.Context, path string, keys ...string) *redis.JSONSliceCmd

	// JSONMSetFunc mocks the JSONMSet method.
	JSONMSetFunc func(ctx context.Context, params ...interface{}) *redis.StatusCmd

	// JSONMSetArgsFunc mocks the JSONMSetArgs method.
	JSONMSetArgsFunc func(ctx context.Context, docs []redis.JSONSetArgs) *redis.StatusCmd

	// JSONMergeFunc mocks the JSONMerge method.
	JSONMergeFunc func(ctx context.Context, key string, path string, value string) *redis.StatusCmd

	// JSONNumIncrByFunc mocks the JSONNumIncrBy method.
	JSONNumIncrByFunc func(ctx context.Context, key string, path string, value float64) *redis.JSONCmd

	// JSONObjKeysFunc mocks the JSONObjKeys method.
	JSONObjKeysFunc func(ctx context.Context, key string, path string) *redis.SliceCmd

	// JSONObjLenFunc mocks the JSONObjLen method.
	JSONObjLenFunc func(ctx context.Context, key string, path string) *redis.IntPointerSliceCmd

	// JSONSetFunc mocks the JSONSet method.
	JSONSetFunc func(ctx context.Context, key string, path string, value interface{}) *redis.StatusCmd

	// JSONSetModeFunc mocks the JSONSetMode method.
	JSONSetModeFunc func(ctx context.Context, key string, path string, value interface{}, mode string) *redis.StatusCmd

	// JSONStrAppendFunc mocks the JSONStrAppend method.
	JSONStrAppendFunc func(ctx context.Context, key string, path string, value string) *redis.IntPointerSliceCmd

	// JSONStrLenFunc mocks the JSONStrLen method.
	JSONStrLenFunc func(ctx context.Context, key string, path string) *redis.IntPointerSliceCmd

	// JSONToggleFunc mocks the JSONToggle method.
	JSONToggleFunc func(ctx context.Context, key string, path string) *redis.IntPointerSliceCmd

	// JSONTypeFunc mocks the JSONType method.
	JSONTypeFunc func(ctx context.Context, key string, path string) *redis.JSONSliceCmd

	// KeysFunc mocks the Keys method.
	KeysFunc func(ctx context.Context, pattern string) *redis.StringSliceCmd

	// LCSFunc mocks the LCS method.
	LCSFunc func(ctx context.Context, q *redis.LCSQuery) *redis.LCSCmd

	// LIndexFunc mocks the LIndex method.
	LIndexFunc func(ctx context.Context, key string, index int64) *redis.StringCmd

	// LInsertFunc mocks the LInsert method.
	LInsertFunc func(ctx context.Context, key string, op string, pivot interface{}, value interface{}) *redis.IntCmd

	// LInsertAfterFunc mocks the LInsertAfter method.
	LInsertAfterFunc func(ctx context.Context, key string, pivot interface{}, value interface{}) *redis.IntCmd

	// LInsertBeforeFunc mocks the LInsertBefore method.
	LInsertBeforeFunc func(ctx context.Context, key string, pivot interface{}, value interface{}) *redis.IntCmd

	// LLenFunc mocks the LLen method.
	LLenFunc func(ctx context.Context, key string) *redis.IntCmd

	// LMPopFunc mocks the LMPop method.
	LMPopFunc func(ctx context.Context, direction string, count int64, keys ...string) *redis.KeyValuesCmd

	// LMoveFunc mocks the LMove method.
	LMoveFunc func(ctx context.Context, source string, destination string, srcpos string, destpos string) *redis.StringCmd

	// LPopFunc mocks the LPop method.
	LPopFunc func(ctx context.Context, key string) *redis.StringCmd

	// LPopCountFunc mocks the LPopCount method.
	LPopCountFunc func(ctx context.Context, key string, count int) *redis.StringSliceCmd

	// LPosFunc mocks the LPos method.
	LPosFunc func(ctx context.Context, key string, value string, args redis.LPosArgs) *redis.IntCmd

	// LPosCountFunc mocks the LPosCount method.
	LPosCountFunc func(ctx context.Context, key string, value string, count int64, args redis.LPosArgs) *redis.IntSliceCmd

	// LPushFunc mocks the LPush method.
	LPushFunc func(ctx context.Context, key string, values ...interface{}) *redis.IntCmd

	// LPushXFunc mocks the LPushX method.
	LPushXFunc func(ctx context.Context, key string, values ...interface{}) *redis.IntCmd

	// LRangeFunc mocks the LRange method.
	LRangeFunc func(ctx context.Context, key string, start int64, stop int64) *redis.StringSliceCmd

	// LRemFunc mocks the LRem method.
	LRemFunc func(ctx context.Context, key string, count int64, value interface{}) *redis.IntCmd

	// LSetFunc mocks the LSet method.
	LSetFunc func(ctx context.Context, key string, index int64, value interface{}) *redis.StatusCmd

	// LTrimFunc mocks the LTrim method.
	LTrimFunc func(ctx context.Context, key string, start int64, stop int64) *redis.StatusCmd

	// LastSaveFunc mocks the LastSave method.
	LastSaveFunc func(ctx context.Context) *redis.IntCmd

	// LatencyFunc mocks the Latency method.
	LatencyFunc func(ctx context.Context) *redis.LatencyCmd

	// LatencyResetFunc mocks the LatencyReset method.
	LatencyResetFunc func(ctx context.Context, events ...interface{}) *redis.StatusCmd

	// MGetFunc mocks the MGet method.
	MGetFunc func(ctx context.Context, keys ...string) *redis.SliceCmd

	// MSetFunc mocks the MSet method.
	MSetFunc func(ctx context.Context, values ...interface{}) *redis.StatusCmd

	// MSetEXFunc mocks the MSetEX method.
	MSetEXFunc func(ctx context.Context, args redis.MSetEXArgs, values ...interface{}) *redis.IntCmd

	// MSetNXFunc mocks the MSetNX method.
	MSetNXFunc func(ctx context.Context, values ...interface{}) *redis.BoolCmd

	// MemoryUsageFunc mocks the MemoryUsage method.
	MemoryUsageFunc func(ctx context.Context, key string, samples ...int) *redis.IntCmd

	// MigrateFunc mocks the Migrate method.
	MigrateFunc func(ctx context.Context, host string, port string, key string, db int, timeout time.Duration) *redis.StatusCmd

	// ModuleLoadexFunc mocks the ModuleLoadex method.
	ModuleLoadexFunc func(ctx context.Context, conf *redis.ModuleLoadexConfig) *redis.StringCmd

	// MoveFunc mocks the Move method.
	MoveFunc func(ctx context.Context, key string, db int) *redis.BoolCmd

	// ObjectEncodingFunc mocks the ObjectEncoding method.
	ObjectEncodingFunc func(ctx context.Context, key string) *redis.StringCmd

	// ObjectFreqFunc mocks the ObjectFreq method.
	ObjectFreqFunc func(ctx context.Context, key string) *redis.IntCmd

	// ObjectIdleTimeFunc mocks the ObjectIdleTime method.
	ObjectIdleTimeFunc func(ctx context.Context, key string) *redis.DurationCmd

	// ObjectRefCountFunc mocks the ObjectRefCount method.
	ObjectRefCountFunc func(ctx context.Context, key string) *redis.IntCmd

	// PExpireFunc mocks the PExpire method.
	PExpireFunc func(ctx context.Context, key string, expiration time.Duration) *redis.BoolCmd

	// PExpireAtFunc mocks the PExpireAt method.
	PExpireAtFunc func(ctx context.Context, key string, tm time.Time) *redis.BoolCmd

	// PExpireTimeFunc mocks the PExpireTime method.
	PExpireTimeFunc func(ctx context.Context, key string) *redis.DurationCmd

	// PFAddFunc mocks the PFAdd method.
	PFAddFunc func(ctx context.Context, key string, els ...interface{}) *redis.IntCmd

	// PFCountFunc mocks the PFCount method.
	PFCountFunc func(ctx context.Context, keys ...string) *redis.IntCmd

	// PFMergeFunc mocks the PFMerge method.
	PFMergeFunc func(ctx context.Context, dest string, keys ...string) *redis.StatusCmd

	// PTTLFunc mocks the PTTL method.
	PTTLFunc func(ctx context.Context, key string) *redis.DurationCmd

	// PersistFunc mocks the Persist method.
	PersistFunc func(ctx context.Context, key string) *redis.BoolCmd

	// PingFunc mocks the Ping method.
	PingFunc func(ctx context.Context) *redis.StatusCmd

	// PipelineFunc mocks the Pipeline method.
	PipelineFunc func() redis.Pipeliner

	// PipelinedFunc mocks the Pipelined method.
	PipelinedFunc func(ctx context.Context, fn func(redis.Pipeliner) error) ([]redis.Cmder, error)

	// PubSubChannelsFunc mocks the PubSubChannels method.
	PubSubChannelsFunc func(ctx context.Context, pattern string) *redis.StringSliceCmd

	// PubSubNumPatFunc mocks the PubSubNumPat method.
	PubSubNumPatFunc func(ctx context.Context) *redis.IntCmd

	// PubSubNumSubFunc mocks the PubSubNumSub method.
	PubSubNumSubFunc func(ctx context.Context, channels ...string) *redis.MapStringIntCmd

	// PubSubShardChannelsFunc mocks the PubSubShardChannels method.
	PubSubShardChannelsFunc func(ctx context.Context, pattern string) *redis.StringSliceCmd

	// PubSubShardNumSubFunc mocks the PubSubShardNumSub method.
	PubSubShardNumSubFunc func(ctx context.Context, channels ...string) *redis.MapStringIntCmd

	// PublishFunc mocks the Publish method.
	PublishFunc func(ctx context.Context, channel string, message interface{}) *redis.IntCmd

	// QuitFunc mocks the Quit method.
	QuitFunc func(ctx context.Context) *redis.StatusCmd

	// RPopFunc mocks the RPop method.
	RPopFunc func(ctx context.Context, key string) *redis.StringCmd

	// RPopCountFunc mocks the RPopCount method.
	RPopCountFunc func(ctx context.Context, key string, count int) *redis.StringSliceCmd

	// RPopLPushFunc mocks the RPopLPush method.
	RPopLPushFunc func(ctx context.Context, source string, destination string) *redis.StringCmd

	// RPushFunc mocks the RPush method.
	RPushFunc func(ctx context.Context, key string, values ...interface{}) *redis.IntCmd

	// RPushXFunc mocks the RPushX method.
	RPushXFunc func(ctx context.Context, key string, values ...interface{}) *redis.IntCmd

	// RandomKeyFunc mocks the RandomKey method.
	RandomKeyFunc func(ctx context.Context) *redis.StringCmd

	// ReadOnlyFunc mocks the ReadOnly method.
	ReadOnlyFunc func(ctx context.Context) *redis.StatusCmd

	// ReadWriteFunc mocks the ReadWrite method.
	ReadWriteFunc func(ctx context.Context) *redis.StatusCmd

	// RenameFunc mocks the Rename method.
	RenameFunc func(ctx context.Context, key string, newkey string) *redis.StatusCmd

	// RenameNXFunc mocks the RenameNX method.
	RenameNXFunc func(ctx context.Context, key string, newkey string) *redis.BoolCmd

	// RestoreFunc mocks the Restore method.
	RestoreFunc func(ctx context.Context, key string, ttl time.Duration, value string) *redis.StatusCmd

	// RestoreReplaceFunc mocks the RestoreReplace method.
	RestoreReplaceFunc func(ctx context.Context, key string, ttl time.Duration, value string) *redis.StatusCmd

	// SAddFunc mocks the SAdd method.
	SAddFunc func(ctx context.Context, key string, members ...interface{}) *redis.IntCmd

	// SCardFunc mocks the SCard method.
	SCardFunc func(ctx context.Context, key string) *redis.IntCmd

	// SDiffFunc mocks the SDiff method.
	SDiffFunc func(ctx context.Context, keys ...string) *redis.StringSliceCmd

	// SDiffStoreFunc mocks the SDiffStore method.
	SDiffStoreFunc func(ctx context.Context, destination string, keys ...string) *redis.IntCmd

	// SInterFunc mocks the SInter method.
	SInterFunc func(ctx context.Context, keys ...string) *redis.StringSliceCmd

	// SInterCardFunc mocks the SInterCard method.
	SInterCardFunc func(ctx context.Context, limit int64, keys ...string) *redis.IntCmd

	// SInterStoreFunc mocks the SInterStore method.
	SInterStoreFunc func(ctx context.Context, destination string, keys ...string) *redis.IntCmd

	// SIsMemberFunc mocks the SIsMember method.
	SIsMemberFunc func(ctx context.Context, key string, member interface{}) *redis.BoolCmd

	// SMIsMemberFunc mocks the SMIsMember method.
	SMIsMemberFunc func(ctx context.Context, key string, members ...interface{}) *redis.BoolSliceCmd

	// SMembersFunc mocks the SMembers method.
	SMembersFunc func(ctx context.Context, key string) *redis.StringSliceCmd

	// SMembersMapFunc mocks the SMembersMap method.
	SMembersMapFunc func(ctx context.Context, key string) *redis.StringStructMapCmd

	// SMoveFunc mocks the SMove method.
	SMoveFunc func(ctx context.Context, source string, destination string, member interface{}) *redis.BoolCmd

	// SPopFunc mocks the SPop method.
	SPopFunc func(ctx context.Context, key string) *redis.StringCmd

	// SPopNFunc mocks the SPopN method.
	SPopNFunc func(ctx context.Context, key string, count int64) *redis.StringSliceCmd

	// SPublishFunc mocks the SPublish method.
	SPublishFunc func(ctx context.Context, channel string, message interface{}) *redis.IntCmd

	// SRandMemberFunc mocks the SRandMember method.
	SRandMemberFunc func(ctx context.Context, key string) *redis.StringCmd

	// SRandMemberNFunc mocks the SRandMemberN method.
	SRandMemberNFunc func(ctx context.Context, key string, count int64) *redis.StringSliceCmd

	// SRemFunc mocks the SRem method.
	SRemFunc func(ctx context.Context, key string, members ...interface{}) *redis.IntCmd

	// SScanFunc mocks the SScan method.
	SScanFunc func(ctx context.Context, key string, cursor uint64, match string, count int64) *redis.ScanCmd

	// SUnionFunc mocks the SUnion method.
	SUnionFunc func(ctx context.Context, keys ...string) *redis.StringSliceCmd

	// SUnionStoreFunc mocks the SUnionStore method.
	SUnionStoreFunc func(ctx context.Context, destination string, keys ...string) *redis.IntCmd

	// SaveFunc mocks the Save method.
	SaveFunc func(ctx context.Context) *redis.StatusCmd

	// ScanFunc mocks the Scan method.
	ScanFunc func(ctx context.Context, cursor uint64, match string, count int64) *redis.ScanCmd

	// ScanTypeFunc mocks the ScanType method.
	ScanTypeFunc func(ctx context.Context, cursor uint64, match string, count int64, keyType string) *redis.ScanCmd

	// ScriptExistsFunc mocks the ScriptExists method.
	ScriptExistsFunc func(ctx context.Context, hashes ...string) *redis.BoolSliceCmd

	// ScriptFlushFunc mocks the ScriptFlush method.
	ScriptFlushFunc func(ctx context.Context) *redis.StatusCmd

	// ScriptKillFunc mocks the ScriptKill method.
	ScriptKillFunc func(ctx context.Context) *redis.StatusCmd

	// ScriptLoadFunc mocks the ScriptLoad method.
	ScriptLoadFunc func(ctx context.Context, script string) *redis.StringCmd

	// SetFunc mocks the Set method.
	SetFunc func(ctx context.Context, key string, value interface{}, expiration time.Duration) *redis.StatusCmd

	// SetArgsFunc mocks the SetArgs method.
	SetArgsFunc func(ctx context.Context, key string, value interface{}, a redis.SetArgs) *redis.StatusCmd

	// SetBitFunc mocks the SetBit method.
	SetBitFunc func(ctx context.Context, key string, offset int64, value int) *redis.IntCmd

	// SetExFunc mocks the SetEx method.
	SetExFunc func(ctx context.Context, key string, value interface{}, expiration time.Duration) *redis.StatusCmd

	// SetIFDEQFunc mocks the SetIFDEQ method.
	SetIFDEQFunc func(ctx context.Context, key string, value interface{}, matchDigest uint64, expiration time.Duration) *redis.StatusCmd

	// SetIFDEQGetFunc mocks the SetIFDEQGet method.
	SetIFDEQGetFunc func(ctx context.Context, key string, value interface{}, matchDigest uint64, expiration time.Duration) *redis.StringCmd

	// SetIFDNEFunc mocks the SetIFDNE method.
	SetIFDNEFunc func(ctx context.Context, key string, value interface{}, matchDigest uint64, expiration time.Duration) *redis.StatusCmd

	// SetIFDNEGetFunc mocks the SetIFDNEGet method.
	SetIFDNEGetFunc func(ctx context.Context, key string, value interface{}, matchDigest uint64, expiration time.Duration) *redis.StringCmd

	// SetIFEQFunc mocks the SetIFEQ method.
	SetIFEQFunc func(ctx context.Context, key string, value interface{}, matchValue interface{}, expiration time.Duration) *redis.StatusCmd

	// SetIFEQGetFunc mocks the SetIFEQGet method.
	SetIFEQGetFunc func(ctx context.Context, key string, value interface{}, matchValue interface{}, expiration time.Duration) *redis.StringCmd

	// SetIFNEFunc mocks the SetIFNE method.
	SetIFNEFunc func(ctx context.Context, key string, value interface{}, matchValue interface{}, expiration time.Duration) *redis.StatusCmd

	// SetIFNEGetFunc mocks the SetIFNEGet method.
	SetIFNEGetFunc func(ctx context.Context, key string, value interface{}, matchValue interface{}, expiration time.Duration) *redis.StringCmd

	// SetNXFunc mocks the SetNX method.
	SetNXFunc func(ctx context.Context, key string, value interface{}, expiration time.Duration) *redis.BoolCmd

	// SetRangeFunc mocks the SetRange method.
	SetRangeFunc func(ctx context.Context, key string, offset int64, value string) *redis.IntCmd

	// SetXXFunc mocks the SetXX method.
	SetXXFunc func(ctx context.Context, key string, value interface{}, expiration time.Duration) *redis.BoolCmd

	// ShutdownFunc mocks the Shutdown method.
	ShutdownFunc func(ctx context.Context) *redis.StatusCmd

	// ShutdownNoSaveFunc mocks the ShutdownNoSave method.
	ShutdownNoSaveFunc func(ctx context.Context) *redis.StatusCmd

	// ShutdownSaveFunc mocks the ShutdownSave method.
	ShutdownSaveFunc func(ctx context.Context) *redis.StatusCmd

	// SlaveOfFunc mocks the SlaveOf method.
	SlaveOfFunc func(ctx context.Context, host string, port string) *redis.StatusCmd

	// SlowLogGetFunc mocks the SlowLogGet method.
	SlowLogGetFunc func(ctx context.Context, num int64) *redis.SlowLogCmd

	// SlowLogLenFunc mocks the SlowLogLen method.
	SlowLogLenFunc func(ctx context.Context) *redis.IntCmd

	// SlowLogResetFunc mocks the SlowLogReset method.
	SlowLogResetFunc func(ctx context.Context) *redis.StatusCmd

	// SortFunc mocks the Sort method.
	SortFunc func(ctx context.Context, key string, sort *redis.Sort) *redis.StringSliceCmd

	// SortInterfacesFunc mocks the SortInterfaces method.
	SortInterfacesFunc func(ctx context.Context, key string, sort *redis.Sort) *redis.SliceCmd

	// SortROFunc mocks the SortRO method.
	SortROFunc func(ctx context.Context, key string, sort *redis.Sort) *redis.StringSliceCmd

	// SortStoreFunc mocks the SortStore method.
	SortStoreFunc func(ctx context.Context, key string, store string, sort *redis.Sort) *redis.IntCmd

	// StrLenFunc mocks the StrLen method.
	StrLenFunc func(ctx context.Context, key string) *redis.IntCmd

	// SubscribeFunc mocks the Subscribe method.
	SubscribeFunc func(ctx context.Context, channels ...string) *redis.PubSub

	// TDigestAddFunc mocks the TDigestAdd method.
	TDigestAddFunc func(ctx context.Context, key string, elements ...float64) *redis.StatusCmd

	// TDigestByRankFunc mocks the TDigestByRank method.
	TDigestByRankFunc func(ctx context.Context, key string, rank ...uint64) *redis.FloatSliceCmd

	// TDigestByRevRankFunc mocks the TDigestByRevRank method.
	TDigestByRevRankFunc func(ctx context.Context, key string, rank ...uint64) *redis.FloatSliceCmd

	// TDigestCDFFunc mocks the TDigestCDF method.
	TDigestCDFFunc func(ctx context.Context, key string, elements ...float64) *redis.FloatSliceCmd

	// TDigestCreateFunc mocks the TDigestCreate method.
	TDigestCreateFunc func(ctx context.Context, key string) *redis.StatusCmd

	// TDigestCreateWithCompressionFunc mocks the TDigestCreateWithCompression method.
	TDigestCreateWithCompressionFunc func(ctx context.Context, key string, compression int64) *redis.StatusCmd

	// TDigestInfoFunc mocks the TDigestInfo method.
	TDigestInfoFunc func(ctx context.Context, key string) *redis.TDigestInfoCmd

	// TDigestMaxFunc mocks the TDigestMax method.
	TDigestMaxFunc func(ctx context.Context, key string) *redis.FloatCmd

	// TDigestMergeFunc mocks the TDigestMerge method.
	TDigestMergeFunc func(ctx context.Context, destKey string, options *redis.TDigestMergeOptions, sourceKeys ...string) *redis.StatusCmd

	// TDigestMinFunc mocks the TDigestMin method.
	TDigestMinFunc func(ctx context.Context, key string) *redis.FloatCmd

	// TDigestQuantileFunc mocks the TDigestQuantile method.
	TDigestQuantileFunc func(ctx context.Context, key string, elements ...float64) *redis.FloatSliceCmd

	// TDigestRankFunc mocks the TDigestRank method.
	TDigestRankFunc func(ctx context.Context, key string, values ...float64) *redis.IntSliceCmd

	// TDigestResetFunc mocks the TDigestReset method.
	TDigestResetFunc func(ctx context.Context, key string) *redis.StatusCmd

	// TDigestRevRankFunc mocks the TDigestRevRank method.
	TDigestRevRankFunc func(ctx context.Context, key string, values ...float64) *redis.IntSliceCmd

	// TDigestTrimmedMeanFunc mocks the TDigestTrimmedMean method.
	TDigestTrimmedMeanFunc func(ctx context.Context, key string, lowCutQuantile float64, highCutQuantile float64) *redis.FloatCmd

	// TSAddFunc mocks the TSAdd method.
	TSAddFunc func(ctx context.Context, key string, timestamp interface{}, value float64) *redis.IntCmd

	// TSAddWithArgsFunc mocks the TSAddWithArgs method.
	TSAddWithArgsFunc func(ctx context.Context, key string, timestamp interface{}, value float64, options *redis.TSOptions) *redis.IntCmd

	// TSAlterFunc mocks the TSAlter method.
	TSAlterFunc func(ctx context.Context, key string, options *redis.TSAlterOptions) *redis.StatusCmd

	// TSCreateFunc mocks the TSCreate method.
	TSCreateFunc func(ctx context.Context, key string) *redis.StatusCmd

	// TSCreateRuleFunc mocks the TSCreateRule method.
	TSCreateRuleFunc func(ctx context.Context, sourceKey string, destKey string, aggregator redis.Aggregator, bucketDuration int) *redis.StatusCmd

	// TSCreateRuleWithArgsFunc mocks the TSCreateRuleWithArgs method.
	TSCreateRuleWithArgsFunc func(ctx context.Context, sourceKey string, destKey string, aggregator redis.Aggregator, bucketDuration int, options *redis.TSCreateRuleOptions) *redis.StatusCmd

	// TSCreateWithArgsFunc mocks the TSCreateWithArgs method.
	TSCreateWithArgsFunc func(ctx context.Context, key string, options *redis.TSOptions) *redis.StatusCmd

	// TSDecrByFunc mocks the TSDecrBy method.
	TSDecrByFunc func(ctx context.Context, Key string, timestamp float64) *redis.IntCmd

	// TSDecrByWithArgsFunc mocks the TSDecrByWithArgs method.
	TSDecrByWithArgsFunc func(ctx context.Context, key string, timestamp float64, options *redis.TSIncrDecrOptions) *redis.IntCmd

	// TSDelFunc mocks the TSDel method.
	TSDelFunc func(ctx context.Context, Key string, fromTimestamp int, toTimestamp int) *redis.IntCmd

	// TSDeleteRuleFunc mocks the TSDeleteRule method.
	TSDeleteRuleFunc func(ctx context.Context, sourceKey string, destKey string) *redis.StatusCmd

	// TSGetFunc mocks the TSGet method.
	TSGetFunc func(ctx context.Context, key string) *redis.TSTimestampValueCmd

	// TSGetWithArgsFunc mocks the TSGetWithArgs method.
	TSGetWithArgsFunc func(ctx context.Context, key string, options *redis.TSGetOptions) *redis.TSTimestampValueCmd

	// TSIncrByFunc mocks the TSIncrBy method.
	TSIncrByFunc func(ctx context.Context, Key string, timestamp float64) *redis.IntCmd

	// TSIncrByWithArgsFunc mocks the TSIncrByWithArgs method.
	TSIncrByWithArgsFunc func(ctx context.Context, key string, timestamp float64, options *redis.TSIncrDecrOptions) *redis.IntCmd

	// TSInfoFunc mocks the TSInfo method.
	TSInfoFunc func(ctx context.Context, key string) *redis.MapStringInterfaceCmd

	// TSInfoWithArgsFunc mocks the TSInfoWithArgs method.
	TSInfoWithArgsFunc func(ctx context.Context, key string, options *redis.TSInfoOptions) *redis.MapStringInterfaceCmd

	// TSMAddFunc mocks the TSMAdd method.
	TSMAddFunc func(ctx context.Context, ktvSlices [][]interface{}) *redis.IntSliceCmd

	// TSMGetFunc mocks the TSMGet method.
	TSMGetFunc func(ctx context.Context, filters []string) *redis.MapStringSliceInterfaceCmd

	// TSMGetWithArgsFunc mocks the TSMGetWithArgs method.
	TSMGetWithArgsFunc func(ctx context.Context, filters []string, options *redis.TSMGetOptions) *redis.MapStringSliceInterfaceCmd

	// TSMRangeFunc mocks the TSMRange method.
	TSMRangeFunc func(ctx context.Context, fromTimestamp int, toTimestamp int, filterExpr []string) *redis.MapStringSliceInterfaceCmd

	// TSMRangeWithArgsFunc mocks the TSMRangeWithArgs method.
	TSMRangeWithArgsFunc func(ctx context.Context, fromTimestamp int, toTimestamp int, filterExpr []string, options *redis.TSMRangeOptions) *redis.MapStringSliceInterfaceCmd

	// TSMRevRangeFunc mocks the TSMRevRange method.
	TSMRevRangeFunc func(ctx context.Context, fromTimestamp int, toTimestamp int, filterExpr []string) *redis.MapStringSliceInterfaceCmd

	// TSMRevRangeWithArgsFunc mocks the TSMRevRangeWithArgs method.
	TSMRevRangeWithArgsFunc func(ctx context.Context, fromTimestamp int, toTimestamp int, filterExpr []string, options *redis.TSMRevRangeOptions) *redis.MapStringSliceInterfaceCmd

	// TSQueryIndexFunc mocks the TSQueryIndex method.
	TSQueryIndexFunc func(ctx context.Context, filterExpr []string) *redis.StringSliceCmd

	// TSRangeFunc mocks the TSRange method.
	TSRangeFunc func(ctx context.Context, key string, fromTimestamp int, toTimestamp int) *redis.TSTimestampValueSliceCmd

	// TSRangeWithArgsFunc mocks the TSRangeWithArgs method.
	TSRangeWithArgsFunc func(ctx context.Context, key string, fromTimestamp int, toTimestamp int, options *redis.TSRangeOptions) *redis.TSTimestampValueSliceCmd

	// TSRevRangeFunc mocks the TSRevRange method.
	TSRevRangeFunc func(ctx context.Context, key string, fromTimestamp int, toTimestamp int) *redis.TSTimestampValueSliceCmd

	// TSRevRangeWithArgsFunc mocks the TSRevRangeWithArgs method.
	TSRevRangeWithArgsFunc func(ctx context.Context, key string, fromTimestamp int, toTimestamp int, options *redis.TSRevRangeOptions) *redis.TSTimestampValueSliceCmd

	// TTLFunc mocks the TTL method.
	TTLFunc func(ctx context.Context, key string) *redis.DurationCmd

	// TimeFunc mocks the Time method.
	TimeFunc func(ctx context.Context) *redis.TimeCmd

	// TopKAddFunc mocks the TopKAdd method.
	TopKAddFunc func(ctx context.Context, key string, elements ...interface{}) *redis.StringSliceCmd

	// TopKCountFunc mocks the TopKCount method.
	TopKCountFunc func(ctx context.Context, key string, elements ...interface{}) *redis.IntSliceCmd

	// TopKIncrByFunc mocks the TopKIncrBy method.
	TopKIncrByFunc func(ctx context.Context, key string, elements ...interface{}) *redis.StringSliceCmd

	// TopKInfoFunc mocks the TopKInfo method.
	TopKInfoFunc func(ctx context.Context, key string) *redis.TopKInfoCmd

	// TopKListFunc mocks the TopKList method.
	TopKListFunc func(ctx context.Context, key string) *redis.StringSliceCmd

	// TopKListWithCountFunc mocks the TopKListWithCount method.
	TopKListWithCountFunc func(ctx context.Context, key string) *redis.MapStringIntCmd

	// TopKQueryFunc mocks the TopKQuery method.
	TopKQueryFunc func(ctx context.Context, key string, elements ...interface{}) *redis.BoolSliceCmd

	// TopKReserveFunc mocks the TopKReserve method.
	TopKReserveFunc func(ctx context.Context, key string, k int64) *redis.StatusCmd

	// TopKReserveWithOptionsFunc mocks the TopKReserveWithOptions method.
	TopKReserveWithOptionsFunc func(ctx context.Context, key string, k int64, width int64, depth int64, decay float64) *redis.StatusCmd

	// TouchFunc mocks the Touch method.
	TouchFunc func(ctx context.Context, keys ...string) *redis.IntCmd

	// TxPipelineFunc mocks the TxPipeline method.
	TxPipelineFunc func() redis.Pipeliner

	// TxPipelinedFunc mocks the TxPipelined method.
	TxPipelinedFunc func(ctx context.Context, fn func(redis.Pipeliner) error) ([]redis.Cmder, error)

	// TypeFunc mocks the Type method.
	TypeFunc func(ctx context.Context, key string) *redis.StatusCmd

	// UnlinkFunc mocks the Unlink method.
	UnlinkFunc func(ctx context.Context, keys ...string) *redis.IntCmd

	// VAddFunc mocks the VAdd method.
	VAddFunc func(ctx context.Context, key string, element string, val redis.Vector) *redis.BoolCmd

	// VAddWithArgsFunc mocks the VAddWithArgs method.
	VAddWithArgsFunc func(ctx context.Context, key string, element string, val redis.Vector, addArgs *redis.VAddArgs) *redis.BoolCmd

	// VCardFunc mocks the VCard method.
	VCardFunc func(ctx context.Context, key string) *redis.IntCmd

	// VClearAttributesFunc mocks the VClearAttributes method.
	VClearAttributesFunc func(ctx context.Context, key string, element string) *redis.BoolCmd

	// VDimFunc mocks the VDim method.
	VDimFunc func(ctx context.Context, key string) *redis.IntCmd

	// VEmbFunc mocks the VEmb method.
	VEmbFunc func(ctx context.Context, key string, element string, raw bool) *redis.SliceCmd

	// VGetAttrFunc mocks the VGetAttr method.
	VGetAttrFunc func(ctx context.Context, key string, element string) *redis.StringCmd

	// VInfoFunc mocks the VInfo method.
	VInfoFunc func(ctx context.Context, key string) *redis.MapStringInterfaceCmd

	// VLinksFunc mocks the VLinks method.
	VLinksFunc func(ctx context.Context, key string, element string) *redis.StringSliceCmd

	// VLinksWithScoresFunc mocks the VLinksWithScores method.
	VLinksWithScoresFunc func(ctx context.Context, key string, element string) *redis.VectorScoreSliceCmd

	// VRandMemberFunc mocks the VRandMember method.
	VRandMemberFunc func(ctx context.Context, key string) *redis.StringCmd

	// VRandMemberCountFunc mocks the VRandMemberCount method.
	VRandMemberCountFunc func(ctx context.Context, key string, count int) *redis.StringSliceCmd

	// VRangeFunc mocks the VRange method.
	VRangeFunc func(ctx context.Context, key string, start string, end string, count int64) *redis.StringSliceCmd

	// VRemFunc mocks the VRem method.
	VRemFunc func(ctx context.Context, key string, element string) *redis.BoolCmd

	// VSetAttrFunc mocks the VSetAttr method.
	VSetAttrFunc func(ctx context.Context, key string, element string, attr interface{}) *redis.BoolCmd

	// VSimFunc mocks the VSim method.
	VSimFunc func(ctx context.Context, key string, val redis.Vector) *redis.StringSliceCmd

	// VSimWithArgsFunc mocks the VSimWithArgs method.
	VSimWithArgsFunc func(ctx context.Context, key string, val redis.Vector, args *redis.VSimArgs) *redis.StringSliceCmd

	// VSimWithArgsWithScoresFunc mocks the VSimWithArgsWithScores method.
	VSimWithArgsWithScoresFunc func(ctx context.Context, key string, val redis.Vector, args *redis.VSimArgs) *redis.VectorScoreSliceCmd

	// VSimWithScoresFunc mocks the VSimWithScores method.
	VSimWithScoresFunc func(ctx context.Context, key string, val redis.Vector) *redis.VectorScoreSliceCmd

	// XAckFunc mocks the XAck method.
	XAckFunc func(ctx context.Context, stream string, group string, ids ...string) *redis.IntCmd

	// XAckDelFunc mocks the XAckDel method.
	XAckDelFunc func(ctx context.Context, stream string, group string, mode string, ids ...string) *redis.SliceCmd

	// XAddFunc mocks the XAdd method.
	XAddFunc func(ctx context.Context, a *redis.XAddArgs) *redis.StringCmd

	// XAutoClaimFunc mocks the XAutoClaim method.
	XAutoClaimFunc func(ctx context.Context, a *redis.XAutoClaimArgs) *redis.XAutoClaimCmd

	// XAutoClaimJustIDFunc mocks the XAutoClaimJustID method.
	XAutoClaimJustIDFunc func(ctx context.Context, a *redis.XAutoClaimArgs) *redis.XAutoClaimJustIDCmd

	// XCfgSetFunc mocks the XCfgSet method.
	XCfgSetFunc func(ctx context.Context, a *redis.XCfgSetArgs) *redis.StatusCmd

	// XClaimFunc mocks the XClaim method.
	XClaimFunc func(ctx context.Context, a *redis.XClaimArgs) *redis.XMessageSliceCmd

	// XClaimJustIDFunc mocks the XClaimJustID method.
	XClaimJustIDFunc func(ctx context.Context, a *redis.XClaimArgs) *redis.StringSliceCmd

	// XDelFunc mocks the XDel method.
	XDelFunc func(ctx context.Context, stream string, ids ...string) *redis.IntCmd

	// XDelExFunc mocks the XDelEx method.
	XDelExFunc func(ctx context.Context, stream string, mode string, ids ...string) *redis.SliceCmd

	// XGroupCreateFunc mocks the XGroupCreate method.
	XGroupCreateFunc func(ctx context.Context, stream string, group string, start string) *redis.StatusCmd

	// XGroupCreateConsumerFunc mocks the XGroupCreateConsumer method.
	XGroupCreateConsumerFunc func(ctx context.Context, stream string, group string, consumer string) *redis.IntCmd

	// XGroupCreateMkStreamFunc mocks the XGroupCreateMkStream method.
	XGroupCreateMkStreamFunc func(ctx context.Context, stream string, group string, start string) *redis.StatusCmd

	// XGroupDelConsumerFunc mocks the XGroupDelConsumer method.
	XGroupDelConsumerFunc func(ctx context.Context, stream string, group string, consumer string) *redis.IntCmd

	// XGroupDestroyFunc mocks the XGroupDestroy method.
	XGroupDestroyFunc func(ctx context.Context, stream string, group string) *redis.IntCmd

	// XGroupSetIDFunc mocks the XGroupSetID method.
	XGroupSetIDFunc func(ctx context.Context, stream string, group string, start string) *redis.StatusCmd

	// XInfoConsumersFunc mocks the XInfoConsumers method.
	XInfoConsumersFunc func(ctx context.Context, key string, group string) *redis.XInfoConsumersCmd

	// XInfoGroupsFunc mocks the XInfoGroups method.
	XInfoGroupsFunc func(ctx context.Context, key string) *redis.XInfoGroupsCmd

	// XInfoStreamFunc mocks the XInfoStream method.
	XInfoStreamFunc func(ctx context.Context, key string) *redis.XInfoStreamCmd

	// XInfoStreamFullFunc mocks the XInfoStreamFull method.
	XInfoStreamFullFunc func(ctx context.Context, key string, count int) *redis.XInfoStreamFullCmd

	// XLenFunc mocks the XLen method.
	XLenFunc func(ctx context.Context, stream string) *redis.IntCmd

	// XPendingFunc mocks the XPending method.
	XPendingFunc func(ctx context.Context, stream string, group string) *redis.XPendingCmd

	// XPendingExtFunc mocks the XPendingExt method.
	XPendingExtFunc func(ctx context.Context, a *redis.XPendingExtArgs) *redis.XPendingExtCmd

	// XRangeFunc mocks the XRange method.
	XRangeFunc func(ctx context.Context, stream string, start string, stop string) *redis.XMessageSliceCmd

	// XRangeNFunc mocks the XRangeN method.
	XRangeNFunc func(ctx context.Context, stream string, start string, stop string, count int64) *redis.XMessageSliceCmd

	// XReadFunc mocks the XRead method.
	XReadFunc func(ctx context.Context, a *redis.XReadArgs) *redis.XStreamSliceCmd

	// XReadGroupFunc mocks the XReadGroup method.
	XReadGroupFunc func(ctx context.Context, a *redis.XReadGroupArgs) *redis.XStreamSliceCmd

	// XReadStreamsFunc mocks the XReadStreams method.
	XReadStreamsFunc func(ctx context.Context, streams ...string) *redis.XStreamSliceCmd

	// XRevRangeFunc mocks the XRevRange method.
	XRevRangeFunc func(ctx context.Context, stream string, start string, stop string) *redis.XMessageSliceCmd

	// XRevRangeNFunc mocks the XRevRangeN method.
	XRevRangeNFunc func(ctx context.Context, stream string, start string, stop string, count int64) *redis.XMessageSliceCmd

	// XTrimMaxLenFunc mocks the XTrimMaxLen method.
	XTrimMaxLenFunc func(ctx context.Context, key string, maxLen int64) *redis.IntCmd

	// XTrimMaxLenApproxFunc mocks the XTrimMaxLenApprox method.
	XTrimMaxLenApproxFunc func(ctx context.Context, key string, maxLen int64, limit int64) *redis.IntCmd

	// XTrimMaxLenApproxModeFunc mocks the XTrimMaxLenApproxMode method.
	XTrimMaxLenApproxModeFunc func(ctx context.Context, key string, maxLen int64, limit int64, mode string) *redis.IntCmd

	// XTrimMaxLenModeFunc mocks the XTrimMaxLenMode method.
	XTrimMaxLenModeFunc func(ctx context.Context, key string, maxLen int64, mode string) *redis.IntCmd

	// XTrimMinIDFunc mocks the XTrimMinID method.
	XTrimMinIDFunc func(ctx context.Context, key string, minID string) *redis.IntCmd

	// XTrimMinIDApproxFunc mocks the XTrimMinIDApprox method.
	XTrimMinIDApproxFunc func(ctx context.Context, key string, minID string, limit int64) *redis.IntCmd

	// XTrimMinIDApproxModeFunc mocks the XTrimMinIDApproxMode method.
	XTrimMinIDApproxModeFunc func(ctx context.Context, key string, minID string, limit int64, mode string) *redis.IntCmd

	// XTrimMinIDModeFunc mocks the XTrimMinIDMode method.
	XTrimMinIDModeFunc func(ctx context.Context, key string, minID string, mode string) *redis.IntCmd

	// ZAddFunc mocks the ZAdd method.
	ZAddFunc func(ctx context.Context, key string, members ...redis.Z) *redis.IntCmd

	// ZAddArgsFunc mocks the ZAddArgs method.
	ZAddArgsFunc func(ctx context.Context, key string, args redis.ZAddArgs) *redis.IntCmd

	// ZAddArgsIncrFunc mocks the ZAddArgsIncr method.
	ZAddArgsIncrFunc func(ctx context.Context, key string, args redis.ZAddArgs) *redis.FloatCmd

	// ZAddGTFunc mocks the ZAddGT method.
	ZAddGTFunc func(ctx context.Context, key string, members ...redis.Z) *redis.IntCmd

	// ZAddLTFunc mocks the ZAddLT method.
	ZAddLTFunc func(ctx context.Context, key string, members ...redis.Z) *redis.IntCmd

	// ZAddNXFunc mocks the ZAddNX method.
	ZAddNXFunc func(ctx context.Context, key string, members ...redis.Z) *redis.IntCmd

	// ZAddXXFunc mocks the ZAddXX method.
	ZAddXXFunc func(ctx context.Context, key string, members ...redis.Z) *redis.IntCmd

	// ZCardFunc mocks the ZCard method.
	ZCardFunc func(ctx context.Context, key string) *redis.IntCmd

	// ZCountFunc mocks the ZCount method.
	ZCountFunc func(ctx context.Context, key string, min string, max string) *redis.IntCmd

	// ZDiffFunc mocks the ZDiff method.
	ZDiffFunc func(ctx context.Context, keys ...string) *redis.StringSliceCmd

	// ZDiffStoreFunc mocks the ZDiffStore method.
	ZDiffStoreFunc func(ctx context.Context, destination string, keys ...string) *redis.IntCmd

	// ZDiffWithScoresFunc mocks the ZDiffWithScores method.
	ZDiffWithScoresFunc func(ctx context.Context, keys ...string) *redis.ZSliceCmd

	// ZIncrByFunc mocks the ZIncrBy method.
	ZIncrByFunc func(ctx context.Context, key string, increment float64, member string) *redis.FloatCmd

	// ZInterFunc mocks the ZInter method.
	ZInterFunc func(ctx context.Context, store *redis.ZStore) *redis.StringSliceCmd

	// ZInterCardFunc mocks the ZInterCard method.
	ZInterCardFunc func(ctx context.Context, limit int64, keys ...string) *redis.IntCmd

	// ZInterStoreFunc mocks the ZInterStore method.
	ZInterStoreFunc func(ctx context.Context, destination string, store *redis.ZStore) *redis.IntCmd

	// ZInterWithScoresFunc mocks the ZInterWithScores method.
	ZInterWithScoresFunc func(ctx context.Context, store *redis.ZStore) *redis.ZSliceCmd

	// ZLexCountFunc mocks the ZLexCount method.
	ZLexCountFunc func(ctx context.Context, key string, min string, max string) *redis.IntCmd

	// ZMPopFunc mocks the ZMPop method.
	ZMPopFunc func(ctx context.Context, order string, count int64, keys ...string) *redis.ZSliceWithKeyCmd

	// ZMScoreFunc mocks the ZMScore method.
	ZMScoreFunc func(ctx context.Context, key string, members ...string) *redis.FloatSliceCmd

	// ZPopMaxFunc mocks the ZPopMax method.
	ZPopMaxFunc func(ctx context.Context, key string, count ...int64) *redis.ZSliceCmd

	// ZPopMinFunc mocks the ZPopMin method.
	ZPopMinFunc func(ctx context.Context, key string, count ...int64) *redis.ZSliceCmd

	// ZRandMemberFunc mocks the ZRandMember method.
	ZRandMemberFunc func(ctx context.Context, key string, count int) *redis.StringSliceCmd

	// ZRandMemberWithScoresFunc mocks the ZRandMemberWithScores method.
	ZRandMemberWithScoresFunc func(ctx context.Context, key string, count int) *redis.ZSliceCmd

	// ZRangeFunc mocks the ZRange method.
	ZRangeFunc func(ctx context.Context, key string, start int64, stop int64) *redis.StringSliceCmd

	// ZRangeArgsFunc mocks the ZRangeArgs method.
	ZRangeArgsFunc func(ctx context.Context, z redis.ZRangeArgs) *redis.StringSliceCmd

	// ZRangeArgsWithScoresFunc mocks the ZRangeArgsWithScores method.
	ZRangeArgsWithScoresFunc func(ctx context.Context, z redis.ZRangeArgs) *redis.ZSliceCmd

	// ZRangeByLexFunc mocks the ZRangeByLex method.
	ZRangeByLexFunc func(ctx context.Context, key string, opt *redis.ZRangeBy) *redis.StringSliceCmd

	// ZRangeByScoreFunc mocks the ZRangeByScore method.
	ZRangeByScoreFunc func(ctx context.Context, key string, opt *redis.ZRangeBy) *redis.StringSliceCmd

	// ZRangeByScoreWithScoresFunc mocks the ZRangeByScoreWithScores method.
	ZRangeByScoreWithScoresFunc func(ctx context.Context, key string, opt *redis.ZRangeBy) *redis.ZSliceCmd

	// ZRangeStoreFunc mocks the ZRangeStore method.
	ZRangeStoreFunc func(ctx context.Context, dst string, z redis.ZRangeArgs) *redis.IntCmd

	// ZRangeWithScoresFunc mocks the ZRangeWithScores method.
	ZRangeWithScoresFunc func(ctx context.Context, key string, start int64, stop int64) *redis.ZSliceCmd

	// ZRankFunc mocks the ZRank method.
	ZRankFunc func(ctx context.Context, key string, member string) *redis.IntCmd

	// ZRankWithScoreFunc mocks the ZRankWithScore method.
	ZRankWithScoreFunc func(ctx context.Context, key string, member string) *redis.RankWithScoreCmd

	// ZRemFunc mocks the ZRem method.
	ZRemFunc func(ctx context.Context, key string, members ...interface{}) *redis.IntCmd

	// ZRemRangeByLexFunc mocks the ZRemRangeByLex method.
	ZRemRangeByLexFunc func(ctx context.Context, key string, min string, max string) *redis.IntCmd

	// ZRemRangeByRankFunc mocks the ZRemRangeByRank method.
	ZRemRangeByRankFunc func(ctx context.Context, key string, start int64, stop int64) *redis.IntCmd

	// ZRemRangeByScoreFunc mocks the ZRemRangeByScore method.
	ZRemRangeByScoreFunc func(ctx context.Context, key string, min string, max string) *redis.IntCmd

	// ZRevRangeFunc mocks the ZRevRange method.
	ZRevRangeFunc func(ctx context.Context, key string, start int64, stop int64) *redis.StringSliceCmd

	// ZRevRangeByLexFunc mocks the ZRevRangeByLex method.
	ZRevRangeByLexFunc func(ctx context.Context, key string, opt *redis.ZRangeBy) *redis.StringSliceCmd

	// ZRevRangeByScoreFunc mocks the ZRevRangeByScore method.
	ZRevRangeByScoreFunc func(ctx context.Context, key string, opt *redis.ZRangeBy) *redis.StringSliceCmd

	// ZRevRangeByScoreWithScoresFunc mocks the ZRevRangeByScoreWithScores method.
	ZRevRangeByScoreWithScoresFunc func(ctx context.Context, key string, opt *redis.ZRangeBy) *redis.ZSliceCmd

	// ZRevRangeWithScoresFunc mocks the ZRevRangeWithScores method.
	ZRevRangeWithScoresFunc func(ctx context.Context, key string, start int64, stop int64) *redis.ZSliceCmd

	// ZRevRankFunc mocks the ZRevRank method.
	ZRevRankFunc func(ctx context.Context, key string, member string) *redis.IntCmd

	// ZRevRankWithScoreFunc mocks the ZRevRankWithScore method.
	ZRevRankWithScoreFunc func(ctx context.Context, key string, member string) *redis.RankWithScoreCmd

	// ZScanFunc mocks the ZScan method.
	ZScanFunc func(ctx context.Context, key string, cursor uint64, match string, count int64) *redis.ScanCmd

	// ZScoreFunc mocks the ZScore method.
	ZScoreFunc func(ctx context.Context, key string, member string) *redis.FloatCmd

	// ZUnionFunc mocks the ZUnion method.
	ZUnionFunc func(ctx context.Context, store redis.ZStore) *redis.StringSliceCmd

	// ZUnionStoreFunc mocks the ZUnionStore method.
	ZUnionStoreFunc func(ctx context.Context, dest string, store *redis.ZStore) *redis.IntCmd

	// ZUnionWithScoresFunc mocks the ZUnionWithScores method.
	ZUnionWithScoresFunc func(ctx context.Context, store redis.ZStore) *redis.ZSliceCmd

	// calls tracks calls to the methods.
	calls struct {
		// ACLCat holds details about calls to the ACLCat method.
		ACLCat []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ACLCatArgs holds details about calls to the ACLCatArgs method.
		ACLCatArgs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Options is the options argument value.
			Options *redis.ACLCatArgs
		}
		// ACLDelUser holds details about calls to the ACLDelUser method.
		ACLDelUser []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Username is the username argument value.
			Username string
		}
		// ACLDryRun holds details about calls to the ACLDryRun method.
		ACLDryRun []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Username is the username argument value.
			Username string
			// Command is the command argument value.
			Command []interface{}
		}
		// ACLGenPass holds details about calls to the ACLGenPass method.
		ACLGenPass []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Bit is the bit argument value.
			Bit int
		}
		// ACLList holds details about calls to the ACLList method.
		ACLList []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ACLLog holds details about calls to the ACLLog method.
		ACLLog []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Count is the count argument value.
			Count int64
		}
		// ACLLogReset holds details about calls to the ACLLogReset method.
		ACLLogReset []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ACLSetUser holds details about calls to the ACLSetUser method.
		ACLSetUser []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Username is the username argument value.
			Username string
			// Rules is the rules argument value.
			Rules []string
		}
		// ACLUsers holds details about calls to the ACLUsers method.
		ACLUsers []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ACLWhoAmI holds details about calls to the ACLWhoAmI method.
		ACLWhoAmI []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// Append holds details about calls to the Append method.
		Append []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Value is the value argument value.
			Value string
		}
		// BFAdd holds details about calls to the BFAdd method.
		BFAdd []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Element is the element argument value.
			Element interface{}
		}
		// BFCard holds details about calls to the BFCard method.
		BFCard []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// BFExists holds details about calls to the BFExists method.
		BFExists []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Element is the element argument value.
			Element interface{}
		}
		// BFInfo holds details about calls to the BFInfo method.
		BFInfo []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// BFInfoArg holds details about calls to the BFInfoArg method.
		BFInfoArg []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Option is the option argument value.
			Option string
		}
		// BFInfoCapacity holds details about calls to the BFInfoCapacity method.
		BFInfoCapacity []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// BFInfoExpansion holds details about calls to the BFInfoExpansion method.
		BFInfoExpansion []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// BFInfoFilters holds details about calls to the BFInfoFilters method.
		BFInfoFilters []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// BFInfoItems holds details about calls to the BFInfoItems method.
		BFInfoItems []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// BFInfoSize holds details about calls to the BFInfoSize method.
		BFInfoSize []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// BFInsert holds details about calls to the BFInsert method.
		BFInsert []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Options is the options argument value.
			Options *redis.BFInsertOptions
			// Elements is the elements argument value.
			Elements []interface{}
		}
		// BFLoadChunk holds details about calls to the BFLoadChunk method.
		BFLoadChunk []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Iterator is the iterator argument value.
			Iterator int64
			// Data is the data argument value.
			Data interface{}
		}
		// BFMAdd holds details about calls to the BFMAdd method.
		BFMAdd []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Elements is the elements argument value.
			Elements []interface{}
		}
		// BFMExists holds details about calls to the BFMExists method.
		BFMExists []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Elements is the elements argument value.
			Elements []interface{}
		}
		// BFReserve holds details about calls to the BFReserve method.
		BFReserve []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// ErrorRate is the errorRate argument value.
			ErrorRate float64
			// Capacity is the capacity argument value.
			Capacity int64
		}
		// BFReserveExpansion holds details about calls to the BFReserveExpansion method.
		BFReserveExpansion []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// ErrorRate is the errorRate argument value.
			ErrorRate float64
			// Capacity is the capacity argument value.
			Capacity int64
			// Expansion is the expansion argument value.
			Expansion int64
		}
		// BFReserveNonScaling holds details about calls to the BFReserveNonScaling method.
		BFReserveNonScaling []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// ErrorRate is the errorRate argument value.
			ErrorRate float64
			// Capacity is the capacity argument value.
			Capacity int64
		}
		// BFReserveWithArgs holds details about calls to the BFReserveWithArgs method.
		BFReserveWithArgs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Options is the options argument value.
			Options *redis.BFReserveOptions
		}
		// BFScanDump holds details about calls to the BFScanDump method.
		BFScanDump []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Iterator is the iterator argument value.
			Iterator int64
		}
		// BLMPop holds details about calls to the BLMPop method.
		BLMPop []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Timeout is the timeout argument value.
			Timeout time.Duration
			// Direction is the direction argument value.
			Direction string
			// Count is the count argument value.
			Count int64
			// Keys is the keys argument value.
			Keys []string
		}
		// BLMove holds details about calls to the BLMove method.
		BLMove []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Source is the source argument value.
			Source string
			// Destination is the destination argument value.
			Destination string
			// Srcpos is the srcpos argument value.
			Srcpos string
			// Destpos is the destpos argument value.
			Destpos string
			// Timeout is the timeout argument value.
			Timeout time.Duration
		}
		// BLPop holds details about calls to the BLPop method.
		BLPop []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Timeout is the timeout argument value.
			Timeout time.Duration
			// Keys is the keys argument value.
			Keys []string
		}
		// BRPop holds details about calls to the BRPop method.
		BRPop []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Timeout is the timeout argument value.
			Timeout time.Duration
			// Keys is the keys argument value.
			Keys []string
		}
		// BRPopLPush holds details about calls to the BRPopLPush method.
		BRPopLPush []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Source is the source argument value.
			Source string
			// Destination is the destination argument value.
			Destination string
			// Timeout is the timeout argument value.
			Timeout time.Duration
		}
		// BZMPop holds details about calls to the BZMPop method.
		BZMPop []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Timeout is the timeout argument value.
			Timeout time.Duration
			// Order is the order argument value.
			Order string
			// Count is the count argument value.
			Count int64
			// Keys is the keys argument value.
			Keys []string
		}
		// BZPopMax holds details about calls to the BZPopMax method.
		BZPopMax []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Timeout is the timeout argument value.
			Timeout time.Duration
			// Keys is the keys argument value.
			Keys []string
		}
		// BZPopMin holds details about calls to the BZPopMin method.
		BZPopMin []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Timeout is the timeout argument value.
			Timeout time.Duration
			// Keys is the keys argument value.
			Keys []string
		}
		// BgRewriteAOF holds details about calls to the BgRewriteAOF method.
		BgRewriteAOF []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// BgSave holds details about calls to the BgSave method.
		BgSave []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// BitCount holds details about calls to the BitCount method.
		BitCount []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// BitCount is the bitCount argument value.
			BitCount *redis.BitCount
		}
		// BitField holds details about calls to the BitField method.
		BitField []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Values is the values argument value.
			Values []interface{}
		}
		// BitFieldRO holds details about calls to the BitFieldRO method.
		BitFieldRO []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Values is the values argument value.
			Values []interface{}
		}
		// BitOpAnd holds details about calls to the BitOpAnd method.
		BitOpAnd []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// DestKey is the destKey argument value.
			DestKey string
			// Keys is the keys argument value.
			Keys []string
		}
		// BitOpAndOr holds details about calls to the BitOpAndOr method.
		BitOpAndOr []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// DestKey is the destKey argument value.
			DestKey string
			// Keys is the keys argument value.
			Keys []string
		}
		// BitOpDiff holds details about calls to the BitOpDiff method.
		BitOpDiff []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// DestKey is the destKey argument value.
			DestKey string
			// Keys is the keys argument value.
			Keys []string
		}
		// BitOpDiff1 holds details about calls to the BitOpDiff1 method.
		BitOpDiff1 []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// DestKey is the destKey argument value.
			DestKey string
			// Keys is the keys argument value.
			Keys []string
		}
		// BitOpNot holds details about calls to the BitOpNot method.
		BitOpNot []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// DestKey is the destKey argument value.
			DestKey string
			// Key is the key argument value.
			Key string
		}
		// BitOpOne holds details about calls to the BitOpOne method.
		BitOpOne []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// DestKey is the destKey argument value.
			DestKey string
			// Keys is the keys argument value.
			Keys []string
		}
		// BitOpOr holds details about calls to the BitOpOr method.
		BitOpOr []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// DestKey is the destKey argument value.
			DestKey string
			// Keys is the keys argument value.
			Keys []string
		}
		// BitOpXor holds details about calls to the BitOpXor method.
		BitOpXor []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// DestKey is the destKey argument value.
			DestKey string
			// Keys is the keys argument value.
			Keys []string
		}
		// BitPos holds details about calls to the BitPos method.
		BitPos []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Bit is the bit argument value.
			Bit int64
			// Pos is the pos argument value.
			Pos []int64
		}
		// BitPosSpan holds details about calls to the BitPosSpan method.
		BitPosSpan []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Bit is the bit argument value.
			Bit int8
			// Start is the start argument value.
			Start int64
			// End is the end argument value.
			End int64
			// Span is the span argument value.
			Span string
		}
		// CFAdd holds details about calls to the CFAdd method.
		CFAdd []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Element is the element argument value.
			Element interface{}
		}
		// CFAddNX holds details about calls to the CFAddNX method.
		CFAddNX []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Element is the element argument value.
			Element interface{}
		}
		// CFCount holds details about calls to the CFCount method.
		CFCount []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Element is the element argument value.
			Element interface{}
		}
		// CFDel holds details about calls to the CFDel method.
		CFDel []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Element is the element argument value.
			Element interface{}
		}
		// CFExists holds details about calls to the CFExists method.
		CFExists []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Element is the element argument value.
			Element interface{}
		}
		// CFInfo holds details about calls to the CFInfo method.
		CFInfo []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// CFInsert holds details about calls to the CFInsert method.
		CFInsert []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Options is the options argument value.
			Options *redis.CFInsertOptions
			// Elements is the elements argument value.
			Elements []interface{}
		}
		// CFInsertNX holds details about calls to the CFInsertNX method.
		CFInsertNX []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Options is the options argument value.
			Options *redis.CFInsertOptions
			// Elements is the elements argument value.
			Elements []interface{}
		}
		// CFLoadChunk holds details about calls to the CFLoadChunk method.
		CFLoadChunk []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Iterator is the iterator argument value.
			Iterator int64
			// Data is the data argument value.
			Data interface{}
		}
		// CFMExists holds details about calls to the CFMExists method.
		CFMExists []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Elements is the elements argument value.
			Elements []interface{}
		}
		// CFReserve holds details about calls to the CFReserve method.
		CFReserve []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Capacity is the capacity argument value.
			Capacity int64
		}
		// CFReserveBucketSize holds details about calls to the CFReserveBucketSize method.
		CFReserveBucketSize []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Capacity is the capacity argument value.
			Capacity int64
			// Bucketsize is the bucketsize argument value.
			Bucketsize int64
		}
		// CFReserveExpansion holds details about calls to the CFReserveExpansion method.
		CFReserveExpansion []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Capacity is the capacity argument value.
			Capacity int64
			// Expansion is the expansion argument value.
			Expansion int64
		}
		// CFReserveMaxIterations holds details about calls to the CFReserveMaxIterations method.
		CFReserveMaxIterations []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Capacity is the capacity argument value.
			Capacity int64
			// Maxiterations is the maxiterations argument value.
			Maxiterations int64
		}
		// CFReserveWithArgs holds details about calls to the CFReserveWithArgs method.
		CFReserveWithArgs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Options is the options argument value.
			Options *redis.CFReserveOptions
		}
		// CFScanDump holds details about calls to the CFScanDump method.
		CFScanDump []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Iterator is the iterator argument value.
			Iterator int64
		}
		// CMSIncrBy holds details about calls to the CMSIncrBy method.
		CMSIncrBy []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Elements is the elements argument value.
			Elements []interface{}
		}
		// CMSInfo holds details about calls to the CMSInfo method.
		CMSInfo []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// CMSInitByDim holds details about calls to the CMSInitByDim method.
		CMSInitByDim []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Width is the width argument value.
			Width int64
			// Height is the height argument value.
			Height int64
		}
		// CMSInitByProb holds details about calls to the CMSInitByProb method.
		CMSInitByProb []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// ErrorRate is the errorRate argument value.
			ErrorRate float64
			// Probability is the probability argument value.
			Probability float64
		}
		// CMSMerge holds details about calls to the CMSMerge method.
		CMSMerge []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// DestKey is the destKey argument value.
			DestKey string
			// SourceKeys is the sourceKeys argument value.
			SourceKeys []string
		}
		// CMSMergeWithWeight holds details about calls to the CMSMergeWithWeight method.
		CMSMergeWithWeight []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// DestKey is the destKey argument value.
			DestKey string
			// SourceKeys is the sourceKeys argument value.
			SourceKeys map[string]int64
		}
		// CMSQuery holds details about calls to the CMSQuery method.
		CMSQuery []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Elements is the elements argument value.
			Elements []interface{}
		}
		// ClientGetName holds details about calls to the ClientGetName method.
		ClientGetName []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ClientID holds details about calls to the ClientID method.
		ClientID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ClientInfo holds details about calls to the ClientInfo method.
		ClientInfo []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ClientKill holds details about calls to the ClientKill method.
		ClientKill []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// IpPort is the ipPort argument value.
			IpPort string
		}
		// ClientKillByFilter holds details about calls to the ClientKillByFilter method.
		ClientKillByFilter []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Keys is the keys argument value.
			Keys []string
		}
		// ClientList holds details about calls to the ClientList method.
		ClientList []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ClientMaintNotifications holds details about calls to the ClientMaintNotifications method.
		ClientMaintNotifications []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Enabled is the enabled argument value.
			Enabled bool
			// EndpointType is the endpointType argument value.
			EndpointType string
		}
		// ClientPause holds details about calls to the ClientPause method.
		ClientPause []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Dur is the dur argument value.
			Dur time.Duration
		}
		// ClientUnblock holds details about calls to the ClientUnblock method.
		ClientUnblock []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID int64
		}
		// ClientUnblockWithError holds details about calls to the ClientUnblockWithError method.
		ClientUnblockWithError []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID int64
		}
		// ClientUnpause holds details about calls to the ClientUnpause method.
		ClientUnpause []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ClusterAddSlots holds details about calls to the ClusterAddSlots method.
		ClusterAddSlots []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Slots is the slots argument value.
			Slots []int
		}
		// ClusterAddSlotsRange holds details about calls to the ClusterAddSlotsRange method.
		ClusterAddSlotsRange []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Min is the min argument value.
			Min int
			// Max is the max argument value.
			Max int
		}
		// ClusterCountFailureReports holds details about calls to the ClusterCountFailureReports method.
		ClusterCountFailureReports []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// NodeID is the nodeID argument value.
			NodeID string
		}
		// ClusterCountKeysInSlot holds details about calls to the ClusterCountKeysInSlot method.
		ClusterCountKeysInSlot []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Slot is the slot argument value.
			Slot int
		}
		// ClusterDelSlots holds details about calls to the ClusterDelSlots method.
		ClusterDelSlots []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Slots is the slots argument value.
			Slots []int
		}
		// ClusterDelSlotsRange holds details about calls to the ClusterDelSlotsRange method.
		ClusterDelSlotsRange []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Min is the min argument value.
			Min int
			// Max is the max argument value.
			Max int
		}
		// ClusterFailover holds details about calls to the ClusterFailover method.
		ClusterFailover []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ClusterForget holds details about calls to the ClusterForget method.
		ClusterForget []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// NodeID is the nodeID argument value.
			NodeID string
		}
		// ClusterGetKeysInSlot holds details about calls to the ClusterGetKeysInSlot method.
		ClusterGetKeysInSlot []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Slot is the slot argument value.
			Slot int
			// Count is the count argument value.
			Count int
		}
		// ClusterInfo holds details about calls to the ClusterInfo method.
		ClusterInfo []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ClusterKeySlot holds details about calls to the ClusterKeySlot method.
		ClusterKeySlot []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// ClusterLinks holds details about calls to the ClusterLinks method.
		ClusterLinks []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ClusterMeet holds details about calls to the ClusterMeet method.
		ClusterMeet []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Host is the host argument value.
			Host string
			// Port is the port argument value.
			Port string
		}
		// ClusterMyID holds details about calls to the ClusterMyID method.
		ClusterMyID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ClusterMyShardID holds details about calls to the ClusterMyShardID method.
		ClusterMyShardID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ClusterNodes holds details about calls to the ClusterNodes method.
		ClusterNodes []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ClusterReplicate holds details about calls to the ClusterReplicate method.
		ClusterReplicate []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// NodeID is the nodeID argument value.
			NodeID string
		}
		// ClusterResetHard holds details about calls to the ClusterResetHard method.
		ClusterResetHard []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ClusterResetSoft holds details about calls to the ClusterResetSoft method.
		ClusterResetSoft []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ClusterSaveConfig holds details about calls to the ClusterSaveConfig method.
		ClusterSaveConfig []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ClusterShards holds details about calls to the ClusterShards method.
		ClusterShards []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ClusterSlaves holds details about calls to the ClusterSlaves method.
		ClusterSlaves []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// NodeID is the nodeID argument value.
			NodeID string
		}
		// ClusterSlots holds details about calls to the ClusterSlots method.
		ClusterSlots []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// Command holds details about calls to the Command method.
		Command []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// CommandGetKeys holds details about calls to the CommandGetKeys method.
		CommandGetKeys []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Commands is the commands argument value.
			Commands []interface{}
		}
		// CommandGetKeysAndFlags holds details about calls to the CommandGetKeysAndFlags method.
		CommandGetKeysAndFlags []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Commands is the commands argument value.
			Commands []interface{}
		}
		// CommandList holds details about calls to the CommandList method.
		CommandList []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Filter is the filter argument value.
			Filter *redis.FilterBy
		}
		// ConfigGet holds details about calls to the ConfigGet method.
		ConfigGet []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Parameter is the parameter argument value.
			Parameter string
		}
		// ConfigResetStat holds details about calls to the ConfigResetStat method.
		ConfigResetStat []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ConfigRewrite holds details about calls to the ConfigRewrite method.
		ConfigRewrite []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ConfigSet holds details about calls to the ConfigSet method.
		ConfigSet []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Parameter is the parameter argument value.
			Parameter string
			// Value is the value argument value.
			Value string
		}
		// Copy holds details about calls to the Copy method.
		Copy []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// SourceKey is the sourceKey argument value.
			SourceKey string
			// DestKey is the destKey argument value.
			DestKey string
			// Db is the db argument value.
			Db int
			// Replace is the replace argument value.
			Replace bool
		}
		// DBSize holds details about calls to the DBSize method.
		DBSize []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// DebugObject holds details about calls to the DebugObject method.
		DebugObject []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// Decr holds details about calls to the Decr method.
		Decr []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// DecrBy holds details about calls to the DecrBy method.
		DecrBy []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Decrement is the decrement argument value.
			Decrement int64
		}
		// Del holds details about calls to the Del method.
		Del []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Keys is the keys argument value.
			Keys []string
		}
		// DelExArgs holds details about calls to the DelExArgs method.
		DelExArgs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// A is the a argument value.
			A redis.DelExArgs
		}
		// Digest holds details about calls to the Digest method.
		Digest []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// Dump holds details about calls to the Dump method.
		Dump []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// Echo holds details about calls to the Echo method.
		Echo []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Message is the message argument value.
			Message interface{}
		}
		// Eval holds details about calls to the Eval method.
		Eval []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Script is the script argument value.
			Script string
			// Keys is the keys argument value.
			Keys []string
			// Args is the args argument value.
			Args []interface{}
		}
		// EvalRO holds details about calls to the EvalRO method.
		EvalRO []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Script is the script argument value.
			Script string
			// Keys is the keys argument value.
			Keys []string
			// Args is the args argument value.
			Args []interface{}
		}
		// EvalSha holds details about calls to the EvalSha method.
		EvalSha []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Sha1 is the sha1 argument value.
			Sha1 string
			// Keys is the keys argument value.
			Keys []string
			// Args is the args argument value.
			Args []interface{}
		}
		// EvalShaRO holds details about calls to the EvalShaRO method.
		EvalShaRO []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Sha1 is the sha1 argument value.
			Sha1 string
			// Keys is the keys argument value.
			Keys []string
			// Args is the args argument value.
			Args []interface{}
		}
		// Exists holds details about calls to the Exists method.
		Exists []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Keys is the keys argument value.
			Keys []string
		}
		// Expire holds details about calls to the Expire method.
		Expire []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Expiration is the expiration argument value.
			Expiration time.Duration
		}
		// ExpireAt holds details about calls to the ExpireAt method.
		ExpireAt []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Tm is the tm argument value.
			Tm time.Time
		}
		// ExpireGT holds details about calls to the ExpireGT method.
		ExpireGT []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Expiration is the expiration argument value.
			Expiration time.Duration
		}
		// ExpireLT holds details about calls to the ExpireLT method.
		ExpireLT []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Expiration is the expiration argument value.
			Expiration time.Duration
		}
		// ExpireNX holds details about calls to the ExpireNX method.
		ExpireNX []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Expiration is the expiration argument value.
			Expiration time.Duration
		}
		// ExpireTime holds details about calls to the ExpireTime method.
		ExpireTime []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// ExpireXX holds details about calls to the ExpireXX method.
		ExpireXX []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Expiration is the expiration argument value.
			Expiration time.Duration
		}
		// FCall holds details about calls to the FCall method.
		FCall []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Function is the function argument value.
			Function string
			// Keys is the keys argument value.
			Keys []string
			// Args is the args argument value.
			Args []interface{}
		}
		// FCallRO holds details about calls to the FCallRO method.
		FCallRO []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Function is the function argument value.
			Function string
			// Keys is the keys argument value.
			Keys []string
			// Args is the args argument value.
			Args []interface{}
		}
		// FCallRo holds details about calls to the FCallRo method.
		FCallRo []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Function is the function argument value.
			Function string
			// Keys is the keys argument value.
			Keys []string
			// Args is the args argument value.
			Args []interface{}
		}
		// FTAggregate holds details about calls to the FTAggregate method.
		FTAggregate []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Index is the index argument value.
			Index string
			// Query is the query argument value.
			Query string
		}
		// FTAggregateWithArgs holds details about calls to the FTAggregateWithArgs method.
		FTAggregateWithArgs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Index is the index argument value.
			Index string
			// Query is the query argument value.
			Query string
			// Options is the options argument value.
			Options *redis.FTAggregateOptions
		}
		// FTAliasAdd holds details about calls to the FTAliasAdd method.
		FTAliasAdd []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Index is the index argument value.
			Index string
			// Alias is the alias argument value.
			Alias string
		}
		// FTAliasDel holds details about calls to the FTAliasDel method.
		FTAliasDel []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Alias is the alias argument value.
			Alias string
		}
		// FTAliasUpdate holds details about calls to the FTAliasUpdate method.
		FTAliasUpdate []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Index is the index argument value.
			Index string
			// Alias is the alias argument value.
			Alias string
		}
		// FTAlter holds details about calls to the FTAlter method.
		FTAlter []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Index is the index argument value.
			Index string
			// SkipInitialScan is the skipInitialScan argument value.
			SkipInitialScan bool
			// Definition is the definition argument value.
			Definition []interface{}
		}
		// FTConfigGet holds details about calls to the FTConfigGet method.
		FTConfigGet []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Option is the option argument value.
			Option string
		}
		// FTConfigSet holds details about calls to the FTConfigSet method.
		FTConfigSet []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Option is the option argument value.
			Option string
			// Value is the value argument value.
			Value interface{}
		}
		// FTCreate holds details about calls to the FTCreate method.
		FTCreate []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Index is the index argument value.
			Index string
			// Options is the options argument value.
			Options *redis.FTCreateOptions
			// Schema is the schema argument value.
			Schema []*redis.FieldSchema
		}
		// FTCursorDel holds details about calls to the FTCursorDel method.
		FTCursorDel []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Index is the index argument value.
			Index string
			// CursorId is the cursorId argument value.
			CursorId int
		}
		// FTCursorRead holds details about calls to the FTCursorRead method.
		FTCursorRead []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Index is the index argument value.
			Index string
			// CursorId is the cursorId argument value.
			CursorId int
			// Count is the count argument value.
			Count int
		}
		// FTDictAdd holds details about calls to the FTDictAdd method.
		FTDictAdd []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Dict is the dict argument value.
			Dict string
			// Term is the term argument value.
			Term []interface{}
		}
		// FTDictDel holds details about calls to the FTDictDel method.
		FTDictDel []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Dict is the dict argument value.
			Dict string
			// Term is the term argument value.
			Term []interface{}
		}
		// FTDictDump holds details about calls to the FTDictDump method.
		FTDictDump []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Dict is the dict argument value.
			Dict string
		}
		// FTDropIndex holds details about calls to the FTDropIndex method.
		FTDropIndex []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Index is the index argument value.
			Index string
		}
		// FTDropIndexWithArgs holds details about calls to the FTDropIndexWithArgs method.
		FTDropIndexWithArgs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Index is the index argument value.
			Index string
			// Options is the options argument value.
			Options *redis.FTDropIndexOptions
		}
		// FTExplain holds details about calls to the FTExplain method.
		FTExplain []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Index is the index argument value.
			Index string
			// Query is the query argument value.
			Query string
		}
		// FTExplainWithArgs holds details about calls to the FTExplainWithArgs method.
		FTExplainWithArgs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Index is the index argument value.
			Index string
			// Query is the query argument value.
			Query string
			// Options is the options argument value.
			Options *redis.FTExplainOptions
		}
		// FTHybrid holds details about calls to the FTHybrid method.
		FTHybrid []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Index is the index argument value.
			Index string
			// SearchExpr is the searchExpr argument value.
			SearchExpr string
			// VectorField is the vectorField argument value.
			VectorField string
			// VectorData is the vectorData argument value.
			VectorData redis.Vector
		}
		// FTHybridWithArgs holds details about calls to the FTHybridWithArgs method.
		FTHybridWithArgs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Index is the index argument value.
			Index string
			// Options is the options argument value.
			Options *redis.FTHybridOptions
		}
		// FTInfo holds details about calls to the FTInfo method.
		FTInfo []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Index is the index argument value.
			Index string
		}
		// FTSearch holds details about calls to the FTSearch method.
		FTSearch []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Index is the index argument value.
			Index string
			// Query is the query argument value.
			Query string
		}
		// FTSearchWithArgs holds details about calls to the FTSearchWithArgs method.
		FTSearchWithArgs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Index is the index argument value.
			Index string
			// Query is the query argument value.
			Query string
			// Options is the options argument value.
			Options *redis.FTSearchOptions
		}
		// FTSpellCheck holds details about calls to the FTSpellCheck method.
		FTSpellCheck []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Index is the index argument value.
			Index string
			// Query is the query argument value.
			Query string
		}
		// FTSpellCheckWithArgs holds details about calls to the FTSpellCheckWithArgs method.
		FTSpellCheckWithArgs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Index is the index argument value.
			Index string
			// Query is the query argument value.
			Query string
			// Options is the options argument value.
			Options *redis.FTSpellCheckOptions
		}
		// FTSynDump holds details about calls to the FTSynDump method.
		FTSynDump []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Index is the index argument value.
			Index string
		}
		// FTSynUpdate holds details about calls to the FTSynUpdate method.
		FTSynUpdate []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Index is the index argument value.
			Index string
			// SynGroupId is the synGroupId argument value.
			SynGroupId interface{}
			// Terms is the terms argument value.
			Terms []interface{}
		}
		// FTSynUpdateWithArgs holds details about calls to the FTSynUpdateWithArgs method.
		FTSynUpdateWithArgs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Index is the index argument value.
			Index string
			// SynGroupId is the synGroupId argument value.
			SynGroupId interface{}
			// Options is the options argument value.
			Options *redis.FTSynUpdateOptions
			// Terms is the terms argument value.
			Terms []interface{}
		}
		// FTTagVals holds details about calls to the FTTagVals method.
		FTTagVals []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Index is the index argument value.
			Index string
			// Field is the field argument value.
			Field string
		}
		// FT_List holds details about calls to the FT_List method.
		FT_List []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// FlushAll holds details about calls to the FlushAll method.
		FlushAll []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// FlushAllAsync holds details about calls to the FlushAllAsync method.
		FlushAllAsync []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// FlushDB holds details about calls to the FlushDB method.
		FlushDB []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// FlushDBAsync holds details about calls to the FlushDBAsync method.
		FlushDBAsync []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// FunctionDelete holds details about calls to the FunctionDelete method.
		FunctionDelete []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// LibName is the libName argument value.
			LibName string
		}
		// FunctionDump holds details about calls to the FunctionDump method.
		FunctionDump []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// FunctionFlush holds details about calls to the FunctionFlush method.
		FunctionFlush []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// FunctionFlushAsync holds details about calls to the FunctionFlushAsync method.
		FunctionFlushAsync []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// FunctionKill holds details about calls to the FunctionKill method.
		FunctionKill []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// FunctionList holds details about calls to the FunctionList method.
		FunctionList []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Q is the q argument value.
			Q redis.FunctionListQuery
		}
		// FunctionLoad holds details about calls to the FunctionLoad method.
		FunctionLoad []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Code is the code argument value.
			Code string
		}
		// FunctionLoadReplace holds details about calls to the FunctionLoadReplace method.
		FunctionLoadReplace []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Code is the code argument value.
			Code string
		}
		// FunctionRestore holds details about calls to the FunctionRestore method.
		FunctionRestore []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// LibDump is the libDump argument value.
			LibDump string
		}
		// FunctionStats holds details about calls to the FunctionStats method.
		FunctionStats []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// GeoAdd holds details about calls to the GeoAdd method.
		GeoAdd []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// GeoLocation is the geoLocation argument value.
			GeoLocation []*redis.GeoLocation
		}
		// GeoDist holds details about calls to the GeoDist method.
		GeoDist []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Member1 is the member1 argument value.
			Member1 string
			// Member2 is the member2 argument value.
			Member2 string
			// Unit is the unit argument value.
			Unit string
		}
		// GeoHash holds details about calls to the GeoHash method.
		GeoHash []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Members is the members argument value.
			Members []string
		}
		// GeoPos holds details about calls to the GeoPos method.
		GeoPos []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Members is the members argument value.
			Members []string
		}
		// GeoRadius holds details about calls to the GeoRadius method.
		GeoRadius []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Longitude is the longitude argument value.
			Longitude float64
			// Latitude is the latitude argument value.
			Latitude float64
			// Query is the query argument value.
			Query *redis.GeoRadiusQuery
		}
		// GeoRadiusByMember holds details about calls to the GeoRadiusByMember method.
		GeoRadiusByMember []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Member is the member argument value.
			Member string
			// Query is the query argument value.
			Query *redis.GeoRadiusQuery
		}
		// GeoRadiusByMemberStore holds details about calls to the GeoRadiusByMemberStore method.
		GeoRadiusByMemberStore []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Member is the member argument value.
			Member string
			// Query is the query argument value.
			Query *redis.GeoRadiusQuery
		}
		// GeoRadiusStore holds details about calls to the GeoRadiusStore method.
		GeoRadiusStore []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Longitude is the longitude argument value.
			Longitude float64
			// Latitude is the latitude argument value.
			Latitude float64
			// Query is the query argument value.
			Query *redis.GeoRadiusQuery
		}
		// GeoSearch holds details about calls to the GeoSearch method.
		GeoSearch []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Q is the q argument value.
			Q *redis.GeoSearchQuery
		}
		// GeoSearchLocation holds details about calls to the GeoSearchLocation method.
		GeoSearchLocation []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Q is the q argument value.
			Q *redis.GeoSearchLocationQuery
		}
		// GeoSearchStore holds details about calls to the GeoSearchStore method.
		GeoSearchStore []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Store is the store argument value.
			Store string
			// Q is the q argument value.
			Q *redis.GeoSearchStoreQuery
		}
		// Get holds details about calls to the Get method.
		Get []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// GetBit holds details about calls to the GetBit method.
		GetBit []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Offset is the offset argument value.
			Offset int64
		}
		// GetDel holds details about calls to the GetDel method.
		GetDel []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// GetEx holds details about calls to the GetEx method.
		GetEx []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Expiration is the expiration argument value.
			Expiration time.Duration
		}
		// GetRange holds details about calls to the GetRange method.
		GetRange []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Start is the start argument value.
			Start int64
			// End is the end argument value.
			End int64
		}
		// GetSet holds details about calls to the GetSet method.
		GetSet []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Value is the value argument value.
			Value interface{}
		}
		// HDel holds details about calls to the HDel method.
		HDel []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Fields is the fields argument value.
			Fields []string
		}
		// HExists holds details about calls to the HExists method.
		HExists []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Field is the field argument value.
			Field string
		}
		// HExpire holds details about calls to the HExpire method.
		HExpire []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Expiration is the expiration argument value.
			Expiration time.Duration
			// Fields is the fields argument value.
			Fields []string
		}
		// HExpireAt holds details about calls to the HExpireAt method.
		HExpireAt []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Tm is the tm argument value.
			Tm time.Time
			// Fields is the fields argument value.
			Fields []string
		}
		// HExpireAtWithArgs holds details about calls to the HExpireAtWithArgs method.
		HExpireAtWithArgs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Tm is the tm argument value.
			Tm time.Time
			// ExpirationArgs is the expirationArgs argument value.
			ExpirationArgs redis.HExpireArgs
			// Fields is the fields argument value.
			Fields []string
		}
		// HExpireTime holds details about calls to the HExpireTime method.
		HExpireTime []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Fields is the fields argument value.
			Fields []string
		}
		// HExpireWithArgs holds details about calls to the HExpireWithArgs method.
		HExpireWithArgs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Expiration is the expiration argument value.
			Expiration time.Duration
			// ExpirationArgs is the expirationArgs argument value.
			ExpirationArgs redis.HExpireArgs
			// Fields is the fields argument value.
			Fields []string
		}
		// HGet holds details about calls to the HGet method.
		HGet []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Field is the field argument value.
			Field string
		}
		// HGetAll holds details about calls to the HGetAll method.
		HGetAll []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// HGetDel holds details about calls to the HGetDel method.
		HGetDel []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Fields is the fields argument value.
			Fields []string
		}
		// HGetEX holds details about calls to the HGetEX method.
		HGetEX []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Fields is the fields argument value.
			Fields []string
		}
		// HGetEXWithArgs holds details about calls to the HGetEXWithArgs method.
		HGetEXWithArgs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Options is the options argument value.
			Options *redis.HGetEXOptions
			// Fields is the fields argument value.
			Fields []string
		}
		// HIncrBy holds details about calls to the HIncrBy method.
		HIncrBy []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Field is the field argument value.
			Field string
			// Incr is the incr argument value.
			Incr int64
		}
		// HIncrByFloat holds details about calls to the HIncrByFloat method.
		HIncrByFloat []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Field is the field argument value.
			Field string
			// Incr is the incr argument value.
			Incr float64
		}
		// HKeys holds details about calls to the HKeys method.
		HKeys []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// HLen holds details about calls to the HLen method.
		HLen []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// HMGet holds details about calls to the HMGet method.
		HMGet []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Fields is the fields argument value.
			Fields []string
		}
		// HMSet holds details about calls to the HMSet method.
		HMSet []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Values is the values argument value.
			Values []interface{}
		}
		// HPExpire holds details about calls to the HPExpire method.
		HPExpire []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Expiration is the expiration argument value.
			Expiration time.Duration
			// Fields is the fields argument value.
			Fields []string
		}
		// HPExpireAt holds details about calls to the HPExpireAt method.
		HPExpireAt []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Tm is the tm argument value.
			Tm time.Time
			// Fields is the fields argument value.
			Fields []string
		}
		// HPExpireAtWithArgs holds details about calls to the HPExpireAtWithArgs method.
		HPExpireAtWithArgs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Tm is the tm argument value.
			Tm time.Time
			// ExpirationArgs is the expirationArgs argument value.
			ExpirationArgs redis.HExpireArgs
			// Fields is the fields argument value.
			Fields []string
		}
		// HPExpireTime holds details about calls to the HPExpireTime method.
		HPExpireTime []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Fields is the fields argument value.
			Fields []string
		}
		// HPExpireWithArgs holds details about calls to the HPExpireWithArgs method.
		HPExpireWithArgs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Expiration is the expiration argument value.
			Expiration time.Duration
			// ExpirationArgs is the expirationArgs argument value.
			ExpirationArgs redis.HExpireArgs
			// Fields is the fields argument value.
			Fields []string
		}
		// HPTTL holds details about calls to the HPTTL method.
		HPTTL []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Fields is the fields argument value.
			Fields []string
		}
		// HPersist holds details about calls to the HPersist method.
		HPersist []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Fields is the fields argument value.
			Fields []string
		}
		// HRandField holds details about calls to the HRandField method.
		HRandField []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Count is the count argument value.
			Count int
		}
		// HRandFieldWithValues holds details about calls to the HRandFieldWithValues method.
		HRandFieldWithValues []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Count is the count argument value.
			Count int
		}
		// HScan holds details about calls to the HScan method.
		HScan []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Cursor is the cursor argument value.
			Cursor uint64
			// Match is the match argument value.
			Match string
			// Count is the count argument value.
			Count int64
		}
		// HScanNoValues holds details about calls to the HScanNoValues method.
		HScanNoValues []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Cursor is the cursor argument value.
			Cursor uint64
			// Match is the match argument value.
			Match string
			// Count is the count argument value.
			Count int64
		}
		// HSet holds details about calls to the HSet method.
		HSet []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Values is the values argument value.
			Values []interface{}
		}
		// HSetEX holds details about calls to the HSetEX method.
		HSetEX []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// FieldsAndValues is the fieldsAndValues argument value.
			FieldsAndValues []string
		}
		// HSetEXWithArgs holds details about calls to the HSetEXWithArgs method.
		HSetEXWithArgs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Options is the options argument value.
			Options *redis.HSetEXOptions
			// FieldsAndValues is the fieldsAndValues argument value.
			FieldsAndValues []string
		}
		// HSetNX holds details about calls to the HSetNX method.
		HSetNX []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Field is the field argument value.
			Field string
			// Value is the value argument value.
			Value interface{}
		}
		// HStrLen holds details about calls to the HStrLen method.
		HStrLen []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Field is the field argument value.
			Field string
		}
		// HTTL holds details about calls to the HTTL method.
		HTTL []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Fields is the fields argument value.
			Fields []string
		}
		// HVals holds details about calls to the HVals method.
		HVals []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// Incr holds details about calls to the Incr method.
		Incr []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// IncrBy holds details about calls to the IncrBy method.
		IncrBy []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Value is the value argument value.
			Value int64
		}
		// IncrByFloat holds details about calls to the IncrByFloat method.
		IncrByFloat []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Value is the value argument value.
			Value float64
		}
		// Info holds details about calls to the Info method.
		Info []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Section is the section argument value.
			Section []string
		}
		// JSONArrAppend holds details about calls to the JSONArrAppend method.
		JSONArrAppend []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Path is the path argument value.
			Path string
			// Values is the values argument value.
			Values []interface{}
		}
		// JSONArrIndex holds details about calls to the JSONArrIndex method.
		JSONArrIndex []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Path is the path argument value.
			Path string
			// Value is the value argument value.
			Value []interface{}
		}
		// JSONArrIndexWithArgs holds details about calls to the JSONArrIndexWithArgs method.
		JSONArrIndexWithArgs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Path is the path argument value.
			Path string
			// Options is the options argument value.
			Options *redis.JSONArrIndexArgs
			// Value is the value argument value.
			Value []interface{}
		}
		// JSONArrInsert holds details about calls to the JSONArrInsert method.
		JSONArrInsert []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Path is the path argument value.
			Path string
			// Index is the index argument value.
			Index int64
			// Values is the values argument value.
			Values []interface{}
		}
		// JSONArrLen holds details about calls to the JSONArrLen method.
		JSONArrLen []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Path is the path argument value.
			Path string
		}
		// JSONArrPop holds details about calls to the JSONArrPop method.
		JSONArrPop []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Path is the path argument value.
			Path string
			// Index is the index argument value.
			Index int
		}
		// JSONArrTrim holds details about calls to the JSONArrTrim method.
		JSONArrTrim []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Path is the path argument value.
			Path string
		}
		// JSONArrTrimWithArgs holds details about calls to the JSONArrTrimWithArgs method.
		JSONArrTrimWithArgs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Path is the path argument value.
			Path string
			// Options is the options argument value.
			Options *redis.JSONArrTrimArgs
		}
		// JSONClear holds details about calls to the JSONClear method.
		JSONClear []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Path is the path argument value.
			Path string
		}
		// JSONDebugMemory holds details about calls to the JSONDebugMemory method.
		JSONDebugMemory []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Path is the path argument value.
			Path string
		}
		// JSONDel holds details about calls to the JSONDel method.
		JSONDel []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Path is the path argument value.
			Path string
		}
		// JSONForget holds details about calls to the JSONForget method.
		JSONForget []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Path is the path argument value.
			Path string
		}
		// JSONGet holds details about calls to the JSONGet method.
		JSONGet []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Paths is the paths argument value.
			Paths []string
		}
		// JSONGetWithArgs holds details about calls to the JSONGetWithArgs method.
		JSONGetWithArgs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Options is the options argument value.
			Options *redis.JSONGetArgs
			// Paths is the paths argument value.
			Paths []string
		}
		// JSONMGet holds details about calls to the JSONMGet method.
		JSONMGet []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Path is the path argument value.
			Path string
			// Keys is the keys argument value.
			Keys []string
		}
		// JSONMSet holds details about calls to the JSONMSet method.
		JSONMSet []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Params is the params argument value.
			Params []interface{}
		}
		// JSONMSetArgs holds details about calls to the JSONMSetArgs method.
		JSONMSetArgs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Docs is the docs argument value.
			Docs []redis.JSONSetArgs
		}
		// JSONMerge holds details about calls to the JSONMerge method.
		JSONMerge []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Path is the path argument value.
			Path string
			// Value is the value argument value.
			Value string
		}
		// JSONNumIncrBy holds details about calls to the JSONNumIncrBy method.
		JSONNumIncrBy []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Path is the path argument value.
			Path string
			// Value is the value argument value.
			Value float64
		}
		// JSONObjKeys holds details about calls to the JSONObjKeys method.
		JSONObjKeys []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Path is the path argument value.
			Path string
		}
		// JSONObjLen holds details about calls to the JSONObjLen method.
		JSONObjLen []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Path is the path argument value.
			Path string
		}
		// JSONSet holds details about calls to the JSONSet method.
		JSONSet []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Path is the path argument value.
			Path string
			// Value is the value argument value.
			Value interface{}
		}
		// JSONSetMode holds details about calls to the JSONSetMode method.
		JSONSetMode []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Path is the path argument value.
			Path string
			// Value is the value argument value.
			Value interface{}
			// Mode is the mode argument value.
			Mode string
		}
		// JSONStrAppend holds details about calls to the JSONStrAppend method.
		JSONStrAppend []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Path is the path argument value.
			Path string
			// Value is the value argument value.
			Value string
		}
		// JSONStrLen holds details about calls to the JSONStrLen method.
		JSONStrLen []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Path is the path argument value.
			Path string
		}
		// JSONToggle holds details about calls to the JSONToggle method.
		JSONToggle []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Path is the path argument value.
			Path string
		}
		// JSONType holds details about calls to the JSONType method.
		JSONType []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Path is the path argument value.
			Path string
		}
		// Keys holds details about calls to the Keys method.
		Keys []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Pattern is the pattern argument value.
			Pattern string
		}
		// LCS holds details about calls to the LCS method.
		LCS []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Q is the q argument value.
			Q *redis.LCSQuery
		}
		// LIndex holds details about calls to the LIndex method.
		LIndex []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Index is the index argument value.
			Index int64
		}
		// LInsert holds details about calls to the LInsert method.
		LInsert []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Op is the op argument value.
			Op string
			// Pivot is the pivot argument value.
			Pivot interface{}
			// Value is the value argument value.
			Value interface{}
		}
		// LInsertAfter holds details about calls to the LInsertAfter method.
		LInsertAfter []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Pivot is the pivot argument value.
			Pivot interface{}
			// Value is the value argument value.
			Value interface{}
		}
		// LInsertBefore holds details about calls to the LInsertBefore method.
		LInsertBefore []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Pivot is the pivot argument value.
			Pivot interface{}
			// Value is the value argument value.
			Value interface{}
		}
		// LLen holds details about calls to the LLen method.
		LLen []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// LMPop holds details about calls to the LMPop method.
		LMPop []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Direction is the direction argument value.
			Direction string
			// Count is the count argument value.
			Count int64
			// Keys is the keys argument value.
			Keys []string
		}
		// LMove holds details about calls to the LMove method.
		LMove []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Source is the source argument value.
			Source string
			// Destination is the destination argument value.
			Destination string
			// Srcpos is the srcpos argument value.
			Srcpos string
			// Destpos is the destpos argument value.
			Destpos string
		}
		// LPop holds details about calls to the LPop method.
		LPop []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// LPopCount holds details about calls to the LPopCount method.
		LPopCount []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Count is the count argument value.
			Count int
		}
		// LPos holds details about calls to the LPos method.
		LPos []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Value is the value argument value.
			Value string
			// Args is the args argument value.
			Args redis.LPosArgs
		}
		// LPosCount holds details about calls to the LPosCount method.
		LPosCount []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Value is the value argument value.
			Value string
			// Count is the count argument value.
			Count int64
			// Args is the args argument value.
			Args redis.LPosArgs
		}
		// LPush holds details about calls to the LPush method.
		LPush []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Values is the values argument value.
			Values []interface{}
		}
		// LPushX holds details about calls to the LPushX method.
		LPushX []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Values is the values argument value.
			Values []interface{}
		}
		// LRange holds details about calls to the LRange method.
		LRange []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Start is the start argument value.
			Start int64
			// Stop is the stop argument value.
			Stop int64
		}
		// LRem holds details about calls to the LRem method.
		LRem []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Count is the count argument value.
			Count int64
			// Value is the value argument value.
			Value interface{}
		}
		// LSet holds details about calls to the LSet method.
		LSet []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Index is the index argument value.
			Index int64
			// Value is the value argument value.
			Value interface{}
		}
		// LTrim holds details about calls to the LTrim method.
		LTrim []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Start is the start argument value.
			Start int64
			// Stop is the stop argument value.
			Stop int64
		}
		// LastSave holds details about calls to the LastSave method.
		LastSave []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// Latency holds details about calls to the Latency method.
		Latency []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// LatencyReset holds details about calls to the LatencyReset method.
		LatencyReset []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Events is the events argument value.
			Events []interface{}
		}
		// MGet holds details about calls to the MGet method.
		MGet []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Keys is the keys argument value.
			Keys []string
		}
		// MSet holds details about calls to the MSet method.
		MSet []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Values is the values argument value.
			Values []interface{}
		}
		// MSetEX holds details about calls to the MSetEX method.
		MSetEX []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Args is the args argument value.
			Args redis.MSetEXArgs
			// Values is the values argument value.
			Values []interface{}
		}
		// MSetNX holds details about calls to the MSetNX method.
		MSetNX []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Values is the values argument value.
			Values []interface{}
		}
		// MemoryUsage holds details about calls to the MemoryUsage method.
		MemoryUsage []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Samples is the samples argument value.
			Samples []int
		}
		// Migrate holds details about calls to the Migrate method.
		Migrate []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Host is the host argument value.
			Host string
			// Port is the port argument value.
			Port string
			// Key is the key argument value.
			Key string
			// Db is the db argument value.
			Db int
			// Timeout is the timeout argument value.
			Timeout time.Duration
		}
		// ModuleLoadex holds details about calls to the ModuleLoadex method.
		ModuleLoadex []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Conf is the conf argument value.
			Conf *redis.ModuleLoadexConfig
		}
		// Move holds details about calls to the Move method.
		Move []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Db is the db argument value.
			Db int
		}
		// ObjectEncoding holds details about calls to the ObjectEncoding method.
		ObjectEncoding []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// ObjectFreq holds details about calls to the ObjectFreq method.
		ObjectFreq []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// ObjectIdleTime holds details about calls to the ObjectIdleTime method.
		ObjectIdleTime []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// ObjectRefCount holds details about calls to the ObjectRefCount method.
		ObjectRefCount []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// PExpire holds details about calls to the PExpire method.
		PExpire []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Expiration is the expiration argument value.
			Expiration time.Duration
		}
		// PExpireAt holds details about calls to the PExpireAt method.
		PExpireAt []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Tm is the tm argument value.
			Tm time.Time
		}
		// PExpireTime holds details about calls to the PExpireTime method.
		PExpireTime []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// PFAdd holds details about calls to the PFAdd method.
		PFAdd []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Els is the els argument value.
			Els []interface{}
		}
		// PFCount holds details about calls to the PFCount method.
		PFCount []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Keys is the keys argument value.
			Keys []string
		}
		// PFMerge holds details about calls to the PFMerge method.
		PFMerge []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Dest is the dest argument value.
			Dest string
			// Keys is the keys argument value.
			Keys []string
		}
		// PTTL holds details about calls to the PTTL method.
		PTTL []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// Persist holds details about calls to the Persist method.
		Persist []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// Ping holds details about calls to the Ping method.
		Ping []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// Pipeline holds details about calls to the Pipeline method.
		Pipeline []struct {
		}
		// Pipelined holds details about calls to the Pipelined method.
		Pipelined []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Fn is the fn argument value.
			Fn func(redis.Pipeliner) error
		}
		// PubSubChannels holds details about calls to the PubSubChannels method.
		PubSubChannels []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Pattern is the pattern argument value.
			Pattern string
		}
		// PubSubNumPat holds details about calls to the PubSubNumPat method.
		PubSubNumPat []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// PubSubNumSub holds details about calls to the PubSubNumSub method.
		PubSubNumSub []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Channels is the channels argument value.
			Channels []string
		}
		// PubSubShardChannels holds details about calls to the PubSubShardChannels method.
		PubSubShardChannels []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Pattern is the pattern argument value.
			Pattern string
		}
		// PubSubShardNumSub holds details about calls to the PubSubShardNumSub method.
		PubSubShardNumSub []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Channels is the channels argument value.
			Channels []string
		}
		// Publish holds details about calls to the Publish method.
		Publish []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Channel is the channel argument value.
			Channel string
			// Message is the message argument value.
			Message interface{}
		}
		// Quit holds details about calls to the Quit method.
		Quit []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// RPop holds details about calls to the RPop method.
		RPop []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// RPopCount holds details about calls to the RPopCount method.
		RPopCount []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Count is the count argument value.
			Count int
		}
		// RPopLPush holds details about calls to the RPopLPush method.
		RPopLPush []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Source is the source argument value.
			Source string
			// Destination is the destination argument value.
			Destination string
		}
		// RPush holds details about calls to the RPush method.
		RPush []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Values is the values argument value.
			Values []interface{}
		}
		// RPushX holds details about calls to the RPushX method.
		RPushX []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Values is the values argument value.
			Values []interface{}
		}
		// RandomKey holds details about calls to the RandomKey method.
		RandomKey []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ReadOnly holds details about calls to the ReadOnly method.
		ReadOnly []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ReadWrite holds details about calls to the ReadWrite method.
		ReadWrite []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// Rename holds details about calls to the Rename method.
		Rename []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Newkey is the newkey argument value.
			Newkey string
		}
		// RenameNX holds details about calls to the RenameNX method.
		RenameNX []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Newkey is the newkey argument value.
			Newkey string
		}
		// Restore holds details about calls to the Restore method.
		Restore []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// TTL is the ttl argument value.
			TTL time.Duration
			// Value is the value argument value.
			Value string
		}
		// RestoreReplace holds details about calls to the RestoreReplace method.
		RestoreReplace []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// TTL is the ttl argument value.
			TTL time.Duration
			// Value is the value argument value.
			Value string
		}
		// SAdd holds details about calls to the SAdd method.
		SAdd []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Members is the members argument value.
			Members []interface{}
		}
		// SCard holds details about calls to the SCard method.
		SCard []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// SDiff holds details about calls to the SDiff method.
		SDiff []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Keys is the keys argument value.
			Keys []string
		}
		// SDiffStore holds details about calls to the SDiffStore method.
		SDiffStore []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Destination is the destination argument value.
			Destination string
			// Keys is the keys argument value.
			Keys []string
		}
		// SInter holds details about calls to the SInter method.
		SInter []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Keys is the keys argument value.
			Keys []string
		}
		// SInterCard holds details about calls to the SInterCard method.
		SInterCard []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Limit is the limit argument value.
			Limit int64
			// Keys is the keys argument value.
			Keys []string
		}
		// SInterStore holds details about calls to the SInterStore method.
		SInterStore []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Destination is the destination argument value.
			Destination string
			// Keys is the keys argument value.
			Keys []string
		}
		// SIsMember holds details about calls to the SIsMember method.
		SIsMember []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Member is the member argument value.
			Member interface{}
		}
		// SMIsMember holds details about calls to the SMIsMember method.
		SMIsMember []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Members is the members argument value.
			Members []interface{}
		}
		// SMembers holds details about calls to the SMembers method.
		SMembers []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// SMembersMap holds details about calls to the SMembersMap method.
		SMembersMap []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// SMove holds details about calls to the SMove method.
		SMove []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Source is the source argument value.
			Source string
			// Destination is the destination argument value.
			Destination string
			// Member is the member argument value.
			Member interface{}
		}
		// SPop holds details about calls to the SPop method.
		SPop []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// SPopN holds details about calls to the SPopN method.
		SPopN []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Count is the count argument value.
			Count int64
		}
		// SPublish holds details about calls to the SPublish method.
		SPublish []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Channel is the channel argument value.
			Channel string
			// Message is the message argument value.
			Message interface{}
		}
		// SRandMember holds details about calls to the SRandMember method.
		SRandMember []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// SRandMemberN holds details about calls to the SRandMemberN method.
		SRandMemberN []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Count is the count argument value.
			Count int64
		}
		// SRem holds details about calls to the SRem method.
		SRem []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Members is the members argument value.
			Members []interface{}
		}
		// SScan holds details about calls to the SScan method.
		SScan []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Cursor is the cursor argument value.
			Cursor uint64
			// Match is the match argument value.
			Match string
			// Count is the count argument value.
			Count int64
		}
		// SUnion holds details about calls to the SUnion method.
		SUnion []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Keys is the keys argument value.
			Keys []string
		}
		// SUnionStore holds details about calls to the SUnionStore method.
		SUnionStore []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Destination is the destination argument value.
			Destination string
			// Keys is the keys argument value.
			Keys []string
		}
		// Save holds details about calls to the Save method.
		Save []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// Scan holds details about calls to the Scan method.
		Scan []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Cursor is the cursor argument value.
			Cursor uint64
			// Match is the match argument value.
			Match string
			// Count is the count argument value.
			Count int64
		}
		// ScanType holds details about calls to the ScanType method.
		ScanType []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Cursor is the cursor argument value.
			Cursor uint64
			// Match is the match argument value.
			Match string
			// Count is the count argument value.
			Count int64
			// KeyType is the keyType argument value.
			KeyType string
		}
		// ScriptExists holds details about calls to the ScriptExists method.
		ScriptExists []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Hashes is the hashes argument value.
			Hashes []string
		}
		// ScriptFlush holds details about calls to the ScriptFlush method.
		ScriptFlush []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ScriptKill holds details about calls to the ScriptKill method.
		ScriptKill []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ScriptLoad holds details about calls to the ScriptLoad method.
		ScriptLoad []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Script is the script argument value.
			Script string
		}
		// Set holds details about calls to the Set method.
		Set []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Value is the value argument value.
			Value interface{}
			// Expiration is the expiration argument value.
			Expiration time.Duration
		}
		// SetArgs holds details about calls to the SetArgs method.
		SetArgs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Value is the value argument value.
			Value interface{}
			// A is the a argument value.
			A redis.SetArgs
		}
		// SetBit holds details about calls to the SetBit method.
		SetBit []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Offset is the offset argument value.
			Offset int64
			// Value is the value argument value.
			Value int
		}
		// SetEx holds details about calls to the SetEx method.
		SetEx []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Value is the value argument value.
			Value interface{}
			// Expiration is the expiration argument value.
			Expiration time.Duration
		}
		// SetIFDEQ holds details about calls to the SetIFDEQ method.
		SetIFDEQ []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Value is the value argument value.
			Value interface{}
			// MatchDigest is the matchDigest argument value.
			MatchDigest uint64
			// Expiration is the expiration argument value.
			Expiration time.Duration
		}
		// SetIFDEQGet holds details about calls to the SetIFDEQGet method.
		SetIFDEQGet []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Value is the value argument value.
			Value interface{}
			// MatchDigest is the matchDigest argument value.
			MatchDigest uint64
			// Expiration is the expiration argument value.
			Expiration time.Duration
		}
		// SetIFDNE holds details about calls to the SetIFDNE method.
		SetIFDNE []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Value is the value argument value.
			Value interface{}
			// MatchDigest is the matchDigest argument value.
			MatchDigest uint64
			// Expiration is the expiration argument value.
			Expiration time.Duration
		}
		// SetIFDNEGet holds details about calls to the SetIFDNEGet method.
		SetIFDNEGet []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Value is the value argument value.
			Value interface{}
			// MatchDigest is the matchDigest argument value.
			MatchDigest uint64
			// Expiration is the expiration argument value.
			Expiration time.Duration
		}
		// SetIFEQ holds details about calls to the SetIFEQ method.
		SetIFEQ []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Value is the value argument value.
			Value interface{}
			// MatchValue is the matchValue argument value.
			MatchValue interface{}
			// Expiration is the expiration argument value.
			Expiration time.Duration
		}
		// SetIFEQGet holds details about calls to the SetIFEQGet method.
		SetIFEQGet []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Value is the value argument value.
			Value interface{}
			// MatchValue is the matchValue argument value.
			MatchValue interface{}
			// Expiration is the expiration argument value.
			Expiration time.Duration
		}
		// SetIFNE holds details about calls to the SetIFNE method.
		SetIFNE []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Value is the value argument value.
			Value interface{}
			// MatchValue is the matchValue argument value.
			MatchValue interface{}
			// Expiration is the expiration argument value.
			Expiration time.Duration
		}
		// SetIFNEGet holds details about calls to the SetIFNEGet method.
		SetIFNEGet []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Value is the value argument value.
			Value interface{}
			// MatchValue is the matchValue argument value.
			MatchValue interface{}
			// Expiration is the expiration argument value.
			Expiration time.Duration
		}
		// SetNX holds details about calls to the SetNX method.
		SetNX []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Value is the value argument value.
			Value interface{}
			// Expiration is the expiration argument value.
			Expiration time.Duration
		}
		// SetRange holds details about calls to the SetRange method.
		SetRange []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Offset is the offset argument value.
			Offset int64
			// Value is the value argument value.
			Value string
		}
		// SetXX holds details about calls to the SetXX method.
		SetXX []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Value is the value argument value.
			Value interface{}
			// Expiration is the expiration argument value.
			Expiration time.Duration
		}
		// Shutdown holds details about calls to the Shutdown method.
		Shutdown []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ShutdownNoSave holds details about calls to the ShutdownNoSave method.
		ShutdownNoSave []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ShutdownSave holds details about calls to the ShutdownSave method.
		ShutdownSave []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// SlaveOf holds details about calls to the SlaveOf method.
		SlaveOf []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Host is the host argument value.
			Host string
			// Port is the port argument value.
			Port string
		}
		// SlowLogGet holds details about calls to the SlowLogGet method.
		SlowLogGet []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Num is the num argument value.
			Num int64
		}
		// SlowLogLen holds details about calls to the SlowLogLen method.
		SlowLogLen []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// SlowLogReset holds details about calls to the SlowLogReset method.
		SlowLogReset []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// Sort holds details about calls to the Sort method.
		Sort []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Sort is the sort argument value.
			Sort *redis.Sort
		}
		// SortInterfaces holds details about calls to the SortInterfaces method.
		SortInterfaces []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Sort is the sort argument value.
			Sort *redis.Sort
		}
		// SortRO holds details about calls to the SortRO method.
		SortRO []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Sort is the sort argument value.
			Sort *redis.Sort
		}
		// SortStore holds details about calls to the SortStore method.
		SortStore []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Store is the store argument value.
			Store string
			// Sort is the sort argument value.
			Sort *redis.Sort
		}
		// StrLen holds details about calls to the StrLen method.
		StrLen []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// Subscribe holds details about calls to the Subscribe method.
		Subscribe []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Channels is the channels argument value.
			Channels []string
		}
		// TDigestAdd holds details about calls to the TDigestAdd method.
		TDigestAdd []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Elements is the elements argument value.
			Elements []float64
		}
		// TDigestByRank holds details about calls to the TDigestByRank method.
		TDigestByRank []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Rank is the rank argument value.
			Rank []uint64
		}
		// TDigestByRevRank holds details about calls to the TDigestByRevRank method.
		TDigestByRevRank []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Rank is the rank argument value.
			Rank []uint64
		}
		// TDigestCDF holds details about calls to the TDigestCDF method.
		TDigestCDF []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Elements is the elements argument value.
			Elements []float64
		}
		// TDigestCreate holds details about calls to the TDigestCreate method.
		TDigestCreate []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// TDigestCreateWithCompression holds details about calls to the TDigestCreateWithCompression method.
		TDigestCreateWithCompression []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Compression is the compression argument value.
			Compression int64
		}
		// TDigestInfo holds details about calls to the TDigestInfo method.
		TDigestInfo []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// TDigestMax holds details about calls to the TDigestMax method.
		TDigestMax []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// TDigestMerge holds details about calls to the TDigestMerge method.
		TDigestMerge []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// DestKey is the destKey argument value.
			DestKey string
			// Options is the options argument value.
			Options *redis.TDigestMergeOptions
			// SourceKeys is the sourceKeys argument value.
			SourceKeys []string
		}
		// TDigestMin holds details about calls to the TDigestMin method.
		TDigestMin []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// TDigestQuantile holds details about calls to the TDigestQuantile method.
		TDigestQuantile []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Elements is the elements argument value.
			Elements []float64
		}
		// TDigestRank holds details about calls to the TDigestRank method.
		TDigestRank []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Values is the values argument value.
			Values []float64
		}
		// TDigestReset holds details about calls to the TDigestReset method.
		TDigestReset []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// TDigestRevRank holds details about calls to the TDigestRevRank method.
		TDigestRevRank []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Values is the values argument value.
			Values []float64
		}
		// TDigestTrimmedMean holds details about calls to the TDigestTrimmedMean method.
		TDigestTrimmedMean []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// LowCutQuantile is the lowCutQuantile argument value.
			LowCutQuantile float64
			// HighCutQuantile is the highCutQuantile argument value.
			HighCutQuantile float64
		}
		// TSAdd holds details about calls to the TSAdd method.
		TSAdd []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Timestamp is the timestamp argument value.
			Timestamp interface{}
			// Value is the value argument value.
			Value float64
		}
		// TSAddWithArgs holds details about calls to the TSAddWithArgs method.
		TSAddWithArgs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Timestamp is the timestamp argument value.
			Timestamp interface{}
			// Value is the value argument value.
			Value float64
			// Options is the options argument value.
			Options *redis.TSOptions
		}
		// TSAlter holds details about calls to the TSAlter method.
		TSAlter []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Options is the options argument value.
			Options *redis.TSAlterOptions
		}
		// TSCreate holds details about calls to the TSCreate method.
		TSCreate []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// TSCreateRule holds details about calls to the TSCreateRule method.
		TSCreateRule []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// SourceKey is the sourceKey argument value.
			SourceKey string
			// DestKey is the destKey argument value.
			DestKey string
			// Aggregator is the aggregator argument value.
			Aggregator redis.Aggregator
			// BucketDuration is the bucketDuration argument value.
			BucketDuration int
		}
		// TSCreateRuleWithArgs holds details about calls to the TSCreateRuleWithArgs method.
		TSCreateRuleWithArgs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// SourceKey is the sourceKey argument value.
			SourceKey string
			// DestKey is the destKey argument value.
			DestKey string
			// Aggregator is the aggregator argument value.
			Aggregator redis.Aggregator
			// BucketDuration is the bucketDuration argument value.
			BucketDuration int
			// Options is the options argument value.
			Options *redis.TSCreateRuleOptions
		}
		// TSCreateWithArgs holds details about calls to the TSCreateWithArgs method.
		TSCreateWithArgs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Options is the options argument value.
			Options *redis.TSOptions
		}
		// TSDecrBy holds details about calls to the TSDecrBy method.
		TSDecrBy []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the Key argument value.
			Key string
			// Timestamp is the timestamp argument value.
			Timestamp float64
		}
		// TSDecrByWithArgs holds details about calls to the TSDecrByWithArgs method.
		TSDecrByWithArgs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Timestamp is the timestamp argument value.
			Timestamp float64
			// Options is the options argument value.
			Options *redis.TSIncrDecrOptions
		}
		// TSDel holds details about calls to the TSDel method.
		TSDel []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the Key argument value.
			Key string
			// FromTimestamp is the fromTimestamp argument value.
			FromTimestamp int
			// ToTimestamp is the toTimestamp argument value.
			ToTimestamp int
		}
		// TSDeleteRule holds details about calls to the TSDeleteRule method.
		TSDeleteRule []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// SourceKey is the sourceKey argument value.
			SourceKey string
			// DestKey is the destKey argument value.
			DestKey string
		}
		// TSGet holds details about calls to the TSGet method.
		TSGet []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// TSGetWithArgs holds details about calls to the TSGetWithArgs method.
		TSGetWithArgs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Options is the options argument value.
			Options *redis.TSGetOptions
		}
		// TSIncrBy holds details about calls to the TSIncrBy method.
		TSIncrBy []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the Key argument value.
			Key string
			// Timestamp is the timestamp argument value.
			Timestamp float64
		}
		// TSIncrByWithArgs holds details about calls to the TSIncrByWithArgs method.
		TSIncrByWithArgs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Timestamp is the timestamp argument value.
			Timestamp float64
			// Options is the options argument value.
			Options *redis.TSIncrDecrOptions
		}
		// TSInfo holds details about calls to the TSInfo method.
		TSInfo []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// TSInfoWithArgs holds details about calls to the TSInfoWithArgs method.
		TSInfoWithArgs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Options is the options argument value.
			Options *redis.TSInfoOptions
		}
		// TSMAdd holds details about calls to the TSMAdd method.
		TSMAdd []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// KtvSlices is the ktvSlices argument value.
			KtvSlices [][]interface{}
		}
		// TSMGet holds details about calls to the TSMGet method.
		TSMGet []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Filters is the filters argument value.
			Filters []string
		}
		// TSMGetWithArgs holds details about calls to the TSMGetWithArgs method.
		TSMGetWithArgs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Filters is the filters argument value.
			Filters []string
			// Options is the options argument value.
			Options *redis.TSMGetOptions
		}
		// TSMRange holds details about calls to the TSMRange method.
		TSMRange []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// FromTimestamp is the fromTimestamp argument value.
			FromTimestamp int
			// ToTimestamp is the toTimestamp argument value.
			ToTimestamp int
			// FilterExpr is the filterExpr argument value.
			FilterExpr []string
		}
		// TSMRangeWithArgs holds details about calls to the TSMRangeWithArgs method.
		TSMRangeWithArgs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// FromTimestamp is the fromTimestamp argument value.
			FromTimestamp int
			// ToTimestamp is the toTimestamp argument value.
			ToTimestamp int
			// FilterExpr is the filterExpr argument value.
			FilterExpr []string
			// Options is the options argument value.
			Options *redis.TSMRangeOptions
		}
		// TSMRevRange holds details about calls to the TSMRevRange method.
		TSMRevRange []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// FromTimestamp is the fromTimestamp argument value.
			FromTimestamp int
			// ToTimestamp is the toTimestamp argument value.
			ToTimestamp int
			// FilterExpr is the filterExpr argument value.
			FilterExpr []string
		}
		// TSMRevRangeWithArgs holds details about calls to the TSMRevRangeWithArgs method.
		TSMRevRangeWithArgs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// FromTimestamp is the fromTimestamp argument value.
			FromTimestamp int
			// ToTimestamp is the toTimestamp argument value.
			ToTimestamp int
			// FilterExpr is the filterExpr argument value.
			FilterExpr []string
			// Options is the options argument value.
			Options *redis.TSMRevRangeOptions
		}
		// TSQueryIndex holds details about calls to the TSQueryIndex method.
		TSQueryIndex []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// FilterExpr is the filterExpr argument value.
			FilterExpr []string
		}
		// TSRange holds details about calls to the TSRange method.
		TSRange []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// FromTimestamp is the fromTimestamp argument value.
			FromTimestamp int
			// ToTimestamp is the toTimestamp argument value.
			ToTimestamp int
		}
		// TSRangeWithArgs holds details about calls to the TSRangeWithArgs method.
		TSRangeWithArgs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// FromTimestamp is the fromTimestamp argument value.
			FromTimestamp int
			// ToTimestamp is the toTimestamp argument value.
			ToTimestamp int
			// Options is the options argument value.
			Options *redis.TSRangeOptions
		}
		// TSRevRange holds details about calls to the TSRevRange method.
		TSRevRange []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// FromTimestamp is the fromTimestamp argument value.
			FromTimestamp int
			// ToTimestamp is the toTimestamp argument value.
			ToTimestamp int
		}
		// TSRevRangeWithArgs holds details about calls to the TSRevRangeWithArgs method.
		TSRevRangeWithArgs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// FromTimestamp is the fromTimestamp argument value.
			FromTimestamp int
			// ToTimestamp is the toTimestamp argument value.
			ToTimestamp int
			// Options is the options argument value.
			Options *redis.TSRevRangeOptions
		}
		// TTL holds details about calls to the TTL method.
		TTL []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// Time holds details about calls to the Time method.
		Time []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// TopKAdd holds details about calls to the TopKAdd method.
		TopKAdd []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Elements is the elements argument value.
			Elements []interface{}
		}
		// TopKCount holds details about calls to the TopKCount method.
		TopKCount []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Elements is the elements argument value.
			Elements []interface{}
		}
		// TopKIncrBy holds details about calls to the TopKIncrBy method.
		TopKIncrBy []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Elements is the elements argument value.
			Elements []interface{}
		}
		// TopKInfo holds details about calls to the TopKInfo method.
		TopKInfo []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// TopKList holds details about calls to the TopKList method.
		TopKList []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// TopKListWithCount holds details about calls to the TopKListWithCount method.
		TopKListWithCount []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// TopKQuery holds details about calls to the TopKQuery method.
		TopKQuery []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Elements is the elements argument value.
			Elements []interface{}
		}
		// TopKReserve holds details about calls to the TopKReserve method.
		TopKReserve []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// K is the k argument value.
			K int64
		}
		// TopKReserveWithOptions holds details about calls to the TopKReserveWithOptions method.
		TopKReserveWithOptions []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// K is the k argument value.
			K int64
			// Width is the width argument value.
			Width int64
			// Depth is the depth argument value.
			Depth int64
			// Decay is the decay argument value.
			Decay float64
		}
		// Touch holds details about calls to the Touch method.
		Touch []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Keys is the keys argument value.
			Keys []string
		}
		// TxPipeline holds details about calls to the TxPipeline method.
		TxPipeline []struct {
		}
		// TxPipelined holds details about calls to the TxPipelined method.
		TxPipelined []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Fn is the fn argument value.
			Fn func(redis.Pipeliner) error
		}
		// Type holds details about calls to the Type method.
		Type []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// Unlink holds details about calls to the Unlink method.
		Unlink []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Keys is the keys argument value.
			Keys []string
		}
		// VAdd holds details about calls to the VAdd method.
		VAdd []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Element is the element argument value.
			Element string
			// Val is the val argument value.
			Val redis.Vector
		}
		// VAddWithArgs holds details about calls to the VAddWithArgs method.
		VAddWithArgs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Element is the element argument value.
			Element string
			// Val is the val argument value.
			Val redis.Vector
			// AddArgs is the addArgs argument value.
			AddArgs *redis.VAddArgs
		}
		// VCard holds details about calls to the VCard method.
		VCard []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// VClearAttributes holds details about calls to the VClearAttributes method.
		VClearAttributes []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Element is the element argument value.
			Element string
		}
		// VDim holds details about calls to the VDim method.
		VDim []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// VEmb holds details about calls to the VEmb method.
		VEmb []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Element is the element argument value.
			Element string
			// Raw is the raw argument value.
			Raw bool
		}
		// VGetAttr holds details about calls to the VGetAttr method.
		VGetAttr []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Element is the element argument value.
			Element string
		}
		// VInfo holds details about calls to the VInfo method.
		VInfo []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// VLinks holds details about calls to the VLinks method.
		VLinks []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Element is the element argument value.
			Element string
		}
		// VLinksWithScores holds details about calls to the VLinksWithScores method.
		VLinksWithScores []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Element is the element argument value.
			Element string
		}
		// VRandMember holds details about calls to the VRandMember method.
		VRandMember []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// VRandMemberCount holds details about calls to the VRandMemberCount method.
		VRandMemberCount []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Count is the count argument value.
			Count int
		}
		// VRange holds details about calls to the VRange method.
		VRange []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Start is the start argument value.
			Start string
			// End is the end argument value.
			End string
			// Count is the count argument value.
			Count int64
		}
		// VRem holds details about calls to the VRem method.
		VRem []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Element is the element argument value.
			Element string
		}
		// VSetAttr holds details about calls to the VSetAttr method.
		VSetAttr []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Element is the element argument value.
			Element string
			// Attr is the attr argument value.
			Attr interface{}
		}
		// VSim holds details about calls to the VSim method.
		VSim []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Val is the val argument value.
			Val redis.Vector
		}
		// VSimWithArgs holds details about calls to the VSimWithArgs method.
		VSimWithArgs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Val is the val argument value.
			Val redis.Vector
			// Args is the args argument value.
			Args *redis.VSimArgs
		}
		// VSimWithArgsWithScores holds details about calls to the VSimWithArgsWithScores method.
		VSimWithArgsWithScores []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Val is the val argument value.
			Val redis.Vector
			// Args is the args argument value.
			Args *redis.VSimArgs
		}
		// VSimWithScores holds details about calls to the VSimWithScores method.
		VSimWithScores []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Val is the val argument value.
			Val redis.Vector
		}
		// XAck holds details about calls to the XAck method.
		XAck []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Stream is the stream argument value.
			Stream string
			// Group is the group argument value.
			Group string
			// Ids is the ids argument value.
			Ids []string
		}
		// XAckDel holds details about calls to the XAckDel method.
		XAckDel []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Stream is the stream argument value.
			Stream string
			// Group is the group argument value.
			Group string
			// Mode is the mode argument value.
			Mode string
			// Ids is the ids argument value.
			Ids []string
		}
		// XAdd holds details about calls to the XAdd method.
		XAdd []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// A is the a argument value.
			A *redis.XAddArgs
		}
		// XAutoClaim holds details about calls to the XAutoClaim method.
		XAutoClaim []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// A is the a argument value.
			A *redis.XAutoClaimArgs
		}
		// XAutoClaimJustID holds details about calls to the XAutoClaimJustID method.
		XAutoClaimJustID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// A is the a argument value.
			A *redis.XAutoClaimArgs
		}
		// XCfgSet holds details about calls to the XCfgSet method.
		XCfgSet []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// A is the a argument value.
			A *redis.XCfgSetArgs
		}
		// XClaim holds details about calls to the XClaim method.
		XClaim []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// A is the a argument value.
			A *redis.XClaimArgs
		}
		// XClaimJustID holds details about calls to the XClaimJustID method.
		XClaimJustID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// A is the a argument value.
			A *redis.XClaimArgs
		}
		// XDel holds details about calls to the XDel method.
		XDel []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Stream is the stream argument value.
			Stream string
			// Ids is the ids argument value.
			Ids []string
		}
		// XDelEx holds details about calls to the XDelEx method.
		XDelEx []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Stream is the stream argument value.
			Stream string
			// Mode is the mode argument value.
			Mode string
			// Ids is the ids argument value.
			Ids []string
		}
		// XGroupCreate holds details about calls to the XGroupCreate method.
		XGroupCreate []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Stream is the stream argument value.
			Stream string
			// Group is the group argument value.
			Group string
			// Start is the start argument value.
			Start string
		}
		// XGroupCreateConsumer holds details about calls to the XGroupCreateConsumer method.
		XGroupCreateConsumer []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Stream is the stream argument value.
			Stream string
			// Group is the group argument value.
			Group string
			// Consumer is the consumer argument value.
			Consumer string
		}
		// XGroupCreateMkStream holds details about calls to the XGroupCreateMkStream method.
		XGroupCreateMkStream []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Stream is the stream argument value.
			Stream string
			// Group is the group argument value.
			Group string
			// Start is the start argument value.
			Start string
		}
		// XGroupDelConsumer holds details about calls to the XGroupDelConsumer method.
		XGroupDelConsumer []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Stream is the stream argument value.
			Stream string
			// Group is the group argument value.
			Group string
			// Consumer is the consumer argument value.
			Consumer string
		}
		// XGroupDestroy holds details about calls to the XGroupDestroy method.
		XGroupDestroy []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Stream is the stream argument value.
			Stream string
			// Group is the group argument value.
			Group string
		}
		// XGroupSetID holds details about calls to the XGroupSetID method.
		XGroupSetID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Stream is the stream argument value.
			Stream string
			// Group is the group argument value.
			Group string
			// Start is the start argument value.
			Start string
		}
		// XInfoConsumers holds details about calls to the XInfoConsumers method.
		XInfoConsumers []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Group is the group argument value.
			Group string
		}
		// XInfoGroups holds details about calls to the XInfoGroups method.
		XInfoGroups []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// XInfoStream holds details about calls to the XInfoStream method.
		XInfoStream []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// XInfoStreamFull holds details about calls to the XInfoStreamFull method.
		XInfoStreamFull []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Count is the count argument value.
			Count int
		}
		// XLen holds details about calls to the XLen method.
		XLen []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Stream is the stream argument value.
			Stream string
		}
		// XPending holds details about calls to the XPending method.
		XPending []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Stream is the stream argument value.
			Stream string
			// Group is the group argument value.
			Group string
		}
		// XPendingExt holds details about calls to the XPendingExt method.
		XPendingExt []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// A is the a argument value.
			A *redis.XPendingExtArgs
		}
		// XRange holds details about calls to the XRange method.
		XRange []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Stream is the stream argument value.
			Stream string
			// Start is the start argument value.
			Start string
			// Stop is the stop argument value.
			Stop string
		}
		// XRangeN holds details about calls to the XRangeN method.
		XRangeN []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Stream is the stream argument value.
			Stream string
			// Start is the start argument value.
			Start string
			// Stop is the stop argument value.
			Stop string
			// Count is the count argument value.
			Count int64
		}
		// XRead holds details about calls to the XRead method.
		XRead []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// A is the a argument value.
			A *redis.XReadArgs
		}
		// XReadGroup holds details about calls to the XReadGroup method.
		XReadGroup []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// A is the a argument value.
			A *redis.XReadGroupArgs
		}
		// XReadStreams holds details about calls to the XReadStreams method.
		XReadStreams []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Streams is the streams argument value.
			Streams []string
		}
		// XRevRange holds details about calls to the XRevRange method.
		XRevRange []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Stream is the stream argument value.
			Stream string
			// Start is the start argument value.
			Start string
			// Stop is the stop argument value.
			Stop string
		}
		// XRevRangeN holds details about calls to the XRevRangeN method.
		XRevRangeN []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Stream is the stream argument value.
			Stream string
			// Start is the start argument value.
			Start string
			// Stop is the stop argument value.
			Stop string
			// Count is the count argument value.
			Count int64
		}
		// XTrimMaxLen holds details about calls to the XTrimMaxLen method.
		XTrimMaxLen []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// MaxLen is the maxLen argument value.
			MaxLen int64
		}
		// XTrimMaxLenApprox holds details about calls to the XTrimMaxLenApprox method.
		XTrimMaxLenApprox []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// MaxLen is the maxLen argument value.
			MaxLen int64
			// Limit is the limit argument value.
			Limit int64
		}
		// XTrimMaxLenApproxMode holds details about calls to the XTrimMaxLenApproxMode method.
		XTrimMaxLenApproxMode []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// MaxLen is the maxLen argument value.
			MaxLen int64
			// Limit is the limit argument value.
			Limit int64
			// Mode is the mode argument value.
			Mode string
		}
		// XTrimMaxLenMode holds details about calls to the XTrimMaxLenMode method.
		XTrimMaxLenMode []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// MaxLen is the maxLen argument value.
			MaxLen int64
			// Mode is the mode argument value.
			Mode string
		}
		// XTrimMinID holds details about calls to the XTrimMinID method.
		XTrimMinID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// MinID is the minID argument value.
			MinID string
		}
		// XTrimMinIDApprox holds details about calls to the XTrimMinIDApprox method.
		XTrimMinIDApprox []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// MinID is the minID argument value.
			MinID string
			// Limit is the limit argument value.
			Limit int64
		}
		// XTrimMinIDApproxMode holds details about calls to the XTrimMinIDApproxMode method.
		XTrimMinIDApproxMode []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// MinID is the minID argument value.
			MinID string
			// Limit is the limit argument value.
			Limit int64
			// Mode is the mode argument value.
			Mode string
		}
		// XTrimMinIDMode holds details about calls to the XTrimMinIDMode method.
		XTrimMinIDMode []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// MinID is the minID argument value.
			MinID string
			// Mode is the mode argument value.
			Mode string
		}
		// ZAdd holds details about calls to the ZAdd method.
		ZAdd []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Members is the members argument value.
			Members []redis.Z
		}
		// ZAddArgs holds details about calls to the ZAddArgs method.
		ZAddArgs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Args is the args argument value.
			Args redis.ZAddArgs
		}
		// ZAddArgsIncr holds details about calls to the ZAddArgsIncr method.
		ZAddArgsIncr []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Args is the args argument value.
			Args redis.ZAddArgs
		}
		// ZAddGT holds details about calls to the ZAddGT method.
		ZAddGT []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Members is the members argument value.
			Members []redis.Z
		}
		// ZAddLT holds details about calls to the ZAddLT method.
		ZAddLT []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Members is the members argument value.
			Members []redis.Z
		}
		// ZAddNX holds details about calls to the ZAddNX method.
		ZAddNX []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Members is the members argument value.
			Members []redis.Z
		}
		// ZAddXX holds details about calls to the ZAddXX method.
		ZAddXX []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Members is the members argument value.
			Members []redis.Z
		}
		// ZCard holds details about calls to the ZCard method.
		ZCard []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// ZCount holds details about calls to the ZCount method.
		ZCount []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Min is the min argument value.
			Min string
			// Max is the max argument value.
			Max string
		}
		// ZDiff holds details about calls to the ZDiff method.
		ZDiff []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Keys is the keys argument value.
			Keys []string
		}
		// ZDiffStore holds details about calls to the ZDiffStore method.
		ZDiffStore []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Destination is the destination argument value.
			Destination string
			// Keys is the keys argument value.
			Keys []string
		}
		// ZDiffWithScores holds details about calls to the ZDiffWithScores method.
		ZDiffWithScores []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Keys is the keys argument value.
			Keys []string
		}
		// ZIncrBy holds details about calls to the ZIncrBy method.
		ZIncrBy []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Increment is the increment argument value.
			Increment float64
			// Member is the member argument value.
			Member string
		}
		// ZInter holds details about calls to the ZInter method.
		ZInter []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Store is the store argument value.
			Store *redis.ZStore
		}
		// ZInterCard holds details about calls to the ZInterCard method.
		ZInterCard []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Limit is the limit argument value.
			Limit int64
			// Keys is the keys argument value.
			Keys []string
		}
		// ZInterStore holds details about calls to the ZInterStore method.
		ZInterStore []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Destination is the destination argument value.
			Destination string
			// Store is the store argument value.
			Store *redis.ZStore
		}
		// ZInterWithScores holds details about calls to the ZInterWithScores method.
		ZInterWithScores []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Store is the store argument value.
			Store *redis.ZStore
		}
		// ZLexCount holds details about calls to the ZLexCount method.
		ZLexCount []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Min is the min argument value.
			Min string
			// Max is the max argument value.
			Max string
		}
		// ZMPop holds details about calls to the ZMPop method.
		ZMPop []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Order is the order argument value.
			Order string
			// Count is the count argument value.
			Count int64
			// Keys is the keys argument value.
			Keys []string
		}
		// ZMScore holds details about calls to the ZMScore method.
		ZMScore []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Members is the members argument value.
			Members []string
		}
		// ZPopMax holds details about calls to the ZPopMax method.
		ZPopMax []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Count is the count argument value.
			Count []int64
		}
		// ZPopMin holds details about calls to the ZPopMin method.
		ZPopMin []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Count is the count argument value.
			Count []int64
		}
		// ZRandMember holds details about calls to the ZRandMember method.
		ZRandMember []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Count is the count argument value.
			Count int
		}
		// ZRandMemberWithScores holds details about calls to the ZRandMemberWithScores method.
		ZRandMemberWithScores []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Count is the count argument value.
			Count int
		}
		// ZRange holds details about calls to the ZRange method.
		ZRange []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Start is the start argument value.
			Start int64
			// Stop is the stop argument value.
			Stop int64
		}
		// ZRangeArgs holds details about calls to the ZRangeArgs method.
		ZRangeArgs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Z is the z argument value.
			Z redis.ZRangeArgs
		}
		// ZRangeArgsWithScores holds details about calls to the ZRangeArgsWithScores method.
		ZRangeArgsWithScores []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Z is the z argument value.
			Z redis.ZRangeArgs
		}
		// ZRangeByLex holds details about calls to the ZRangeByLex method.
		ZRangeByLex []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Opt is the opt argument value.
			Opt *redis.ZRangeBy
		}
		// ZRangeByScore holds details about calls to the ZRangeByScore method.
		ZRangeByScore []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Opt is the opt argument value.
			Opt *redis.ZRangeBy
		}
		// ZRangeByScoreWithScores holds details about calls to the ZRangeByScoreWithScores method.
		ZRangeByScoreWithScores []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Opt is the opt argument value.
			Opt *redis.ZRangeBy
		}
		// ZRangeStore holds details about calls to the ZRangeStore method.
		ZRangeStore []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Dst is the dst argument value.
			Dst string
			// Z is the z argument value.
			Z redis.ZRangeArgs
		}
		// ZRangeWithScores holds details about calls to the ZRangeWithScores method.
		ZRangeWithScores []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Start is the start argument value.
			Start int64
			// Stop is the stop argument value.
			Stop int64
		}
		// ZRank holds details about calls to the ZRank method.
		ZRank []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Member is the member argument value.
			Member string
		}
		// ZRankWithScore holds details about calls to the ZRankWithScore method.
		ZRankWithScore []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Member is the member argument value.
			Member string
		}
		// ZRem holds details about calls to the ZRem method.
		ZRem []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Members is the members argument value.
			Members []interface{}
		}
		// ZRemRangeByLex holds details about calls to the ZRemRangeByLex method.
		ZRemRangeByLex []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Min is the min argument value.
			Min string
			// Max is the max argument value.
			Max string
		}
		// ZRemRangeByRank holds details about calls to the ZRemRangeByRank method.
		ZRemRangeByRank []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Start is the start argument value.
			Start int64
			// Stop is the stop argument value.
			Stop int64
		}
		// ZRemRangeByScore holds details about calls to the ZRemRangeByScore method.
		ZRemRangeByScore []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Min is the min argument value.
			Min string
			// Max is the max argument value.
			Max string
		}
		// ZRevRange holds details about calls to the ZRevRange method.
		ZRevRange []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Start is the start argument value.
			Start int64
			// Stop is the stop argument value.
			Stop int64
		}
		// ZRevRangeByLex holds details about calls to the ZRevRangeByLex method.
		ZRevRangeByLex []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Opt is the opt argument value.
			Opt *redis.ZRangeBy
		}
		// ZRevRangeByScore holds details about calls to the ZRevRangeByScore method.
		ZRevRangeByScore []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Opt is the opt argument value.
			Opt *redis.ZRangeBy
		}
		// ZRevRangeByScoreWithScores holds details about calls to the ZRevRangeByScoreWithScores method.
		ZRevRangeByScoreWithScores []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Opt is the opt argument value.
			Opt *redis.ZRangeBy
		}
		// ZRevRangeWithScores holds details about calls to the ZRevRangeWithScores method.
		ZRevRangeWithScores []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Start is the start argument value.
			Start int64
			// Stop is the stop argument value.
			Stop int64
		}
		// ZRevRank holds details about calls to the ZRevRank method.
		ZRevRank []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Member is the member argument value.
			Member string
		}
		// ZRevRankWithScore holds details about calls to the ZRevRankWithScore method.
		ZRevRankWithScore []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Member is the member argument value.
			Member string
		}
		// ZScan holds details about calls to the ZScan method.
		ZScan []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Cursor is the cursor argument value.
			Cursor uint64
			// Match is the match argument value.
			Match string
			// Count is the count argument value.
			Count int64
		}
		// ZScore holds details about calls to the ZScore method.
		ZScore []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Member is the member argument value.
			Member string
		}
		// ZUnion holds details about calls to the ZUnion method.
		ZUnion []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Store is the store argument value.
			Store redis.ZStore
		}
		// ZUnionStore holds details about calls to the ZUnionStore method.
		ZUnionStore []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Dest is the dest argument value.
			Dest string
			// Store is the store argument value.
			Store *redis.ZStore
		}
		// ZUnionWithScores holds details about calls to the ZUnionWithScores method.
		ZUnionWithScores []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Store is the store argument value.
			Store redis.ZStore
		}
	}
	lockACLCat                       sync.RWMutex
	lockACLCatArgs                   sync.RWMutex
	lockACLDelUser                   sync.RWMutex
	lockACLDryRun                    sync.RWMutex
	lockACLGenPass                   sync.RWMutex
	lockACLList                      sync.RWMutex
	lockACLLog                       sync.RWMutex
	lockACLLogReset                  sync.RWMutex
	lockACLSetUser                   sync.RWMutex
	lockACLUsers                     sync.RWMutex
	lockACLWhoAmI                    sync.RWMutex
	lockAppend                       sync.RWMutex
	lockBFAdd                        sync.RWMutex
	lockBFCard                       sync.RWMutex
	lockBFExists                     sync.RWMutex
	lockBFInfo                       sync.RWMutex
	lockBFInfoArg                    sync.RWMutex
	lockBFInfoCapacity               sync.RWMutex
	lockBFInfoExpansion              sync.RWMutex
	lockBFInfoFilters                sync.RWMutex
	lockBFInfoItems                  sync.RWMutex
	lockBFInfoSize                   sync.RWMutex
	lockBFInsert                     sync.RWMutex
	lockBFLoadChunk                  sync.RWMutex
	lockBFMAdd                       sync.RWMutex
	lockBFMExists                    sync.RWMutex
	lockBFReserve                    sync.RWMutex
	lockBFReserveExpansion           sync.RWMutex
	lockBFReserveNonScaling          sync.RWMutex
	lockBFReserveWithArgs            sync.RWMutex
	lockBFScanDump                   sync.RWMutex
	lockBLMPop                       sync.RWMutex
	lockBLMove                       sync.RWMutex
	lockBLPop                        sync.RWMutex
	lockBRPop                        sync.RWMutex
	lockBRPopLPush                   sync.RWMutex
	lockBZMPop                       sync.RWMutex
	lockBZPopMax                     sync.RWMutex
	lockBZPopMin                     sync.RWMutex
	lockBgRewriteAOF                 sync.RWMutex
	lockBgSave                       sync.RWMutex
	lockBitCount                     sync.RWMutex
	lockBitField                     sync.RWMutex
	lockBitFieldRO                   sync.RWMutex
	lockBitOpAnd                     sync.RWMutex
	lockBitOpAndOr                   sync.RWMutex
	lockBitOpDiff                    sync.RWMutex
	lockBitOpDiff1                   sync.RWMutex
	lockBitOpNot                     sync.RWMutex
	lockBitOpOne                     sync.RWMutex
	lockBitOpOr                      sync.RWMutex
	lockBitOpXor                     sync.RWMutex
	lockBitPos                       sync.RWMutex
	lockBitPosSpan                   sync.RWMutex
	lockCFAdd                        sync.RWMutex
	lockCFAddNX                      sync.RWMutex
	lockCFCount                      sync.RWMutex
	lockCFDel                        sync.RWMutex
	lockCFExists                     sync.RWMutex
	lockCFInfo                       sync.RWMutex
	lockCFInsert                     sync.RWMutex
	lockCFInsertNX                   sync.RWMutex
	lockCFLoadChunk                  sync.RWMutex
	lockCFMExists                    sync.RWMutex
	lockCFReserve                    sync.RWMutex
	lockCFReserveBucketSize          sync.RWMutex
	lockCFReserveExpansion           sync.RWMutex
	lockCFReserveMaxIterations       sync.RWMutex
	lockCFReserveWithArgs            sync.RWMutex
	lockCFScanDump                   sync.RWMutex
	lockCMSIncrBy                    sync.RWMutex
	lockCMSInfo                      sync.RWMutex
	lockCMSInitByDim                 sync.RWMutex
	lockCMSInitByProb                sync.RWMutex
	lockCMSMerge                     sync.RWMutex
	lockCMSMergeWithWeight           sync.RWMutex
	lockCMSQuery                     sync.RWMutex
	lockClientGetName                sync.RWMutex
	lockClientID                     sync.RWMutex
	lockClientInfo                   sync.RWMutex
	lockClientKill                   sync.RWMutex
	lockClientKillByFilter           sync.RWMutex
	lockClientList                   sync.RWMutex
	lockClientMaintNotifications     sync.RWMutex
	lockClientPause                  sync.RWMutex
	lockClientUnblock                sync.RWMutex
	lockClientUnblockWithError       sync.RWMutex
	lockClientUnpause                sync.RWMutex
	lockClusterAddSlots              sync.RWMutex
	lockClusterAddSlotsRange         sync.RWMutex
	lockClusterCountFailureReports   sync.RWMutex
	lockClusterCountKeysInSlot       sync.RWMutex
	lockClusterDelSlots              sync.RWMutex
	lockClusterDelSlotsRange         sync.RWMutex
	lockClusterFailover              sync.RWMutex
	lockClusterForget                sync.RWMutex
	lockClusterGetKeysInSlot         sync.RWMutex
	lockClusterInfo                  sync.RWMutex
	lockClusterKeySlot               sync.RWMutex
	lockClusterLinks                 sync.RWMutex
	lockClusterMeet                  sync.RWMutex
	lockClusterMyID                  sync.RWMutex
	lockClusterMyShardID             sync.RWMutex
	lockClusterNodes                 sync.RWMutex
	lockClusterReplicate             sync.RWMutex
	lockClusterResetHard             sync.RWMutex
	lockClusterResetSoft             sync.RWMutex
	lockClusterSaveConfig            sync.RWMutex
	lockClusterShards                sync.RWMutex
	lockClusterSlaves                sync.RWMutex
	lockClusterSlots                 sync.RWMutex
	lockCommand                      sync.RWMutex
	lockCommandGetKeys               sync.RWMutex
	lockCommandGetKeysAndFlags       sync.RWMutex
	lockCommandList                  sync.RWMutex
	lockConfigGet                    sync.RWMutex
	lockConfigResetStat              sync.RWMutex
	lockConfigRewrite                sync.RWMutex
	lockConfigSet                    sync.RWMutex
	lockCopy                         sync.RWMutex
	lockDBSize                       sync.RWMutex
	lockDebugObject                  sync.RWMutex
	lockDecr                         sync.RWMutex
	lockDecrBy                       sync.RWMutex
	lockDel                          sync.RWMutex
	lockDelExArgs                    sync.RWMutex
	lockDigest                       sync.RWMutex
	lockDump                         sync.RWMutex
	lockEcho                         sync.RWMutex
	lockEval                         sync.RWMutex
	lockEvalRO                       sync.RWMutex
	lockEvalSha                      sync.RWMutex
	lockEvalShaRO                    sync.RWMutex
	lockExists                       sync.RWMutex
	lockExpire                       sync.RWMutex
	lockExpireAt                     sync.RWMutex
	lockExpireGT                     sync.RWMutex
	lockExpireLT                     sync.RWMutex
	lockExpireNX                     sync.RWMutex
	lockExpireTime                   sync.RWMutex
	lockExpireXX                     sync.RWMutex
	lockFCall                        sync.RWMutex
	lockFCallRO                      sync.RWMutex
	lockFCallRo                      sync.RWMutex
	lockFTAggregate                  sync.RWMutex
	lockFTAggregateWithArgs          sync.RWMutex
	lockFTAliasAdd                   sync.RWMutex
	lockFTAliasDel                   sync.RWMutex
	lockFTAliasUpdate                sync.RWMutex
	lockFTAlter                      sync.RWMutex
	lockFTConfigGet                  sync.RWMutex
	lockFTConfigSet                  sync.RWMutex
	lockFTCreate                     sync.RWMutex
	lockFTCursorDel                  sync.RWMutex
	lockFTCursorRead                 sync.RWMutex
	lockFTDictAdd                    sync.RWMutex
	lockFTDictDel                    sync.RWMutex
	lockFTDictDump                   sync.RWMutex
	lockFTDropIndex                  sync.RWMutex
	lockFTDropIndexWithArgs          sync.RWMutex
	lockFTExplain                    sync.RWMutex
	lockFTExplainWithArgs            sync.RWMutex
	lockFTHybrid                     sync.RWMutex
	lockFTHybridWithArgs             sync.RWMutex
	lockFTInfo                       sync.RWMutex
	lockFTSearch                     sync.RWMutex
	lockFTSearchWithArgs             sync.RWMutex
	lockFTSpellCheck                 sync.RWMutex
	lockFTSpellCheckWithArgs         sync.RWMutex
	lockFTSynDump                    sync.RWMutex
	lockFTSynUpdate                  sync.RWMutex
	lockFTSynUpdateWithArgs          sync.RWMutex
	lockFTTagVals                    sync.RWMutex
	lockFT_List                      sync.RWMutex
	lockFlushAll                     sync.RWMutex
	lockFlushAllAsync                sync.RWMutex
	lockFlushDB                      sync.RWMutex
	lockFlushDBAsync                 sync.RWMutex
	lockFunctionDelete               sync.RWMutex
	lockFunctionDump                 sync.RWMutex
	lockFunctionFlush                sync.RWMutex
	lockFunctionFlushAsync           sync.RWMutex
	lockFunctionKill                 sync.RWMutex
	lockFunctionList                 sync.RWMutex
	lockFunctionLoad                 sync.RWMutex
	lockFunctionLoadReplace          sync.RWMutex
	lockFunctionRestore              sync.RWMutex
	lockFunctionStats                sync.RWMutex
	lockGeoAdd                       sync.RWMutex
	lockGeoDist                      sync.RWMutex
	lockGeoHash                      sync.RWMutex
	lockGeoPos                       sync.RWMutex
	lockGeoRadius                    sync.RWMutex
	lockGeoRadiusByMember            sync.RWMutex
	lockGeoRadiusByMemberStore       sync.RWMutex
	lockGeoRadiusStore               sync.RWMutex
	lockGeoSearch                    sync.RWMutex
	lockGeoSearchLocation            sync.RWMutex
	lockGeoSearchStore               sync.RWMutex
	lockGet                          sync.RWMutex
	lockGetBit                       sync.RWMutex
	lockGetDel                       sync.RWMutex
	lockGetEx                        sync.RWMutex
	lockGetRange                     sync.RWMutex
	lockGetSet                       sync.RWMutex
	lockHDel                         sync.RWMutex
	lockHExists                      sync.RWMutex
	lockHExpire                      sync.RWMutex
	lockHExpireAt                    sync.RWMutex
	lockHExpireAtWithArgs            sync.RWMutex
	lockHExpireTime                  sync.RWMutex
	lockHExpireWithArgs              sync.RWMutex
	lockHGet                         sync.RWMutex
	lockHGetAll                      sync.RWMutex
	lockHGetDel                      sync.RWMutex
	lockHGetEX                       sync.RWMutex
	lockHGetEXWithArgs               sync.RWMutex
	lockHIncrBy                      sync.RWMutex
	lockHIncrByFloat                 sync.RWMutex
	lockHKeys                        sync.RWMutex
	lockHLen                         sync.RWMutex
	lockHMGet                        sync.RWMutex
	lockHMSet                        sync.RWMutex
	lockHPExpire                     sync.RWMutex
	lockHPExpireAt                   sync.RWMutex
	lockHPExpireAtWithArgs           sync.RWMutex
	lockHPExpireTime                 sync.RWMutex
	lockHPExpireWithArgs             sync.RWMutex
	lockHPTTL                        sync.RWMutex
	lockHPersist                     sync.RWMutex
	lockHRandField                   sync.RWMutex
	lockHRandFieldWithValues         sync.RWMutex
	lockHScan                        sync.RWMutex
	lockHScanNoValues                sync.RWMutex
	lockHSet                         sync.RWMutex
	lockHSetEX                       sync.RWMutex
	lockHSetEXWithArgs               sync.RWMutex
	lockHSetNX                       sync.RWMutex
	lockHStrLen                      sync.RWMutex
	lockHTTL                         sync.RWMutex
	lockHVals                        sync.RWMutex
	lockIncr                         sync.RWMutex
	lockIncrBy                       sync.RWMutex
	lockIncrByFloat                  sync.RWMutex
	lockInfo                         sync.RWMutex
	lockJSONArrAppend                sync.RWMutex
	lockJSONArrIndex                 sync.RWMutex
	lockJSONArrIndexWithArgs         sync.RWMutex
	lockJSONArrInsert                sync.RWMutex
	lockJSONArrLen                   sync.RWMutex
	lockJSONArrPop                   sync.RWMutex
	lockJSONArrTrim                  sync.RWMutex
	lockJSONArrTrimWithArgs          sync.RWMutex
	lockJSONClear                    sync.RWMutex
	lockJSONDebugMemory              sync.RWMutex
	lockJSONDel                      sync.RWMutex
	lockJSONForget                   sync.RWMutex
	lockJSONGet                      sync.RWMutex
	lockJSONGetWithArgs              sync.RWMutex
	lockJSONMGet                     sync.RWMutex
	lockJSONMSet                     sync.RWMutex
	lockJSONMSetArgs                 sync.RWMutex
	lockJSONMerge                    sync.RWMutex
	lockJSONNumIncrBy                sync.RWMutex
	lockJSONObjKeys                  sync.RWMutex
	lockJSONObjLen                   sync.RWMutex
	lockJSONSet                      sync.RWMutex
	lockJSONSetMode                  sync.RWMutex
	lockJSONStrAppend                sync.RWMutex
	lockJSONStrLen                   sync.RWMutex
	lockJSONToggle                   sync.RWMutex
	lockJSONType                     sync.RWMutex
	lockKeys                         sync.RWMutex
	lockLCS                          sync.RWMutex
	lockLIndex                       sync.RWMutex
	lockLInsert                      sync.RWMutex
	lockLInsertAfter                 sync.RWMutex
	lockLInsertBefore                sync.RWMutex
	lockLLen                         sync.RWMutex
	lockLMPop                        sync.RWMutex
	lockLMove                        sync.RWMutex
	lockLPop                         sync.RWMutex
	lockLPopCount                    sync.RWMutex
	lockLPos                         sync.RWMutex
	lockLPosCount                    sync.RWMutex
	lockLPush                        sync.RWMutex
	lockLPushX                       sync.RWMutex
	lockLRange                       sync.RWMutex
	lockLRem                         sync.RWMutex
	lockLSet                         sync.RWMutex
	lockLTrim                        sync.RWMutex
	lockLastSave                     sync.RWMutex
	lockLatency                      sync.RWMutex
	lockLatencyReset                 sync.RWMutex
	lockMGet                         sync.RWMutex
	lockMSet                         sync.RWMutex
	lockMSetEX                       sync.RWMutex
	lockMSetNX                       sync.RWMutex
	lockMemoryUsage                  sync.RWMutex
	lockMigrate                      sync.RWMutex
	lockModuleLoadex                 sync.RWMutex
	lockMove                         sync.RWMutex
	lockObjectEncoding               sync.RWMutex
	lockObjectFreq                   sync.RWMutex
	lockObjectIdleTime               sync.RWMutex
	lockObjectRefCount               sync.RWMutex
	lockPExpire                      sync.RWMutex
	lockPExpireAt                    sync.RWMutex
	lockPExpireTime                  sync.RWMutex
	lockPFAdd                        sync.RWMutex
	lockPFCount                      sync.RWMutex
	lockPFMerge                      sync.RWMutex
	lockPTTL                         sync.RWMutex
	lockPersist                      sync.RWMutex
	lockPing                         sync.RWMutex
	lockPipeline                     sync.RWMutex
	lockPipelined                    sync.RWMutex
	lockPubSubChannels               sync.RWMutex
	lockPubSubNumPat                 sync.RWMutex
	lockPubSubNumSub                 sync.RWMutex
	lockPubSubShardChannels          sync.RWMutex
	lockPubSubShardNumSub            sync.RWMutex
	lockPublish                      sync.RWMutex
	lockQuit                         sync.RWMutex
	lockRPop                         sync.RWMutex
	lockRPopCount                    sync.RWMutex
	lockRPopLPush                    sync.RWMutex
	lockRPush                        sync.RWMutex
	lockRPushX                       sync.RWMutex
	lockRandomKey                    sync.RWMutex
	lockReadOnly                     sync.RWMutex
	lockReadWrite                    sync.RWMutex
	lockRename                       sync.RWMutex
	lockRenameNX                     sync.RWMutex
	lockRestore                      sync.RWMutex
	lockRestoreReplace               sync.RWMutex
	lockSAdd                         sync.RWMutex
	lockSCard                        sync.RWMutex
	lockSDiff                        sync.RWMutex
	lockSDiffStore                   sync.RWMutex
	lockSInter                       sync.RWMutex
	lockSInterCard                   sync.RWMutex
	lockSInterStore                  sync.RWMutex
	lockSIsMember                    sync.RWMutex
	lockSMIsMember                   sync.RWMutex
	lockSMembers                     sync.RWMutex
	lockSMembersMap                  sync.RWMutex
	lockSMove                        sync.RWMutex
	lockSPop                         sync.RWMutex
	lockSPopN                        sync.RWMutex
	lockSPublish                     sync.RWMutex
	lockSRandMember                  sync.RWMutex
	lockSRandMemberN                 sync.RWMutex
	lockSRem                         sync.RWMutex
	lockSScan                        sync.RWMutex
	lockSUnion                       sync.RWMutex
	lockSUnionStore                  sync.RWMutex
	lockSave                         sync.RWMutex
	lockScan                         sync.RWMutex
	lockScanType                     sync.RWMutex
	lockScriptExists                 sync.RWMutex
	lockScriptFlush                  sync.RWMutex
	lockScriptKill                   sync.RWMutex
	lockScriptLoad                   sync.RWMutex
	lockSet                          sync.RWMutex
	lockSetArgs                      sync.RWMutex
	lockSetBit                       sync.RWMutex
	lockSetEx                        sync.RWMutex
	lockSetIFDEQ                     sync.RWMutex
	lockSetIFDEQGet                  sync.RWMutex
	lockSetIFDNE                     sync.RWMutex
	lockSetIFDNEGet                  sync.RWMutex
	lockSetIFEQ                      sync.RWMutex
	lockSetIFEQGet                   sync.RWMutex
	lockSetIFNE                      sync.RWMutex
	lockSetIFNEGet                   sync.RWMutex
	lockSetNX                        sync.RWMutex
	lockSetRange                     sync.RWMutex
	lockSetXX                        sync.RWMutex
	lockShutdown                     sync.RWMutex
	lockShutdownNoSave               sync.RWMutex
	lockShutdownSave                 sync.RWMutex
	lockSlaveOf                      sync.RWMutex
	lockSlowLogGet                   sync.RWMutex
	lockSlowLogLen                   sync.RWMutex
	lockSlowLogReset                 sync.RWMutex
	lockSort                         sync.RWMutex
	lockSortInterfaces               sync.RWMutex
	lockSortRO                       sync.RWMutex
	lockSortStore                    sync.RWMutex
	lockStrLen                       sync.RWMutex
	lockSubscribe                    sync.RWMutex
	lockTDigestAdd                   sync.RWMutex
	lockTDigestByRank                sync.RWMutex
	lockTDigestByRevRank             sync.RWMutex
	lockTDigestCDF                   sync.RWMutex
	lockTDigestCreate                sync.RWMutex
	lockTDigestCreateWithCompression sync.RWMutex
	lockTDigestInfo                  sync.RWMutex
	lockTDigestMax                   sync.RWMutex
	lockTDigestMerge                 sync.RWMutex
	lockTDigestMin                   sync.RWMutex
	lockTDigestQuantile              sync.RWMutex
	lockTDigestRank                  sync.RWMutex
	lockTDigestReset                 sync.RWMutex
	lockTDigestRevRank               sync.RWMutex
	lockTDigestTrimmedMean           sync.RWMutex
	lockTSAdd                        sync.RWMutex
	lockTSAddWithArgs                sync.RWMutex
	lockTSAlter                      sync.RWMutex
	lockTSCreate                     sync.RWMutex
	lockTSCreateRule                 sync.RWMutex
	lockTSCreateRuleWithArgs         sync.RWMutex
	lockTSCreateWithArgs             sync.RWMutex
	lockTSDecrBy                     sync.RWMutex
	lockTSDecrByWithArgs             sync.RWMutex
	lockTSDel                        sync.RWMutex
	lockTSDeleteRule                 sync.RWMutex
	lockTSGet                        sync.RWMutex
	lockTSGetWithArgs                sync.RWMutex
	lockTSIncrBy                     sync.RWMutex
	lockTSIncrByWithArgs             sync.RWMutex
	lockTSInfo                       sync.RWMutex
	lockTSInfoWithArgs               sync.RWMutex
	lockTSMAdd                       sync.RWMutex
	lockTSMGet                       sync.RWMutex
	lockTSMGetWithArgs               sync.RWMutex
	lockTSMRange                     sync.RWMutex
	lockTSMRangeWithArgs             sync.RWMutex
	lockTSMRevRange                  sync.RWMutex
	lockTSMRevRangeWithArgs          sync.RWMutex
	lockTSQueryIndex                 sync.RWMutex
	lockTSRange                      sync.RWMutex
	lockTSRangeWithArgs              sync.RWMutex
	lockTSRevRange                   sync.RWMutex
	lockTSRevRangeWithArgs           sync.RWMutex
	lockTTL                          sync.RWMutex
	lockTime                         sync.RWMutex
	lockTopKAdd                      sync.RWMutex
	lockTopKCount                    sync.RWMutex
	lockTopKIncrBy                   sync.RWMutex
	lockTopKInfo                     sync.RWMutex
	lockTopKList                     sync.RWMutex
	lockTopKListWithCount            sync.RWMutex
	lockTopKQuery                    sync.RWMutex
	lockTopKReserve                  sync.RWMutex
	lockTopKReserveWithOptions       sync.RWMutex
	lockTouch                        sync.RWMutex
	lockTxPipeline                   sync.RWMutex
	lockTxPipelined                  sync.RWMutex
	lockType                         sync.RWMutex
	lockUnlink                       sync.RWMutex
	lockVAdd                         sync.RWMutex
	lockVAddWithArgs                 sync.RWMutex
	lockVCard                        sync.RWMutex
	lockVClearAttributes             sync.RWMutex
	lockVDim                         sync.RWMutex
	lockVEmb                         sync.RWMutex
	lockVGetAttr                     sync.RWMutex
	lockVInfo                        sync.RWMutex
	lockVLinks                       sync.RWMutex
	lockVLinksWithScores             sync.RWMutex
	lockVRandMember                  sync.RWMutex
	lockVRandMemberCount             sync.RWMutex
	lockVRange                       sync.RWMutex
	lockVRem                         sync.RWMutex
	lockVSetAttr                     sync.RWMutex
	lockVSim                         sync.RWMutex
	lockVSimWithArgs                 sync.RWMutex
	lockVSimWithArgsWithScores       sync.RWMutex
	lockVSimWithScores               sync.RWMutex
	lockXAck                         sync.RWMutex
	lockXAckDel                      sync.RWMutex
	lockXAdd                         sync.RWMutex
	lockXAutoClaim                   sync.RWMutex
	lockXAutoClaimJustID             sync.RWMutex
	lockXCfgSet                      sync.RWMutex
	lockXClaim                       sync.RWMutex
	lockXClaimJustID                 sync.RWMutex
	lockXDel                         sync.RWMutex
	lockXDelEx                       sync.RWMutex
	lockXGroupCreate                 sync.RWMutex
	lockXGroupCreateConsumer         sync.RWMutex
	lockXGroupCreateMkStream         sync.RWMutex
	lockXGroupDelConsumer            sync.RWMutex
	lockXGroupDestroy                sync.RWMutex
	lockXGroupSetID                  sync.RWMutex
	lockXInfoConsumers               sync.RWMutex
	lockXInfoGroups                  sync.RWMutex
	lockXInfoStream                  sync.RWMutex
	lockXInfoStreamFull              sync.RWMutex
	lockXLen                         sync.RWMutex
	lockXPending                     sync.RWMutex
	lockXPendingExt                  sync.RWMutex
	lockXRange                       sync.RWMutex
	lockXRangeN                      sync.RWMutex
	lockXRead                        sync.RWMutex
	lockXReadGroup                   sync.RWMutex
	lockXReadStreams                 sync.RWMutex
	lockXRevRange                    sync.RWMutex
	lockXRevRangeN                   sync.RWMutex
	lockXTrimMaxLen                  sync.RWMutex
	lockXTrimMaxLenApprox            sync.RWMutex
	lockXTrimMaxLenApproxMode        sync.RWMutex
	lockXTrimMaxLenMode              sync.RWMutex
	lockXTrimMinID                   sync.RWMutex
	lockXTrimMinIDApprox             sync.RWMutex
	lockXTrimMinIDApproxMode         sync.RWMutex
	lockXTrimMinIDMode               sync.RWMutex
	lockZAdd                         sync.RWMutex
	lockZAddArgs                     sync.RWMutex
	lockZAddArgsIncr                 sync.RWMutex
	lockZAddGT                       sync.RWMutex
	lockZAddLT                       sync.RWMutex
	lockZAddNX                       sync.RWMutex
	lockZAddXX                       sync.RWMutex
	lockZCard                        sync.RWMutex
	lockZCount                       sync.RWMutex
	lockZDiff                        sync.RWMutex
	lockZDiffStore                   sync.RWMutex
	lockZDiffWithScores              sync.RWMutex
	lockZIncrBy                      sync.RWMutex
	lockZInter                       sync.RWMutex
	lockZInterCard                   sync.RWMutex
	lockZInterStore                  sync.RWMutex
	lockZInterWithScores             sync.RWMutex
	lockZLexCount                    sync.RWMutex
	lockZMPop                        sync.RWMutex
	lockZMScore                      sync.RWMutex
	lockZPopMax                      sync.RWMutex
	lockZPopMin                      sync.RWMutex
	lockZRandMember                  sync.RWMutex
	lockZRandMemberWithScores        sync.RWMutex
	lockZRange                       sync.RWMutex
	lockZRangeArgs                   sync.RWMutex
	lockZRangeArgsWithScores         sync.RWMutex
	lockZRangeByLex                  sync.RWMutex
	lockZRangeByScore                sync.RWMutex
	lockZRangeByScoreWithScores      sync.RWMutex
	lockZRangeStore                  sync.RWMutex
	lockZRangeWithScores             sync.RWMutex
	lockZRank                        sync.RWMutex
	lockZRankWithScore               sync.RWMutex
	lockZRem                         sync.RWMutex
	lockZRemRangeByLex               sync.RWMutex
	lockZRemRangeByRank              sync.RWMutex
	lockZRemRangeByScore             sync.RWMutex
	lockZRevRange                    sync.RWMutex
	lockZRevRangeByLex               sync.RWMutex
	lockZRevRangeByScore             sync.RWMutex
	lockZRevRangeByScoreWithScores   sync.RWMutex
	lockZRevRangeWithScores          sync.RWMutex
	lockZRevRank                     sync.RWMutex
	lockZRevRankWithScore            sync.RWMutex
	lockZScan                        sync.RWMutex
	lockZScore                       sync.RWMutex
	lockZUnion                       sync.RWMutex
	lockZUnionStore                  sync.RWMutex
	lockZUnionWithScores             sync.RWMutex
}

// ACLCat calls ACLCatFunc.
func (mock *MoqCmdable) ACLCat(ctx context.Context) *redis.StringSliceCmd {
	if mock.ACLCatFunc == nil {
		panic("MoqCmdable.ACLCatFunc: method is nil but Cmdable.ACLCat was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockACLCat.Lock()
	mock.calls.ACLCat = append(mock.calls.ACLCat, callInfo)
	mock.lockACLCat.Unlock()
	return mock.ACLCatFunc(ctx)
}

// ACLCatCalls gets all the calls that were made to ACLCat.
// Check the length with:
//
//	len(mockedCmdable.ACLCatCalls())
func (mock *MoqCmdable) ACLCatCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockACLCat.RLock()
	calls = mock.calls.ACLCat
	mock.lockACLCat.RUnlock()
	return calls
}

// ResetACLCatCalls reset all the calls that were made to ACLCat.
func (mock *MoqCmdable) ResetACLCatCalls() {
	mock.lockACLCat.Lock()
	mock.calls.ACLCat = nil
	mock.lockACLCat.Unlock()
}

// ACLCatArgs calls ACLCatArgsFunc.
func (mock *MoqCmdable) ACLCatArgs(ctx context.Context, options *redis.ACLCatArgs) *redis.StringSliceCmd {
	if mock.ACLCatArgsFunc == nil {
		panic("MoqCmdable.ACLCatArgsFunc: method is nil but Cmdable.ACLCatArgs was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Options *redis.ACLCatArgs
	}{
		Ctx:     ctx,
		Options: options,
	}
	mock.lockACLCatArgs.Lock()
	mock.calls.ACLCatArgs = append(mock.calls.ACLCatArgs, callInfo)
	mock.lockACLCatArgs.Unlock()
	return mock.ACLCatArgsFunc(ctx, options)
}

// ACLCatArgsCalls gets all the calls that were made to ACLCatArgs.
// Check the length with:
//
//	len(mockedCmdable.ACLCatArgsCalls())
func (mock *MoqCmdable) ACLCatArgsCalls() []struct {
	Ctx     context.Context
	Options *redis.ACLCatArgs
} {
	var calls []struct {
		Ctx     context.Context
		Options *redis.ACLCatArgs
	}
	mock.lockACLCatArgs.RLock()
	calls = mock.calls.ACLCatArgs
	mock.lockACLCatArgs.RUnlock()
	return calls
}

// ResetACLCatArgsCalls reset all the calls that were made to ACLCatArgs.
func (mock *MoqCmdable) ResetACLCatArgsCalls() {
	mock.lockACLCatArgs.Lock()
	mock.calls.ACLCatArgs = nil
	mock.lockACLCatArgs.Unlock()
}

// ACLDelUser calls ACLDelUserFunc.
func (mock *MoqCmdable) ACLDelUser(ctx context.Context, username string) *redis.IntCmd {
	if mock.ACLDelUserFunc == nil {
		panic("MoqCmdable.ACLDelUserFunc: method is nil but Cmdable.ACLDelUser was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Username string
	}{
		Ctx:      ctx,
		Username: username,
	}
	mock.lockACLDelUser.Lock()
	mock.calls.ACLDelUser = append(mock.calls.ACLDelUser, callInfo)
	mock.lockACLDelUser.Unlock()
	return mock.ACLDelUserFunc(ctx, username)
}

// ACLDelUserCalls gets all the calls that were made to ACLDelUser.
// Check the length with:
//
//	len(mockedCmdable.ACLDelUserCalls())
func (mock *MoqCmdable) ACLDelUserCalls() []struct {
	Ctx      context.Context
	Username string
} {
	var calls []struct {
		Ctx      context.Context
		Username string
	}
	mock.lockACLDelUser.RLock()
	calls = mock.calls.ACLDelUser
	mock.lockACLDelUser.RUnlock()
	return calls
}

// ResetACLDelUserCalls reset all the calls that were made to ACLDelUser.
func (mock *MoqCmdable) ResetACLDelUserCalls() {
	mock.lockACLDelUser.Lock()
	mock.calls.ACLDelUser = nil
	mock.lockACLDelUser.Unlock()
}

// ACLDryRun calls ACLDryRunFunc.
func (mock *MoqCmdable) ACLDryRun(ctx context.Context, username string, command ...interface{}) *redis.StringCmd {
	if mock.ACLDryRunFunc == nil {
		panic("MoqCmdable.ACLDryRunFunc: method is nil but Cmdable.ACLDryRun was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Username string
		Command  []interface{}
	}{
		Ctx:      ctx,
		Username: username,
		Command:  command,
	}
	mock.lockACLDryRun.Lock()
	mock.calls.ACLDryRun = append(mock.calls.ACLDryRun, callInfo)
	mock.lockACLDryRun.Unlock()
	return mock.ACLDryRunFunc(ctx, username, command...)
}

// ACLDryRunCalls gets all the calls that were made to ACLDryRun.
// Check the length with:
//
//	len(mockedCmdable.ACLDryRunCalls())
func (mock *MoqCmdable) ACLDryRunCalls() []struct {
	Ctx      context.Context
	Username string
	Command  []interface{}
} {
	var calls []struct {
		Ctx      context.Context
		Username string
		Command  []interface{}
	}
	mock.lockACLDryRun.RLock()
	calls = mock.calls.ACLDryRun
	mock.lockACLDryRun.RUnlock()
	return calls
}

// ResetACLDryRunCalls reset all the calls that were made to ACLDryRun.
func (mock *MoqCmdable) ResetACLDryRunCalls() {
	mock.lockACLDryRun.Lock()
	mock.calls.ACLDryRun = nil
	mock.lockACLDryRun.Unlock()
}

// ACLGenPass calls ACLGenPassFunc.
func (mock *MoqCmdable) ACLGenPass(ctx context.Context, bit int) *redis.StringCmd {
	if mock.ACLGenPassFunc == nil {
		panic("MoqCmdable.ACLGenPassFunc: method is nil but Cmdable.ACLGenPass was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Bit int
	}{
		Ctx: ctx,
		Bit: bit,
	}
	mock.lockACLGenPass.Lock()
	mock.calls.ACLGenPass = append(mock.calls.ACLGenPass, callInfo)
	mock.lockACLGenPass.Unlock()
	return mock.ACLGenPassFunc(ctx, bit)
}

// ACLGenPassCalls gets all the calls that were made to ACLGenPass.
// Check the length with:
//
//	len(mockedCmdable.ACLGenPassCalls())
func (mock *MoqCmdable) ACLGenPassCalls() []struct {
	Ctx context.Context
	Bit int
} {
	var calls []struct {
		Ctx context.Context
		Bit int
	}
	mock.lockACLGenPass.RLock()
	calls = mock.calls.ACLGenPass
	mock.lockACLGenPass.RUnlock()
	return calls
}

// ResetACLGenPassCalls reset all the calls that were made to ACLGenPass.
func (mock *MoqCmdable) ResetACLGenPassCalls() {
	mock.lockACLGenPass.Lock()
	mock.calls.ACLGenPass = nil
	mock.lockACLGenPass.Unlock()
}

// ACLList calls ACLListFunc.
func (mock *MoqCmdable) ACLList(ctx context.Context) *redis.StringSliceCmd {
	if mock.ACLListFunc == nil {
		panic("MoqCmdable.ACLListFunc: method is nil but Cmdable.ACLList was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockACLList.Lock()
	mock.calls.ACLList = append(mock.calls.ACLList, callInfo)
	mock.lockACLList.Unlock()
	return mock.ACLListFunc(ctx)
}

// ACLListCalls gets all the calls that were made to ACLList.
// Check the length with:
//
//	len(mockedCmdable.ACLListCalls())
func (mock *MoqCmdable) ACLListCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockACLList.RLock()
	calls = mock.calls.ACLList
	mock.lockACLList.RUnlock()
	return calls
}

// ResetACLListCalls reset all the calls that were made to ACLList.
func (mock *MoqCmdable) ResetACLListCalls() {
	mock.lockACLList.Lock()
	mock.calls.ACLList = nil
	mock.lockACLList.Unlock()
}

// ACLLog calls ACLLogFunc.
func (mock *MoqCmdable) ACLLog(ctx context.Context, count int64) *redis.ACLLogCmd {
	if mock.ACLLogFunc == nil {
		panic("MoqCmdable.ACLLogFunc: method is nil but Cmdable.ACLLog was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Count int64
	}{
		Ctx:   ctx,
		Count: count,
	}
	mock.lockACLLog.Lock()
	mock.calls.ACLLog = append(mock.calls.ACLLog, callInfo)
	mock.lockACLLog.Unlock()
	return mock.ACLLogFunc(ctx, count)
}

// ACLLogCalls gets all the calls that were made to ACLLog.
// Check the length with:
//
//	len(mockedCmdable.ACLLogCalls())
func (mock *MoqCmdable) ACLLogCalls() []struct {
	Ctx   context.Context
	Count int64
} {
	var calls []struct {
		Ctx   context.Context
		Count int64
	}
	mock.lockACLLog.RLock()
	calls = mock.calls.ACLLog
	mock.lockACLLog.RUnlock()
	return calls
}

// ResetACLLogCalls reset all the calls that were made to ACLLog.
func (mock *MoqCmdable) ResetACLLogCalls() {
	mock.lockACLLog.Lock()
	mock.calls.ACLLog = nil
	mock.lockACLLog.Unlock()
}

// ACLLogReset calls ACLLogResetFunc.
func (mock *MoqCmdable) ACLLogReset(ctx context.Context) *redis.StatusCmd {
	if mock.ACLLogResetFunc == nil {
		panic("MoqCmdable.ACLLogResetFunc: method is nil but Cmdable.ACLLogReset was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockACLLogReset.Lock()
	mock.calls.ACLLogReset = append(mock.calls.ACLLogReset, callInfo)
	mock.lockACLLogReset.Unlock()
	return mock.ACLLogResetFunc(ctx)
}

// ACLLogResetCalls gets all the calls that were made to ACLLogReset.
// Check the length with:
//
//	len(mockedCmdable.ACLLogResetCalls())
func (mock *MoqCmdable) ACLLogResetCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockACLLogReset.RLock()
	calls = mock.calls.ACLLogReset
	mock.lockACLLogReset.RUnlock()
	return calls
}

// ResetACLLogResetCalls reset all the calls that were made to ACLLogReset.
func (mock *MoqCmdable) ResetACLLogResetCalls() {
	mock.lockACLLogReset.Lock()
	mock.calls.ACLLogReset = nil
	mock.lockACLLogReset.Unlock()
}

// ACLSetUser calls ACLSetUserFunc.
func (mock *MoqCmdable) ACLSetUser(ctx context.Context, username string, rules ...string) *redis.StatusCmd {
	if mock.ACLSetUserFunc == nil {
		panic("MoqCmdable.ACLSetUserFunc: method is nil but Cmdable.ACLSetUser was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Username string
		Rules    []string
	}{
		Ctx:      ctx,
		Username: username,
		Rules:    rules,
	}
	mock.lockACLSetUser.Lock()
	mock.calls.ACLSetUser = append(mock.calls.ACLSetUser, callInfo)
	mock.lockACLSetUser.Unlock()
	return mock.ACLSetUserFunc(ctx, username, rules...)
}

// ACLSetUserCalls gets all the calls that were made to ACLSetUser.
// Check the length with:
//
//	len(mockedCmdable.ACLSetUserCalls())
func (mock *MoqCmdable) ACLSetUserCalls() []struct {
	Ctx      context.Context
	Username string
	Rules    []string
} {
	var calls []struct {
		Ctx      context.Context
		Username string
		Rules    []string
	}
	mock.lockACLSetUser.RLock()
	calls = mock.calls.ACLSetUser
	mock.lockACLSetUser.RUnlock()
	return calls
}

// ResetACLSetUserCalls reset all the calls that were made to ACLSetUser.
func (mock *MoqCmdable) ResetACLSetUserCalls() {
	mock.lockACLSetUser.Lock()
	mock.calls.ACLSetUser = nil
	mock.lockACLSetUser.Unlock()
}

// ACLUsers calls ACLUsersFunc.
func (mock *MoqCmdable) ACLUsers(ctx context.Context) *redis.StringSliceCmd {
	if mock.ACLUsersFunc == nil {
		panic("MoqCmdable.ACLUsersFunc: method is nil but Cmdable.ACLUsers was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockACLUsers.Lock()
	mock.calls.ACLUsers = append(mock.calls.ACLUsers, callInfo)
	mock.lockACLUsers.Unlock()
	return mock.ACLUsersFunc(ctx)
}

// ACLUsersCalls gets all the calls that were made to ACLUsers.
// Check the length with:
//
//	len(mockedCmdable.ACLUsersCalls())
func (mock *MoqCmdable) ACLUsersCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockACLUsers.RLock()
	calls = mock.calls.ACLUsers
	mock.lockACLUsers.RUnlock()
	return calls
}

// ResetACLUsersCalls reset all the calls that were made to ACLUsers.
func (mock *MoqCmdable) ResetACLUsersCalls() {
	mock.lockACLUsers.Lock()
	mock.calls.ACLUsers = nil
	mock.lockACLUsers.Unlock()
}

// ACLWhoAmI calls ACLWhoAmIFunc.
func (mock *MoqCmdable) ACLWhoAmI(ctx context.Context) *redis.StringCmd {
	if mock.ACLWhoAmIFunc == nil {
		panic("MoqCmdable.ACLWhoAmIFunc: method is nil but Cmdable.ACLWhoAmI was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockACLWhoAmI.Lock()
	mock.calls.ACLWhoAmI = append(mock.calls.ACLWhoAmI, callInfo)
	mock.lockACLWhoAmI.Unlock()
	return mock.ACLWhoAmIFunc(ctx)
}

// ACLWhoAmICalls gets all the calls that were made to ACLWhoAmI.
// Check the length with:
//
//	len(mockedCmdable.ACLWhoAmICalls())
func (mock *MoqCmdable) ACLWhoAmICalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockACLWhoAmI.RLock()
	calls = mock.calls.ACLWhoAmI
	mock.lockACLWhoAmI.RUnlock()
	return calls
}

// ResetACLWhoAmICalls reset all the calls that were made to ACLWhoAmI.
func (mock *MoqCmdable) ResetACLWhoAmICalls() {
	mock.lockACLWhoAmI.Lock()
	mock.calls.ACLWhoAmI = nil
	mock.lockACLWhoAmI.Unlock()
}

// Append calls AppendFunc.
func (mock *MoqCmdable) Append(ctx context.Context, key string, value string) *redis.IntCmd {
	if mock.AppendFunc == nil {
		panic("MoqCmdable.AppendFunc: method is nil but Cmdable.Append was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Value string
	}{
		Ctx:   ctx,
		Key:   key,
		Value: value,
	}
	mock.lockAppend.Lock()
	mock.calls.Append = append(mock.calls.Append, callInfo)
	mock.lockAppend.Unlock()
	return mock.AppendFunc(ctx, key, value)
}

// AppendCalls gets all the calls that were made to Append.
// Check the length with:
//
//	len(mockedCmdable.AppendCalls())
func (mock *MoqCmdable) AppendCalls() []struct {
	Ctx   context.Context
	Key   string
	Value string
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Value string
	}
	mock.lockAppend.RLock()
	calls = mock.calls.Append
	mock.lockAppend.RUnlock()
	return calls
}

// ResetAppendCalls reset all the calls that were made to Append.
func (mock *MoqCmdable) ResetAppendCalls() {
	mock.lockAppend.Lock()
	mock.calls.Append = nil
	mock.lockAppend.Unlock()
}

// BFAdd calls BFAddFunc.
func (mock *MoqCmdable) BFAdd(ctx context.Context, key string, element interface{}) *redis.BoolCmd {
	if mock.BFAddFunc == nil {
		panic("MoqCmdable.BFAddFunc: method is nil but Cmdable.BFAdd was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Key     string
		Element interface{}
	}{
		Ctx:     ctx,
		Key:     key,
		Element: element,
	}
	mock.lockBFAdd.Lock()
	mock.calls.BFAdd = append(mock.calls.BFAdd, callInfo)
	mock.lockBFAdd.Unlock()
	return mock.BFAddFunc(ctx, key, element)
}

// BFAddCalls gets all the calls that were made to BFAdd.
// Check the length with:
//
//	len(mockedCmdable.BFAddCalls())
func (mock *MoqCmdable) BFAddCalls() []struct {
	Ctx     context.Context
	Key     string
	Element interface{}
} {
	var calls []struct {
		Ctx     context.Context
		Key     string
		Element interface{}
	}
	mock.lockBFAdd.RLock()
	calls = mock.calls.BFAdd
	mock.lockBFAdd.RUnlock()
	return calls
}

// ResetBFAddCalls reset all the calls that were made to BFAdd.
func (mock *MoqCmdable) ResetBFAddCalls() {
	mock.lockBFAdd.Lock()
	mock.calls.BFAdd = nil
	mock.lockBFAdd.Unlock()
}

// BFCard calls BFCardFunc.
func (mock *MoqCmdable) BFCard(ctx context.Context, key string) *redis.IntCmd {
	if mock.BFCardFunc == nil {
		panic("MoqCmdable.BFCardFunc: method is nil but Cmdable.BFCard was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockBFCard.Lock()
	mock.calls.BFCard = append(mock.calls.BFCard, callInfo)
	mock.lockBFCard.Unlock()
	return mock.BFCardFunc(ctx, key)
}

// BFCardCalls gets all the calls that were made to BFCard.
// Check the length with:
//
//	len(mockedCmdable.BFCardCalls())
func (mock *MoqCmdable) BFCardCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockBFCard.RLock()
	calls = mock.calls.BFCard
	mock.lockBFCard.RUnlock()
	return calls
}

// ResetBFCardCalls reset all the calls that were made to BFCard.
func (mock *MoqCmdable) ResetBFCardCalls() {
	mock.lockBFCard.Lock()
	mock.calls.BFCard = nil
	mock.lockBFCard.Unlock()
}

// BFExists calls BFExistsFunc.
func (mock *MoqCmdable) BFExists(ctx context.Context, key string, element interface{}) *redis.BoolCmd {
	if mock.BFExistsFunc == nil {
		panic("MoqCmdable.BFExistsFunc: method is nil but Cmdable.BFExists was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Key     string
		Element interface{}
	}{
		Ctx:     ctx,
		Key:     key,
		Element: element,
	}
	mock.lockBFExists.Lock()
	mock.calls.BFExists = append(mock.calls.BFExists, callInfo)
	mock.lockBFExists.Unlock()
	return mock.BFExistsFunc(ctx, key, element)
}

// BFExistsCalls gets all the calls that were made to BFExists.
// Check the length with:
//
//	len(mockedCmdable.BFExistsCalls())
func (mock *MoqCmdable) BFExistsCalls() []struct {
	Ctx     context.Context
	Key     string
	Element interface{}
} {
	var calls []struct {
		Ctx     context.Context
		Key     string
		Element interface{}
	}
	mock.lockBFExists.RLock()
	calls = mock.calls.BFExists
	mock.lockBFExists.RUnlock()
	return calls
}

// ResetBFExistsCalls reset all the calls that were made to BFExists.
func (mock *MoqCmdable) ResetBFExistsCalls() {
	mock.lockBFExists.Lock()
	mock.calls.BFExists = nil
	mock.lockBFExists.Unlock()
}

// BFInfo calls BFInfoFunc.
func (mock *MoqCmdable) BFInfo(ctx context.Context, key string) *redis.BFInfoCmd {
	if mock.BFInfoFunc == nil {
		panic("MoqCmdable.BFInfoFunc: method is nil but Cmdable.BFInfo was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockBFInfo.Lock()
	mock.calls.BFInfo = append(mock.calls.BFInfo, callInfo)
	mock.lockBFInfo.Unlock()
	return mock.BFInfoFunc(ctx, key)
}

// BFInfoCalls gets all the calls that were made to BFInfo.
// Check the length with:
//
//	len(mockedCmdable.BFInfoCalls())
func (mock *MoqCmdable) BFInfoCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockBFInfo.RLock()
	calls = mock.calls.BFInfo
	mock.lockBFInfo.RUnlock()
	return calls
}

// ResetBFInfoCalls reset all the calls that were made to BFInfo.
func (mock *MoqCmdable) ResetBFInfoCalls() {
	mock.lockBFInfo.Lock()
	mock.calls.BFInfo = nil
	mock.lockBFInfo.Unlock()
}

// BFInfoArg calls BFInfoArgFunc.
func (mock *MoqCmdable) BFInfoArg(ctx context.Context, key string, option string) *redis.BFInfoCmd {
	if mock.BFInfoArgFunc == nil {
		panic("MoqCmdable.BFInfoArgFunc: method is nil but Cmdable.BFInfoArg was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		Option string
	}{
		Ctx:    ctx,
		Key:    key,
		Option: option,
	}
	mock.lockBFInfoArg.Lock()
	mock.calls.BFInfoArg = append(mock.calls.BFInfoArg, callInfo)
	mock.lockBFInfoArg.Unlock()
	return mock.BFInfoArgFunc(ctx, key, option)
}

// BFInfoArgCalls gets all the calls that were made to BFInfoArg.
// Check the length with:
//
//	len(mockedCmdable.BFInfoArgCalls())
func (mock *MoqCmdable) BFInfoArgCalls() []struct {
	Ctx    context.Context
	Key    string
	Option string
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		Option string
	}
	mock.lockBFInfoArg.RLock()
	calls = mock.calls.BFInfoArg
	mock.lockBFInfoArg.RUnlock()
	return calls
}

// ResetBFInfoArgCalls reset all the calls that were made to BFInfoArg.
func (mock *MoqCmdable) ResetBFInfoArgCalls() {
	mock.lockBFInfoArg.Lock()
	mock.calls.BFInfoArg = nil
	mock.lockBFInfoArg.Unlock()
}

// BFInfoCapacity calls BFInfoCapacityFunc.
func (mock *MoqCmdable) BFInfoCapacity(ctx context.Context, key string) *redis.BFInfoCmd {
	if mock.BFInfoCapacityFunc == nil {
		panic("MoqCmdable.BFInfoCapacityFunc: method is nil but Cmdable.BFInfoCapacity was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockBFInfoCapacity.Lock()
	mock.calls.BFInfoCapacity = append(mock.calls.BFInfoCapacity, callInfo)
	mock.lockBFInfoCapacity.Unlock()
	return mock.BFInfoCapacityFunc(ctx, key)
}

// BFInfoCapacityCalls gets all the calls that were made to BFInfoCapacity.
// Check the length with:
//
//	len(mockedCmdable.BFInfoCapacityCalls())
func (mock *MoqCmdable) BFInfoCapacityCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockBFInfoCapacity.RLock()
	calls = mock.calls.BFInfoCapacity
	mock.lockBFInfoCapacity.RUnlock()
	return calls
}

// ResetBFInfoCapacityCalls reset all the calls that were made to BFInfoCapacity.
func (mock *MoqCmdable) ResetBFInfoCapacityCalls() {
	mock.lockBFInfoCapacity.Lock()
	mock.calls.BFInfoCapacity = nil
	mock.lockBFInfoCapacity.Unlock()
}

// BFInfoExpansion calls BFInfoExpansionFunc.
func (mock *MoqCmdable) BFInfoExpansion(ctx context.Context, key string) *redis.BFInfoCmd {
	if mock.BFInfoExpansionFunc == nil {
		panic("MoqCmdable.BFInfoExpansionFunc: method is nil but Cmdable.BFInfoExpansion was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockBFInfoExpansion.Lock()
	mock.calls.BFInfoExpansion = append(mock.calls.BFInfoExpansion, callInfo)
	mock.lockBFInfoExpansion.Unlock()
	return mock.BFInfoExpansionFunc(ctx, key)
}

// BFInfoExpansionCalls gets all the calls that were made to BFInfoExpansion.
// Check the length with:
//
//	len(mockedCmdable.BFInfoExpansionCalls())
func (mock *MoqCmdable) BFInfoExpansionCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockBFInfoExpansion.RLock()
	calls = mock.calls.BFInfoExpansion
	mock.lockBFInfoExpansion.RUnlock()
	return calls
}

// ResetBFInfoExpansionCalls reset all the calls that were made to BFInfoExpansion.
func (mock *MoqCmdable) ResetBFInfoExpansionCalls() {
	mock.lockBFInfoExpansion.Lock()
	mock.calls.BFInfoExpansion = nil
	mock.lockBFInfoExpansion.Unlock()
}

// BFInfoFilters calls BFInfoFiltersFunc.
func (mock *MoqCmdable) BFInfoFilters(ctx context.Context, key string) *redis.BFInfoCmd {
	if mock.BFInfoFiltersFunc == nil {
		panic("MoqCmdable.BFInfoFiltersFunc: method is nil but Cmdable.BFInfoFilters was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockBFInfoFilters.Lock()
	mock.calls.BFInfoFilters = append(mock.calls.BFInfoFilters, callInfo)
	mock.lockBFInfoFilters.Unlock()
	return mock.BFInfoFiltersFunc(ctx, key)
}

// BFInfoFiltersCalls gets all the calls that were made to BFInfoFilters.
// Check the length with:
//
//	len(mockedCmdable.BFInfoFiltersCalls())
func (mock *MoqCmdable) BFInfoFiltersCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockBFInfoFilters.RLock()
	calls = mock.calls.BFInfoFilters
	mock.lockBFInfoFilters.RUnlock()
	return calls
}

// ResetBFInfoFiltersCalls reset all the calls that were made to BFInfoFilters.
func (mock *MoqCmdable) ResetBFInfoFiltersCalls() {
	mock.lockBFInfoFilters.Lock()
	mock.calls.BFInfoFilters = nil
	mock.lockBFInfoFilters.Unlock()
}

// BFInfoItems calls BFInfoItemsFunc.
func (mock *MoqCmdable) BFInfoItems(ctx context.Context, key string) *redis.BFInfoCmd {
	if mock.BFInfoItemsFunc == nil {
		panic("MoqCmdable.BFInfoItemsFunc: method is nil but Cmdable.BFInfoItems was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockBFInfoItems.Lock()
	mock.calls.BFInfoItems = append(mock.calls.BFInfoItems, callInfo)
	mock.lockBFInfoItems.Unlock()
	return mock.BFInfoItemsFunc(ctx, key)
}

// BFInfoItemsCalls gets all the calls that were made to BFInfoItems.
// Check the length with:
//
//	len(mockedCmdable.BFInfoItemsCalls())
func (mock *MoqCmdable) BFInfoItemsCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockBFInfoItems.RLock()
	calls = mock.calls.BFInfoItems
	mock.lockBFInfoItems.RUnlock()
	return calls
}

// ResetBFInfoItemsCalls reset all the calls that were made to BFInfoItems.
func (mock *MoqCmdable) ResetBFInfoItemsCalls() {
	mock.lockBFInfoItems.Lock()
	mock.calls.BFInfoItems = nil
	mock.lockBFInfoItems.Unlock()
}

// BFInfoSize calls BFInfoSizeFunc.
func (mock *MoqCmdable) BFInfoSize(ctx context.Context, key string) *redis.BFInfoCmd {
	if mock.BFInfoSizeFunc == nil {
		panic("MoqCmdable.BFInfoSizeFunc: method is nil but Cmdable.BFInfoSize was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockBFInfoSize.Lock()
	mock.calls.BFInfoSize = append(mock.calls.BFInfoSize, callInfo)
	mock.lockBFInfoSize.Unlock()
	return mock.BFInfoSizeFunc(ctx, key)
}

// BFInfoSizeCalls gets all the calls that were made to BFInfoSize.
// Check the length with:
//
//	len(mockedCmdable.BFInfoSizeCalls())
func (mock *MoqCmdable) BFInfoSizeCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockBFInfoSize.RLock()
	calls = mock.calls.BFInfoSize
	mock.lockBFInfoSize.RUnlock()
	return calls
}

// ResetBFInfoSizeCalls reset all the calls that were made to BFInfoSize.
func (mock *MoqCmdable) ResetBFInfoSizeCalls() {
	mock.lockBFInfoSize.Lock()
	mock.calls.BFInfoSize = nil
	mock.lockBFInfoSize.Unlock()
}

// BFInsert calls BFInsertFunc.
func (mock *MoqCmdable) BFInsert(ctx context.Context, key string, options *redis.BFInsertOptions, elements ...interface{}) *redis.BoolSliceCmd {
	if mock.BFInsertFunc == nil {
		panic("MoqCmdable.BFInsertFunc: method is nil but Cmdable.BFInsert was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Key      string
		Options  *redis.BFInsertOptions
		Elements []interface{}
	}{
		Ctx:      ctx,
		Key:      key,
		Options:  options,
		Elements: elements,
	}
	mock.lockBFInsert.Lock()
	mock.calls.BFInsert = append(mock.calls.BFInsert, callInfo)
	mock.lockBFInsert.Unlock()
	return mock.BFInsertFunc(ctx, key, options, elements...)
}

// BFInsertCalls gets all the calls that were made to BFInsert.
// Check the length with:
//
//	len(mockedCmdable.BFInsertCalls())
func (mock *MoqCmdable) BFInsertCalls() []struct {
	Ctx      context.Context
	Key      string
	Options  *redis.BFInsertOptions
	Elements []interface{}
} {
	var calls []struct {
		Ctx      context.Context
		Key      string
		Options  *redis.BFInsertOptions
		Elements []interface{}
	}
	mock.lockBFInsert.RLock()
	calls = mock.calls.BFInsert
	mock.lockBFInsert.RUnlock()
	return calls
}

// ResetBFInsertCalls reset all the calls that were made to BFInsert.
func (mock *MoqCmdable) ResetBFInsertCalls() {
	mock.lockBFInsert.Lock()
	mock.calls.BFInsert = nil
	mock.lockBFInsert.Unlock()
}

// BFLoadChunk calls BFLoadChunkFunc.
func (mock *MoqCmdable) BFLoadChunk(ctx context.Context, key string, iterator int64, data interface{}) *redis.StatusCmd {
	if mock.BFLoadChunkFunc == nil {
		panic("MoqCmdable.BFLoadChunkFunc: method is nil but Cmdable.BFLoadChunk was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Key      string
		Iterator int64
		Data     interface{}
	}{
		Ctx:      ctx,
		Key:      key,
		Iterator: iterator,
		Data:     data,
	}
	mock.lockBFLoadChunk.Lock()
	mock.calls.BFLoadChunk = append(mock.calls.BFLoadChunk, callInfo)
	mock.lockBFLoadChunk.Unlock()
	return mock.BFLoadChunkFunc(ctx, key, iterator, data)
}

// BFLoadChunkCalls gets all the calls that were made to BFLoadChunk.
// Check the length with:
//
//	len(mockedCmdable.BFLoadChunkCalls())
func (mock *MoqCmdable) BFLoadChunkCalls() []struct {
	Ctx      context.Context
	Key      string
	Iterator int64
	Data     interface{}
} {
	var calls []struct {
		Ctx      context.Context
		Key      string
		Iterator int64
		Data     interface{}
	}
	mock.lockBFLoadChunk.RLock()
	calls = mock.calls.BFLoadChunk
	mock.lockBFLoadChunk.RUnlock()
	return calls
}

// ResetBFLoadChunkCalls reset all the calls that were made to BFLoadChunk.
func (mock *MoqCmdable) ResetBFLoadChunkCalls() {
	mock.lockBFLoadChunk.Lock()
	mock.calls.BFLoadChunk = nil
	mock.lockBFLoadChunk.Unlock()
}

// BFMAdd calls BFMAddFunc.
func (mock *MoqCmdable) BFMAdd(ctx context.Context, key string, elements ...interface{}) *redis.BoolSliceCmd {
	if mock.BFMAddFunc == nil {
		panic("MoqCmdable.BFMAddFunc: method is nil but Cmdable.BFMAdd was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Key      string
		Elements []interface{}
	}{
		Ctx:      ctx,
		Key:      key,
		Elements: elements,
	}
	mock.lockBFMAdd.Lock()
	mock.calls.BFMAdd = append(mock.calls.BFMAdd, callInfo)
	mock.lockBFMAdd.Unlock()
	return mock.BFMAddFunc(ctx, key, elements...)
}

// BFMAddCalls gets all the calls that were made to BFMAdd.
// Check the length with:
//
//	len(mockedCmdable.BFMAddCalls())
func (mock *MoqCmdable) BFMAddCalls() []struct {
	Ctx      context.Context
	Key      string
	Elements []interface{}
} {
	var calls []struct {
		Ctx      context.Context
		Key      string
		Elements []interface{}
	}
	mock.lockBFMAdd.RLock()
	calls = mock.calls.BFMAdd
	mock.lockBFMAdd.RUnlock()
	return calls
}

// ResetBFMAddCalls reset all the calls that were made to BFMAdd.
func (mock *MoqCmdable) ResetBFMAddCalls() {
	mock.lockBFMAdd.Lock()
	mock.calls.BFMAdd = nil
	mock.lockBFMAdd.Unlock()
}

// BFMExists calls BFMExistsFunc.
func (mock *MoqCmdable) BFMExists(ctx context.Context, key string, elements ...interface{}) *redis.BoolSliceCmd {
	if mock.BFMExistsFunc == nil {
		panic("MoqCmdable.BFMExistsFunc: method is nil but Cmdable.BFMExists was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Key      string
		Elements []interface{}
	}{
		Ctx:      ctx,
		Key:      key,
		Elements: elements,
	}
	mock.lockBFMExists.Lock()
	mock.calls.BFMExists = append(mock.calls.BFMExists, callInfo)
	mock.lockBFMExists.Unlock()
	return mock.BFMExistsFunc(ctx, key, elements...)
}

// BFMExistsCalls gets all the calls that were made to BFMExists.
// Check the length with:
//
//	len(mockedCmdable.BFMExistsCalls())
func (mock *MoqCmdable) BFMExistsCalls() []struct {
	Ctx      context.Context
	Key      string
	Elements []interface{}
} {
	var calls []struct {
		Ctx      context.Context
		Key      string
		Elements []interface{}
	}
	mock.lockBFMExists.RLock()
	calls = mock.calls.BFMExists
	mock.lockBFMExists.RUnlock()
	return calls
}

// ResetBFMExistsCalls reset all the calls that were made to BFMExists.
func (mock *MoqCmdable) ResetBFMExistsCalls() {
	mock.lockBFMExists.Lock()
	mock.calls.BFMExists = nil
	mock.lockBFMExists.Unlock()
}

// BFReserve calls BFReserveFunc.
func (mock *MoqCmdable) BFReserve(ctx context.Context, key string, errorRate float64, capacity int64) *redis.StatusCmd {
	if mock.BFReserveFunc == nil {
		panic("MoqCmdable.BFReserveFunc: method is nil but Cmdable.BFReserve was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Key       string
		ErrorRate float64
		Capacity  int64
	}{
		Ctx:       ctx,
		Key:       key,
		ErrorRate: errorRate,
		Capacity:  capacity,
	}
	mock.lockBFReserve.Lock()
	mock.calls.BFReserve = append(mock.calls.BFReserve, callInfo)
	mock.lockBFReserve.Unlock()
	return mock.BFReserveFunc(ctx, key, errorRate, capacity)
}

// BFReserveCalls gets all the calls that were made to BFReserve.
// Check the length with:
//
//	len(mockedCmdable.BFReserveCalls())
func (mock *MoqCmdable) BFReserveCalls() []struct {
	Ctx       context.Context
	Key       string
	ErrorRate float64
	Capacity  int64
} {
	var calls []struct {
		Ctx       context.Context
		Key       string
		ErrorRate float64
		Capacity  int64
	}
	mock.lockBFReserve.RLock()
	calls = mock.calls.BFReserve
	mock.lockBFReserve.RUnlock()
	return calls
}

// ResetBFReserveCalls reset all the calls that were made to BFReserve.
func (mock *MoqCmdable) ResetBFReserveCalls() {
	mock.lockBFReserve.Lock()
	mock.calls.BFReserve = nil
	mock.lockBFReserve.Unlock()
}

// BFReserveExpansion calls BFReserveExpansionFunc.
func (mock *MoqCmdable) BFReserveExpansion(ctx context.Context, key string, errorRate float64, capacity int64, expansion int64) *redis.StatusCmd {
	if mock.BFReserveExpansionFunc == nil {
		panic("MoqCmdable.BFReserveExpansionFunc: method is nil but Cmdable.BFReserveExpansion was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Key       string
		ErrorRate float64
		Capacity  int64
		Expansion int64
	}{
		Ctx:       ctx,
		Key:       key,
		ErrorRate: errorRate,
		Capacity:  capacity,
		Expansion: expansion,
	}
	mock.lockBFReserveExpansion.Lock()
	mock.calls.BFReserveExpansion = append(mock.calls.BFReserveExpansion, callInfo)
	mock.lockBFReserveExpansion.Unlock()
	return mock.BFReserveExpansionFunc(ctx, key, errorRate, capacity, expansion)
}

// BFReserveExpansionCalls gets all the calls that were made to BFReserveExpansion.
// Check the length with:
//
//	len(mockedCmdable.BFReserveExpansionCalls())
func (mock *MoqCmdable) BFReserveExpansionCalls() []struct {
	Ctx       context.Context
	Key       string
	ErrorRate float64
	Capacity  int64
	Expansion int64
} {
	var calls []struct {
		Ctx       context.Context
		Key       string
		ErrorRate float64
		Capacity  int64
		Expansion int64
	}
	mock.lockBFReserveExpansion.RLock()
	calls = mock.calls.BFReserveExpansion
	mock.lockBFReserveExpansion.RUnlock()
	return calls
}

// ResetBFReserveExpansionCalls reset all the calls that were made to BFReserveExpansion.
func (mock *MoqCmdable) ResetBFReserveExpansionCalls() {
	mock.lockBFReserveExpansion.Lock()
	mock.calls.BFReserveExpansion = nil
	mock.lockBFReserveExpansion.Unlock()
}

// BFReserveNonScaling calls BFReserveNonScalingFunc.
func (mock *MoqCmdable) BFReserveNonScaling(ctx context.Context, key string, errorRate float64, capacity int64) *redis.StatusCmd {
	if mock.BFReserveNonScalingFunc == nil {
		panic("MoqCmdable.BFReserveNonScalingFunc: method is nil but Cmdable.BFReserveNonScaling was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Key       string
		ErrorRate float64
		Capacity  int64
	}{
		Ctx:       ctx,
		Key:       key,
		ErrorRate: errorRate,
		Capacity:  capacity,
	}
	mock.lockBFReserveNonScaling.Lock()
	mock.calls.BFReserveNonScaling = append(mock.calls.BFReserveNonScaling, callInfo)
	mock.lockBFReserveNonScaling.Unlock()
	return mock.BFReserveNonScalingFunc(ctx, key, errorRate, capacity)
}

// BFReserveNonScalingCalls gets all the calls that were made to BFReserveNonScaling.
// Check the length with:
//
//	len(mockedCmdable.BFReserveNonScalingCalls())
func (mock *MoqCmdable) BFReserveNonScalingCalls() []struct {
	Ctx       context.Context
	Key       string
	ErrorRate float64
	Capacity  int64
} {
	var calls []struct {
		Ctx       context.Context
		Key       string
		ErrorRate float64
		Capacity  int64
	}
	mock.lockBFReserveNonScaling.RLock()
	calls = mock.calls.BFReserveNonScaling
	mock.lockBFReserveNonScaling.RUnlock()
	return calls
}

// ResetBFReserveNonScalingCalls reset all the calls that were made to BFReserveNonScaling.
func (mock *MoqCmdable) ResetBFReserveNonScalingCalls() {
	mock.lockBFReserveNonScaling.Lock()
	mock.calls.BFReserveNonScaling = nil
	mock.lockBFReserveNonScaling.Unlock()
}

// BFReserveWithArgs calls BFReserveWithArgsFunc.
func (mock *MoqCmdable) BFReserveWithArgs(ctx context.Context, key string, options *redis.BFReserveOptions) *redis.StatusCmd {
	if mock.BFReserveWithArgsFunc == nil {
		panic("MoqCmdable.BFReserveWithArgsFunc: method is nil but Cmdable.BFReserveWithArgs was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Key     string
		Options *redis.BFReserveOptions
	}{
		Ctx:     ctx,
		Key:     key,
		Options: options,
	}
	mock.lockBFReserveWithArgs.Lock()
	mock.calls.BFReserveWithArgs = append(mock.calls.BFReserveWithArgs, callInfo)
	mock.lockBFReserveWithArgs.Unlock()
	return mock.BFReserveWithArgsFunc(ctx, key, options)
}

// BFReserveWithArgsCalls gets all the calls that were made to BFReserveWithArgs.
// Check the length with:
//
//	len(mockedCmdable.BFReserveWithArgsCalls())
func (mock *MoqCmdable) BFReserveWithArgsCalls() []struct {
	Ctx     context.Context
	Key     string
	Options *redis.BFReserveOptions
} {
	var calls []struct {
		Ctx     context.Context
		Key     string
		Options *redis.BFReserveOptions
	}
	mock.lockBFReserveWithArgs.RLock()
	calls = mock.calls.BFReserveWithArgs
	mock.lockBFReserveWithArgs.RUnlock()
	return calls
}

// ResetBFReserveWithArgsCalls reset all the calls that were made to BFReserveWithArgs.
func (mock *MoqCmdable) ResetBFReserveWithArgsCalls() {
	mock.lockBFReserveWithArgs.Lock()
	mock.calls.BFReserveWithArgs = nil
	mock.lockBFReserveWithArgs.Unlock()
}

// BFScanDump calls BFScanDumpFunc.
func (mock *MoqCmdable) BFScanDump(ctx context.Context, key string, iterator int64) *redis.ScanDumpCmd {
	if mock.BFScanDumpFunc == nil {
		panic("MoqCmdable.BFScanDumpFunc: method is nil but Cmdable.BFScanDump was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Key      string
		Iterator int64
	}{
		Ctx:      ctx,
		Key:      key,
		Iterator: iterator,
	}
	mock.lockBFScanDump.Lock()
	mock.calls.BFScanDump = append(mock.calls.BFScanDump, callInfo)
	mock.lockBFScanDump.Unlock()
	return mock.BFScanDumpFunc(ctx, key, iterator)
}

// BFScanDumpCalls gets all the calls that were made to BFScanDump.
// Check the length with:
//
//	len(mockedCmdable.BFScanDumpCalls())
func (mock *MoqCmdable) BFScanDumpCalls() []struct {
	Ctx      context.Context
	Key      string
	Iterator int64
} {
	var calls []struct {
		Ctx      context.Context
		Key      string
		Iterator int64
	}
	mock.lockBFScanDump.RLock()
	calls = mock.calls.BFScanDump
	mock.lockBFScanDump.RUnlock()
	return calls
}

// ResetBFScanDumpCalls reset all the calls that were made to BFScanDump.
func (mock *MoqCmdable) ResetBFScanDumpCalls() {
	mock.lockBFScanDump.Lock()
	mock.calls.BFScanDump = nil
	mock.lockBFScanDump.Unlock()
}

// BLMPop calls BLMPopFunc.
func (mock *MoqCmdable) BLMPop(ctx context.Context, timeout time.Duration, direction string, count int64, keys ...string) *redis.KeyValuesCmd {
	if mock.BLMPopFunc == nil {
		panic("MoqCmdable.BLMPopFunc: method is nil but Cmdable.BLMPop was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Timeout   time.Duration
		Direction string
		Count     int64
		Keys      []string
	}{
		Ctx:       ctx,
		Timeout:   timeout,
		Direction: direction,
		Count:     count,
		Keys:      keys,
	}
	mock.lockBLMPop.Lock()
	mock.calls.BLMPop = append(mock.calls.BLMPop, callInfo)
	mock.lockBLMPop.Unlock()
	return mock.BLMPopFunc(ctx, timeout, direction, count, keys...)
}

// BLMPopCalls gets all the calls that were made to BLMPop.
// Check the length with:
//
//	len(mockedCmdable.BLMPopCalls())
func (mock *MoqCmdable) BLMPopCalls() []struct {
	Ctx       context.Context
	Timeout   time.Duration
	Direction string
	Count     int64
	Keys      []string
} {
	var calls []struct {
		Ctx       context.Context
		Timeout   time.Duration
		Direction string
		Count     int64
		Keys      []string
	}
	mock.lockBLMPop.RLock()
	calls = mock.calls.BLMPop
	mock.lockBLMPop.RUnlock()
	return calls
}

// ResetBLMPopCalls reset all the calls that were made to BLMPop.
func (mock *MoqCmdable) ResetBLMPopCalls() {
	mock.lockBLMPop.Lock()
	mock.calls.BLMPop = nil
	mock.lockBLMPop.Unlock()
}

// BLMove calls BLMoveFunc.
func (mock *MoqCmdable) BLMove(ctx context.Context, source string, destination string, srcpos string, destpos string, timeout time.Duration) *redis.StringCmd {
	if mock.BLMoveFunc == nil {
		panic("MoqCmdable.BLMoveFunc: method is nil but Cmdable.BLMove was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		Source      string
		Destination string
		Srcpos      string
		Destpos     string
		Timeout     time.Duration
	}{
		Ctx:         ctx,
		Source:      source,
		Destination: destination,
		Srcpos:      srcpos,
		Destpos:     destpos,
		Timeout:     timeout,
	}
	mock.lockBLMove.Lock()
	mock.calls.BLMove = append(mock.calls.BLMove, callInfo)
	mock.lockBLMove.Unlock()
	return mock.BLMoveFunc(ctx, source, destination, srcpos, destpos, timeout)
}

// BLMoveCalls gets all the calls that were made to BLMove.
// Check the length with:
//
//	len(mockedCmdable.BLMoveCalls())
func (mock *MoqCmdable) BLMoveCalls() []struct {
	Ctx         context.Context
	Source      string
	Destination string
	Srcpos      string
	Destpos     string
	Timeout     time.Duration
} {
	var calls []struct {
		Ctx         context.Context
		Source      string
		Destination string
		Srcpos      string
		Destpos     string
		Timeout     time.Duration
	}
	mock.lockBLMove.RLock()
	calls = mock.calls.BLMove
	mock.lockBLMove.RUnlock()
	return calls
}

// ResetBLMoveCalls reset all the calls that were made to BLMove.
func (mock *MoqCmdable) ResetBLMoveCalls() {
	mock.lockBLMove.Lock()
	mock.calls.BLMove = nil
	mock.lockBLMove.Unlock()
}

// BLPop calls BLPopFunc.
func (mock *MoqCmdable) BLPop(ctx context.Context, timeout time.Duration, keys ...string) *redis.StringSliceCmd {
	if mock.BLPopFunc == nil {
		panic("MoqCmdable.BLPopFunc: method is nil but Cmdable.BLPop was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Timeout time.Duration
		Keys    []string
	}{
		Ctx:     ctx,
		Timeout: timeout,
		Keys:    keys,
	}
	mock.lockBLPop.Lock()
	mock.calls.BLPop = append(mock.calls.BLPop, callInfo)
	mock.lockBLPop.Unlock()
	return mock.BLPopFunc(ctx, timeout, keys...)
}

// BLPopCalls gets all the calls that were made to BLPop.
// Check the length with:
//
//	len(mockedCmdable.BLPopCalls())
func (mock *MoqCmdable) BLPopCalls() []struct {
	Ctx     context.Context
	Timeout time.Duration
	Keys    []string
} {
	var calls []struct {
		Ctx     context.Context
		Timeout time.Duration
		Keys    []string
	}
	mock.lockBLPop.RLock()
	calls = mock.calls.BLPop
	mock.lockBLPop.RUnlock()
	return calls
}

// ResetBLPopCalls reset all the calls that were made to BLPop.
func (mock *MoqCmdable) ResetBLPopCalls() {
	mock.lockBLPop.Lock()
	mock.calls.BLPop = nil
	mock.lockBLPop.Unlock()
}

// BRPop calls BRPopFunc.
func (mock *MoqCmdable) BRPop(ctx context.Context, timeout time.Duration, keys ...string) *redis.StringSliceCmd {
	if mock.BRPopFunc == nil {
		panic("MoqCmdable.BRPopFunc: method is nil but Cmdable.BRPop was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Timeout time.Duration
		Keys    []string
	}{
		Ctx:     ctx,
		Timeout: timeout,
		Keys:    keys,
	}
	mock.lockBRPop.Lock()
	mock.calls.BRPop = append(mock.calls.BRPop, callInfo)
	mock.lockBRPop.Unlock()
	return mock.BRPopFunc(ctx, timeout, keys...)
}

// BRPopCalls gets all the calls that were made to BRPop.
// Check the length with:
//
//	len(mockedCmdable.BRPopCalls())
func (mock *MoqCmdable) BRPopCalls() []struct {
	Ctx     context.Context
	Timeout time.Duration
	Keys    []string
} {
	var calls []struct {
		Ctx     context.Context
		Timeout time.Duration
		Keys    []string
	}
	mock.lockBRPop.RLock()
	calls = mock.calls.BRPop
	mock.lockBRPop.RUnlock()
	return calls
}

// ResetBRPopCalls reset all the calls that were made to BRPop.
func (mock *MoqCmdable) ResetBRPopCalls() {
	mock.lockBRPop.Lock()
	mock.calls.BRPop = nil
	mock.lockBRPop.Unlock()
}

// BRPopLPush calls BRPopLPushFunc.
func (mock *MoqCmdable) BRPopLPush(ctx context.Context, source string, destination string, timeout time.Duration) *redis.StringCmd {
	if mock.BRPopLPushFunc == nil {
		panic("MoqCmdable.BRPopLPushFunc: method is nil but Cmdable.BRPopLPush was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		Source      string
		Destination string
		Timeout     time.Duration
	}{
		Ctx:         ctx,
		Source:      source,
		Destination: destination,
		Timeout:     timeout,
	}
	mock.lockBRPopLPush.Lock()
	mock.calls.BRPopLPush = append(mock.calls.BRPopLPush, callInfo)
	mock.lockBRPopLPush.Unlock()
	return mock.BRPopLPushFunc(ctx, source, destination, timeout)
}

// BRPopLPushCalls gets all the calls that were made to BRPopLPush.
// Check the length with:
//
//	len(mockedCmdable.BRPopLPushCalls())
func (mock *MoqCmdable) BRPopLPushCalls() []struct {
	Ctx         context.Context
	Source      string
	Destination string
	Timeout     time.Duration
} {
	var calls []struct {
		Ctx         context.Context
		Source      string
		Destination string
		Timeout     time.Duration
	}
	mock.lockBRPopLPush.RLock()
	calls = mock.calls.BRPopLPush
	mock.lockBRPopLPush.RUnlock()
	return calls
}

// ResetBRPopLPushCalls reset all the calls that were made to BRPopLPush.
func (mock *MoqCmdable) ResetBRPopLPushCalls() {
	mock.lockBRPopLPush.Lock()
	mock.calls.BRPopLPush = nil
	mock.lockBRPopLPush.Unlock()
}

// BZMPop calls BZMPopFunc.
func (mock *MoqCmdable) BZMPop(ctx context.Context, timeout time.Duration, order string, count int64, keys ...string) *redis.ZSliceWithKeyCmd {
	if mock.BZMPopFunc == nil {
		panic("MoqCmdable.BZMPopFunc: method is nil but Cmdable.BZMPop was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Timeout time.Duration
		Order   string
		Count   int64
		Keys    []string
	}{
		Ctx:     ctx,
		Timeout: timeout,
		Order:   order,
		Count:   count,
		Keys:    keys,
	}
	mock.lockBZMPop.Lock()
	mock.calls.BZMPop = append(mock.calls.BZMPop, callInfo)
	mock.lockBZMPop.Unlock()
	return mock.BZMPopFunc(ctx, timeout, order, count, keys...)
}

// BZMPopCalls gets all the calls that were made to BZMPop.
// Check the length with:
//
//	len(mockedCmdable.BZMPopCalls())
func (mock *MoqCmdable) BZMPopCalls() []struct {
	Ctx     context.Context
	Timeout time.Duration
	Order   string
	Count   int64
	Keys    []string
} {
	var calls []struct {
		Ctx     context.Context
		Timeout time.Duration
		Order   string
		Count   int64
		Keys    []string
	}
	mock.lockBZMPop.RLock()
	calls = mock.calls.BZMPop
	mock.lockBZMPop.RUnlock()
	return calls
}

// ResetBZMPopCalls reset all the calls that were made to BZMPop.
func (mock *MoqCmdable) ResetBZMPopCalls() {
	mock.lockBZMPop.Lock()
	mock.calls.BZMPop = nil
	mock.lockBZMPop.Unlock()
}

// BZPopMax calls BZPopMaxFunc.
func (mock *MoqCmdable) BZPopMax(ctx context.Context, timeout time.Duration, keys ...string) *redis.ZWithKeyCmd {
	if mock.BZPopMaxFunc == nil {
		panic("MoqCmdable.BZPopMaxFunc: method is nil but Cmdable.BZPopMax was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Timeout time.Duration
		Keys    []string
	}{
		Ctx:     ctx,
		Timeout: timeout,
		Keys:    keys,
	}
	mock.lockBZPopMax.Lock()
	mock.calls.BZPopMax = append(mock.calls.BZPopMax, callInfo)
	mock.lockBZPopMax.Unlock()
	return mock.BZPopMaxFunc(ctx, timeout, keys...)
}

// BZPopMaxCalls gets all the calls that were made to BZPopMax.
// Check the length with:
//
//	len(mockedCmdable.BZPopMaxCalls())
func (mock *MoqCmdable) BZPopMaxCalls() []struct {
	Ctx     context.Context
	Timeout time.Duration
	Keys    []string
} {
	var calls []struct {
		Ctx     context.Context
		Timeout time.Duration
		Keys    []string
	}
	mock.lockBZPopMax.RLock()
	calls = mock.calls.BZPopMax
	mock.lockBZPopMax.RUnlock()
	return calls
}

// ResetBZPopMaxCalls reset all the calls that were made to BZPopMax.
func (mock *MoqCmdable) ResetBZPopMaxCalls() {
	mock.lockBZPopMax.Lock()
	mock.calls.BZPopMax = nil
	mock.lockBZPopMax.Unlock()
}

// BZPopMin calls BZPopMinFunc.
func (mock *MoqCmdable) BZPopMin(ctx context.Context, timeout time.Duration, keys ...string) *redis.ZWithKeyCmd {
	if mock.BZPopMinFunc == nil {
		panic("MoqCmdable.BZPopMinFunc: method is nil but Cmdable.BZPopMin was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Timeout time.Duration
		Keys    []string
	}{
		Ctx:     ctx,
		Timeout: timeout,
		Keys:    keys,
	}
	mock.lockBZPopMin.Lock()
	mock.calls.BZPopMin = append(mock.calls.BZPopMin, callInfo)
	mock.lockBZPopMin.Unlock()
	return mock.BZPopMinFunc(ctx, timeout, keys...)
}

// BZPopMinCalls gets all the calls that were made to BZPopMin.
// Check the length with:
//
//	len(mockedCmdable.BZPopMinCalls())
func (mock *MoqCmdable) BZPopMinCalls() []struct {
	Ctx     context.Context
	Timeout time.Duration
	Keys    []string
} {
	var calls []struct {
		Ctx     context.Context
		Timeout time.Duration
		Keys    []string
	}
	mock.lockBZPopMin.RLock()
	calls = mock.calls.BZPopMin
	mock.lockBZPopMin.RUnlock()
	return calls
}

// ResetBZPopMinCalls reset all the calls that were made to BZPopMin.
func (mock *MoqCmdable) ResetBZPopMinCalls() {
	mock.lockBZPopMin.Lock()
	mock.calls.BZPopMin = nil
	mock.lockBZPopMin.Unlock()
}

// BgRewriteAOF calls BgRewriteAOFFunc.
func (mock *MoqCmdable) BgRewriteAOF(ctx context.Context) *redis.StatusCmd {
	if mock.BgRewriteAOFFunc == nil {
		panic("MoqCmdable.BgRewriteAOFFunc: method is nil but Cmdable.BgRewriteAOF was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockBgRewriteAOF.Lock()
	mock.calls.BgRewriteAOF = append(mock.calls.BgRewriteAOF, callInfo)
	mock.lockBgRewriteAOF.Unlock()
	return mock.BgRewriteAOFFunc(ctx)
}

// BgRewriteAOFCalls gets all the calls that were made to BgRewriteAOF.
// Check the length with:
//
//	len(mockedCmdable.BgRewriteAOFCalls())
func (mock *MoqCmdable) BgRewriteAOFCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockBgRewriteAOF.RLock()
	calls = mock.calls.BgRewriteAOF
	mock.lockBgRewriteAOF.RUnlock()
	return calls
}

// ResetBgRewriteAOFCalls reset all the calls that were made to BgRewriteAOF.
func (mock *MoqCmdable) ResetBgRewriteAOFCalls() {
	mock.lockBgRewriteAOF.Lock()
	mock.calls.BgRewriteAOF = nil
	mock.lockBgRewriteAOF.Unlock()
}

// BgSave calls BgSaveFunc.
func (mock *MoqCmdable) BgSave(ctx context.Context) *redis.StatusCmd {
	if mock.BgSaveFunc == nil {
		panic("MoqCmdable.BgSaveFunc: method is nil but Cmdable.BgSave was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockBgSave.Lock()
	mock.calls.BgSave = append(mock.calls.BgSave, callInfo)
	mock.lockBgSave.Unlock()
	return mock.BgSaveFunc(ctx)
}

// BgSaveCalls gets all the calls that were made to BgSave.
// Check the length with:
//
//	len(mockedCmdable.BgSaveCalls())
func (mock *MoqCmdable) BgSaveCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockBgSave.RLock()
	calls = mock.calls.BgSave
	mock.lockBgSave.RUnlock()
	return calls
}

// ResetBgSaveCalls reset all the calls that were made to BgSave.
func (mock *MoqCmdable) ResetBgSaveCalls() {
	mock.lockBgSave.Lock()
	mock.calls.BgSave = nil
	mock.lockBgSave.Unlock()
}

// BitCount calls BitCountFunc.
func (mock *MoqCmdable) BitCount(ctx context.Context, key string, bitCount *redis.BitCount) *redis.IntCmd {
	if mock.BitCountFunc == nil {
		panic("MoqCmdable.BitCountFunc: method is nil but Cmdable.BitCount was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Key      string
		BitCount *redis.BitCount
	}{
		Ctx:      ctx,
		Key:      key,
		BitCount: bitCount,
	}
	mock.lockBitCount.Lock()
	mock.calls.BitCount = append(mock.calls.BitCount, callInfo)
	mock.lockBitCount.Unlock()
	return mock.BitCountFunc(ctx, key, bitCount)
}

// BitCountCalls gets all the calls that were made to BitCount.
// Check the length with:
//
//	len(mockedCmdable.BitCountCalls())
func (mock *MoqCmdable) BitCountCalls() []struct {
	Ctx      context.Context
	Key      string
	BitCount *redis.BitCount
} {
	var calls []struct {
		Ctx      context.Context
		Key      string
		BitCount *redis.BitCount
	}
	mock.lockBitCount.RLock()
	calls = mock.calls.BitCount
	mock.lockBitCount.RUnlock()
	return calls
}

// ResetBitCountCalls reset all the calls that were made to BitCount.
func (mock *MoqCmdable) ResetBitCountCalls() {
	mock.lockBitCount.Lock()
	mock.calls.BitCount = nil
	mock.lockBitCount.Unlock()
}

// BitField calls BitFieldFunc.
func (mock *MoqCmdable) BitField(ctx context.Context, key string, values ...interface{}) *redis.IntSliceCmd {
	if mock.BitFieldFunc == nil {
		panic("MoqCmdable.BitFieldFunc: method is nil but Cmdable.BitField was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		Values []interface{}
	}{
		Ctx:    ctx,
		Key:    key,
		Values: values,
	}
	mock.lockBitField.Lock()
	mock.calls.BitField = append(mock.calls.BitField, callInfo)
	mock.lockBitField.Unlock()
	return mock.BitFieldFunc(ctx, key, values...)
}

// BitFieldCalls gets all the calls that were made to BitField.
// Check the length with:
//
//	len(mockedCmdable.BitFieldCalls())
func (mock *MoqCmdable) BitFieldCalls() []struct {
	Ctx    context.Context
	Key    string
	Values []interface{}
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		Values []interface{}
	}
	mock.lockBitField.RLock()
	calls = mock.calls.BitField
	mock.lockBitField.RUnlock()
	return calls
}

// ResetBitFieldCalls reset all the calls that were made to BitField.
func (mock *MoqCmdable) ResetBitFieldCalls() {
	mock.lockBitField.Lock()
	mock.calls.BitField = nil
	mock.lockBitField.Unlock()
}

// BitFieldRO calls BitFieldROFunc.
func (mock *MoqCmdable) BitFieldRO(ctx context.Context, key string, values ...interface{}) *redis.IntSliceCmd {
	if mock.BitFieldROFunc == nil {
		panic("MoqCmdable.BitFieldROFunc: method is nil but Cmdable.BitFieldRO was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		Values []interface{}
	}{
		Ctx:    ctx,
		Key:    key,
		Values: values,
	}
	mock.lockBitFieldRO.Lock()
	mock.calls.BitFieldRO = append(mock.calls.BitFieldRO, callInfo)
	mock.lockBitFieldRO.Unlock()
	return mock.BitFieldROFunc(ctx, key, values...)
}

// BitFieldROCalls gets all the calls that were made to BitFieldRO.
// Check the length with:
//
//	len(mockedCmdable.BitFieldROCalls())
func (mock *MoqCmdable) BitFieldROCalls() []struct {
	Ctx    context.Context
	Key    string
	Values []interface{}
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		Values []interface{}
	}
	mock.lockBitFieldRO.RLock()
	calls = mock.calls.BitFieldRO
	mock.lockBitFieldRO.RUnlock()
	return calls
}

// ResetBitFieldROCalls reset all the calls that were made to BitFieldRO.
func (mock *MoqCmdable) ResetBitFieldROCalls() {
	mock.lockBitFieldRO.Lock()
	mock.calls.BitFieldRO = nil
	mock.lockBitFieldRO.Unlock()
}

// BitOpAnd calls BitOpAndFunc.
func (mock *MoqCmdable) BitOpAnd(ctx context.Context, destKey string, keys ...string) *redis.IntCmd {
	if mock.BitOpAndFunc == nil {
		panic("MoqCmdable.BitOpAndFunc: method is nil but Cmdable.BitOpAnd was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		DestKey string
		Keys    []string
	}{
		Ctx:     ctx,
		DestKey: destKey,
		Keys:    keys,
	}
	mock.lockBitOpAnd.Lock()
	mock.calls.BitOpAnd = append(mock.calls.BitOpAnd, callInfo)
	mock.lockBitOpAnd.Unlock()
	return mock.BitOpAndFunc(ctx, destKey, keys...)
}

// BitOpAndCalls gets all the calls that were made to BitOpAnd.
// Check the length with:
//
//	len(mockedCmdable.BitOpAndCalls())
func (mock *MoqCmdable) BitOpAndCalls() []struct {
	Ctx     context.Context
	DestKey string
	Keys    []string
} {
	var calls []struct {
		Ctx     context.Context
		DestKey string
		Keys    []string
	}
	mock.lockBitOpAnd.RLock()
	calls = mock.calls.BitOpAnd
	mock.lockBitOpAnd.RUnlock()
	return calls
}

// ResetBitOpAndCalls reset all the calls that were made to BitOpAnd.
func (mock *MoqCmdable) ResetBitOpAndCalls() {
	mock.lockBitOpAnd.Lock()
	mock.calls.BitOpAnd = nil
	mock.lockBitOpAnd.Unlock()
}

// BitOpAndOr calls BitOpAndOrFunc.
func (mock *MoqCmdable) BitOpAndOr(ctx context.Context, destKey string, keys ...string) *redis.IntCmd {
	if mock.BitOpAndOrFunc == nil {
		panic("MoqCmdable.BitOpAndOrFunc: method is nil but Cmdable.BitOpAndOr was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		DestKey string
		Keys    []string
	}{
		Ctx:     ctx,
		DestKey: destKey,
		Keys:    keys,
	}
	mock.lockBitOpAndOr.Lock()
	mock.calls.BitOpAndOr = append(mock.calls.BitOpAndOr, callInfo)
	mock.lockBitOpAndOr.Unlock()
	return mock.BitOpAndOrFunc(ctx, destKey, keys...)
}

// BitOpAndOrCalls gets all the calls that were made to BitOpAndOr.
// Check the length with:
//
//	len(mockedCmdable.BitOpAndOrCalls())
func (mock *MoqCmdable) BitOpAndOrCalls() []struct {
	Ctx     context.Context
	DestKey string
	Keys    []string
} {
	var calls []struct {
		Ctx     context.Context
		DestKey string
		Keys    []string
	}
	mock.lockBitOpAndOr.RLock()
	calls = mock.calls.BitOpAndOr
	mock.lockBitOpAndOr.RUnlock()
	return calls
}

// ResetBitOpAndOrCalls reset all the calls that were made to BitOpAndOr.
func (mock *MoqCmdable) ResetBitOpAndOrCalls() {
	mock.lockBitOpAndOr.Lock()
	mock.calls.BitOpAndOr = nil
	mock.lockBitOpAndOr.Unlock()
}

// BitOpDiff calls BitOpDiffFunc.
func (mock *MoqCmdable) BitOpDiff(ctx context.Context, destKey string, keys ...string) *redis.IntCmd {
	if mock.BitOpDiffFunc == nil {
		panic("MoqCmdable.BitOpDiffFunc: method is nil but Cmdable.BitOpDiff was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		DestKey string
		Keys    []string
	}{
		Ctx:     ctx,
		DestKey: destKey,
		Keys:    keys,
	}
	mock.lockBitOpDiff.Lock()
	mock.calls.BitOpDiff = append(mock.calls.BitOpDiff, callInfo)
	mock.lockBitOpDiff.Unlock()
	return mock.BitOpDiffFunc(ctx, destKey, keys...)
}

// BitOpDiffCalls gets all the calls that were made to BitOpDiff.
// Check the length with:
//
//	len(mockedCmdable.BitOpDiffCalls())
func (mock *MoqCmdable) BitOpDiffCalls() []struct {
	Ctx     context.Context
	DestKey string
	Keys    []string
} {
	var calls []struct {
		Ctx     context.Context
		DestKey string
		Keys    []string
	}
	mock.lockBitOpDiff.RLock()
	calls = mock.calls.BitOpDiff
	mock.lockBitOpDiff.RUnlock()
	return calls
}

// ResetBitOpDiffCalls reset all the calls that were made to BitOpDiff.
func (mock *MoqCmdable) ResetBitOpDiffCalls() {
	mock.lockBitOpDiff.Lock()
	mock.calls.BitOpDiff = nil
	mock.lockBitOpDiff.Unlock()
}

// BitOpDiff1 calls BitOpDiff1Func.
func (mock *MoqCmdable) BitOpDiff1(ctx context.Context, destKey string, keys ...string) *redis.IntCmd {
	if mock.BitOpDiff1Func == nil {
		panic("MoqCmdable.BitOpDiff1Func: method is nil but Cmdable.BitOpDiff1 was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		DestKey string
		Keys    []string
	}{
		Ctx:     ctx,
		DestKey: destKey,
		Keys:    keys,
	}
	mock.lockBitOpDiff1.Lock()
	mock.calls.BitOpDiff1 = append(mock.calls.BitOpDiff1, callInfo)
	mock.lockBitOpDiff1.Unlock()
	return mock.BitOpDiff1Func(ctx, destKey, keys...)
}

// BitOpDiff1Calls gets all the calls that were made to BitOpDiff1.
// Check the length with:
//
//	len(mockedCmdable.BitOpDiff1Calls())
func (mock *MoqCmdable) BitOpDiff1Calls() []struct {
	Ctx     context.Context
	DestKey string
	Keys    []string
} {
	var calls []struct {
		Ctx     context.Context
		DestKey string
		Keys    []string
	}
	mock.lockBitOpDiff1.RLock()
	calls = mock.calls.BitOpDiff1
	mock.lockBitOpDiff1.RUnlock()
	return calls
}

// ResetBitOpDiff1Calls reset all the calls that were made to BitOpDiff1.
func (mock *MoqCmdable) ResetBitOpDiff1Calls() {
	mock.lockBitOpDiff1.Lock()
	mock.calls.BitOpDiff1 = nil
	mock.lockBitOpDiff1.Unlock()
}

// BitOpNot calls BitOpNotFunc.
func (mock *MoqCmdable) BitOpNot(ctx context.Context, destKey string, key string) *redis.IntCmd {
	if mock.BitOpNotFunc == nil {
		panic("MoqCmdable.BitOpNotFunc: method is nil but Cmdable.BitOpNot was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		DestKey string
		Key     string
	}{
		Ctx:     ctx,
		DestKey: destKey,
		Key:     key,
	}
	mock.lockBitOpNot.Lock()
	mock.calls.BitOpNot = append(mock.calls.BitOpNot, callInfo)
	mock.lockBitOpNot.Unlock()
	return mock.BitOpNotFunc(ctx, destKey, key)
}

// BitOpNotCalls gets all the calls that were made to BitOpNot.
// Check the length with:
//
//	len(mockedCmdable.BitOpNotCalls())
func (mock *MoqCmdable) BitOpNotCalls() []struct {
	Ctx     context.Context
	DestKey string
	Key     string
} {
	var calls []struct {
		Ctx     context.Context
		DestKey string
		Key     string
	}
	mock.lockBitOpNot.RLock()
	calls = mock.calls.BitOpNot
	mock.lockBitOpNot.RUnlock()
	return calls
}

// ResetBitOpNotCalls reset all the calls that were made to BitOpNot.
func (mock *MoqCmdable) ResetBitOpNotCalls() {
	mock.lockBitOpNot.Lock()
	mock.calls.BitOpNot = nil
	mock.lockBitOpNot.Unlock()
}

// BitOpOne calls BitOpOneFunc.
func (mock *MoqCmdable) BitOpOne(ctx context.Context, destKey string, keys ...string) *redis.IntCmd {
	if mock.BitOpOneFunc == nil {
		panic("MoqCmdable.BitOpOneFunc: method is nil but Cmdable.BitOpOne was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		DestKey string
		Keys    []string
	}{
		Ctx:     ctx,
		DestKey: destKey,
		Keys:    keys,
	}
	mock.lockBitOpOne.Lock()
	mock.calls.BitOpOne = append(mock.calls.BitOpOne, callInfo)
	mock.lockBitOpOne.Unlock()
	return mock.BitOpOneFunc(ctx, destKey, keys...)
}

// BitOpOneCalls gets all the calls that were made to BitOpOne.
// Check the length with:
//
//	len(mockedCmdable.BitOpOneCalls())
func (mock *MoqCmdable) BitOpOneCalls() []struct {
	Ctx     context.Context
	DestKey string
	Keys    []string
} {
	var calls []struct {
		Ctx     context.Context
		DestKey string
		Keys    []string
	}
	mock.lockBitOpOne.RLock()
	calls = mock.calls.BitOpOne
	mock.lockBitOpOne.RUnlock()
	return calls
}

// ResetBitOpOneCalls reset all the calls that were made to BitOpOne.
func (mock *MoqCmdable) ResetBitOpOneCalls() {
	mock.lockBitOpOne.Lock()
	mock.calls.BitOpOne = nil
	mock.lockBitOpOne.Unlock()
}

// BitOpOr calls BitOpOrFunc.
func (mock *MoqCmdable) BitOpOr(ctx context.Context, destKey string, keys ...string) *redis.IntCmd {
	if mock.BitOpOrFunc == nil {
		panic("MoqCmdable.BitOpOrFunc: method is nil but Cmdable.BitOpOr was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		DestKey string
		Keys    []string
	}{
		Ctx:     ctx,
		DestKey: destKey,
		Keys:    keys,
	}
	mock.lockBitOpOr.Lock()
	mock.calls.BitOpOr = append(mock.calls.BitOpOr, callInfo)
	mock.lockBitOpOr.Unlock()
	return mock.BitOpOrFunc(ctx, destKey, keys...)
}

// BitOpOrCalls gets all the calls that were made to BitOpOr.
// Check the length with:
//
//	len(mockedCmdable.BitOpOrCalls())
func (mock *MoqCmdable) BitOpOrCalls() []struct {
	Ctx     context.Context
	DestKey string
	Keys    []string
} {
	var calls []struct {
		Ctx     context.Context
		DestKey string
		Keys    []string
	}
	mock.lockBitOpOr.RLock()
	calls = mock.calls.BitOpOr
	mock.lockBitOpOr.RUnlock()
	return calls
}

// ResetBitOpOrCalls reset all the calls that were made to BitOpOr.
func (mock *MoqCmdable) ResetBitOpOrCalls() {
	mock.lockBitOpOr.Lock()
	mock.calls.BitOpOr = nil
	mock.lockBitOpOr.Unlock()
}

// BitOpXor calls BitOpXorFunc.
func (mock *MoqCmdable) BitOpXor(ctx context.Context, destKey string, keys ...string) *redis.IntCmd {
	if mock.BitOpXorFunc == nil {
		panic("MoqCmdable.BitOpXorFunc: method is nil but Cmdable.BitOpXor was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		DestKey string
		Keys    []string
	}{
		Ctx:     ctx,
		DestKey: destKey,
		Keys:    keys,
	}
	mock.lockBitOpXor.Lock()
	mock.calls.BitOpXor = append(mock.calls.BitOpXor, callInfo)
	mock.lockBitOpXor.Unlock()
	return mock.BitOpXorFunc(ctx, destKey, keys...)
}

// BitOpXorCalls gets all the calls that were made to BitOpXor.
// Check the length with:
//
//	len(mockedCmdable.BitOpXorCalls())
func (mock *MoqCmdable) BitOpXorCalls() []struct {
	Ctx     context.Context
	DestKey string
	Keys    []string
} {
	var calls []struct {
		Ctx     context.Context
		DestKey string
		Keys    []string
	}
	mock.lockBitOpXor.RLock()
	calls = mock.calls.BitOpXor
	mock.lockBitOpXor.RUnlock()
	return calls
}

// ResetBitOpXorCalls reset all the calls that were made to BitOpXor.
func (mock *MoqCmdable) ResetBitOpXorCalls() {
	mock.lockBitOpXor.Lock()
	mock.calls.BitOpXor = nil
	mock.lockBitOpXor.Unlock()
}

// BitPos calls BitPosFunc.
func (mock *MoqCmdable) BitPos(ctx context.Context, key string, bit int64, pos ...int64) *redis.IntCmd {
	if mock.BitPosFunc == nil {
		panic("MoqCmdable.BitPosFunc: method is nil but Cmdable.BitPos was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
		Bit int64
		Pos []int64
	}{
		Ctx: ctx,
		Key: key,
		Bit: bit,
		Pos: pos,
	}
	mock.lockBitPos.Lock()
	mock.calls.BitPos = append(mock.calls.BitPos, callInfo)
	mock.lockBitPos.Unlock()
	return mock.BitPosFunc(ctx, key, bit, pos...)
}

// BitPosCalls gets all the calls that were made to BitPos.
// Check the length with:
//
//	len(mockedCmdable.BitPosCalls())
func (mock *MoqCmdable) BitPosCalls() []struct {
	Ctx context.Context
	Key string
	Bit int64
	Pos []int64
} {
	var calls []struct {
		Ctx context.Context
		Key string
		Bit int64
		Pos []int64
	}
	mock.lockBitPos.RLock()
	calls = mock.calls.BitPos
	mock.lockBitPos.RUnlock()
	return calls
}

// ResetBitPosCalls reset all the calls that were made to BitPos.
func (mock *MoqCmdable) ResetBitPosCalls() {
	mock.lockBitPos.Lock()
	mock.calls.BitPos = nil
	mock.lockBitPos.Unlock()
}

// BitPosSpan calls BitPosSpanFunc.
func (mock *MoqCmdable) BitPosSpan(ctx context.Context, key string, bit int8, start int64, end int64, span string) *redis.IntCmd {
	if mock.BitPosSpanFunc == nil {
		panic("MoqCmdable.BitPosSpanFunc: method is nil but Cmdable.BitPosSpan was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Bit   int8
		Start int64
		End   int64
		Span  string
	}{
		Ctx:   ctx,
		Key:   key,
		Bit:   bit,
		Start: start,
		End:   end,
		Span:  span,
	}
	mock.lockBitPosSpan.Lock()
	mock.calls.BitPosSpan = append(mock.calls.BitPosSpan, callInfo)
	mock.lockBitPosSpan.Unlock()
	return mock.BitPosSpanFunc(ctx, key, bit, start, end, span)
}

// BitPosSpanCalls gets all the calls that were made to BitPosSpan.
// Check the length with:
//
//	len(mockedCmdable.BitPosSpanCalls())
func (mock *MoqCmdable) BitPosSpanCalls() []struct {
	Ctx   context.Context
	Key   string
	Bit   int8
	Start int64
	End   int64
	Span  string
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Bit   int8
		Start int64
		End   int64
		Span  string
	}
	mock.lockBitPosSpan.RLock()
	calls = mock.calls.BitPosSpan
	mock.lockBitPosSpan.RUnlock()
	return calls
}

// ResetBitPosSpanCalls reset all the calls that were made to BitPosSpan.
func (mock *MoqCmdable) ResetBitPosSpanCalls() {
	mock.lockBitPosSpan.Lock()
	mock.calls.BitPosSpan = nil
	mock.lockBitPosSpan.Unlock()
}

// CFAdd calls CFAddFunc.
func (mock *MoqCmdable) CFAdd(ctx context.Context, key string, element interface{}) *redis.BoolCmd {
	if mock.CFAddFunc == nil {
		panic("MoqCmdable.CFAddFunc: method is nil but Cmdable.CFAdd was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Key     string
		Element interface{}
	}{
		Ctx:     ctx,
		Key:     key,
		Element: element,
	}
	mock.lockCFAdd.Lock()
	mock.calls.CFAdd = append(mock.calls.CFAdd, callInfo)
	mock.lockCFAdd.Unlock()
	return mock.CFAddFunc(ctx, key, element)
}

// CFAddCalls gets all the calls that were made to CFAdd.
// Check the length with:
//
//	len(mockedCmdable.CFAddCalls())
func (mock *MoqCmdable) CFAddCalls() []struct {
	Ctx     context.Context
	Key     string
	Element interface{}
} {
	var calls []struct {
		Ctx     context.Context
		Key     string
		Element interface{}
	}
	mock.lockCFAdd.RLock()
	calls = mock.calls.CFAdd
	mock.lockCFAdd.RUnlock()
	return calls
}

// ResetCFAddCalls reset all the calls that were made to CFAdd.
func (mock *MoqCmdable) ResetCFAddCalls() {
	mock.lockCFAdd.Lock()
	mock.calls.CFAdd = nil
	mock.lockCFAdd.Unlock()
}

// CFAddNX calls CFAddNXFunc.
func (mock *MoqCmdable) CFAddNX(ctx context.Context, key string, element interface{}) *redis.BoolCmd {
	if mock.CFAddNXFunc == nil {
		panic("MoqCmdable.CFAddNXFunc: method is nil but Cmdable.CFAddNX was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Key     string
		Element interface{}
	}{
		Ctx:     ctx,
		Key:     key,
		Element: element,
	}
	mock.lockCFAddNX.Lock()
	mock.calls.CFAddNX = append(mock.calls.CFAddNX, callInfo)
	mock.lockCFAddNX.Unlock()
	return mock.CFAddNXFunc(ctx, key, element)
}

// CFAddNXCalls gets all the calls that were made to CFAddNX.
// Check the length with:
//
//	len(mockedCmdable.CFAddNXCalls())
func (mock *MoqCmdable) CFAddNXCalls() []struct {
	Ctx     context.Context
	Key     string
	Element interface{}
} {
	var calls []struct {
		Ctx     context.Context
		Key     string
		Element interface{}
	}
	mock.lockCFAddNX.RLock()
	calls = mock.calls.CFAddNX
	mock.lockCFAddNX.RUnlock()
	return calls
}

// ResetCFAddNXCalls reset all the calls that were made to CFAddNX.
func (mock *MoqCmdable) ResetCFAddNXCalls() {
	mock.lockCFAddNX.Lock()
	mock.calls.CFAddNX = nil
	mock.lockCFAddNX.Unlock()
}

// CFCount calls CFCountFunc.
func (mock *MoqCmdable) CFCount(ctx context.Context, key string, element interface{}) *redis.IntCmd {
	if mock.CFCountFunc == nil {
		panic("MoqCmdable.CFCountFunc: method is nil but Cmdable.CFCount was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Key     string
		Element interface{}
	}{
		Ctx:     ctx,
		Key:     key,
		Element: element,
	}
	mock.lockCFCount.Lock()
	mock.calls.CFCount = append(mock.calls.CFCount, callInfo)
	mock.lockCFCount.Unlock()
	return mock.CFCountFunc(ctx, key, element)
}

// CFCountCalls gets all the calls that were made to CFCount.
// Check the length with:
//
//	len(mockedCmdable.CFCountCalls())
func (mock *MoqCmdable) CFCountCalls() []struct {
	Ctx     context.Context
	Key     string
	Element interface{}
} {
	var calls []struct {
		Ctx     context.Context
		Key     string
		Element interface{}
	}
	mock.lockCFCount.RLock()
	calls = mock.calls.CFCount
	mock.lockCFCount.RUnlock()
	return calls
}

// ResetCFCountCalls reset all the calls that were made to CFCount.
func (mock *MoqCmdable) ResetCFCountCalls() {
	mock.lockCFCount.Lock()
	mock.calls.CFCount = nil
	mock.lockCFCount.Unlock()
}

// CFDel calls CFDelFunc.
func (mock *MoqCmdable) CFDel(ctx context.Context, key string, element interface{}) *redis.BoolCmd {
	if mock.CFDelFunc == nil {
		panic("MoqCmdable.CFDelFunc: method is nil but Cmdable.CFDel was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Key     string
		Element interface{}
	}{
		Ctx:     ctx,
		Key:     key,
		Element: element,
	}
	mock.lockCFDel.Lock()
	mock.calls.CFDel = append(mock.calls.CFDel, callInfo)
	mock.lockCFDel.Unlock()
	return mock.CFDelFunc(ctx, key, element)
}

// CFDelCalls gets all the calls that were made to CFDel.
// Check the length with:
//
//	len(mockedCmdable.CFDelCalls())
func (mock *MoqCmdable) CFDelCalls() []struct {
	Ctx     context.Context
	Key     string
	Element interface{}
} {
	var calls []struct {
		Ctx     context.Context
		Key     string
		Element interface{}
	}
	mock.lockCFDel.RLock()
	calls = mock.calls.CFDel
	mock.lockCFDel.RUnlock()
	return calls
}

// ResetCFDelCalls reset all the calls that were made to CFDel.
func (mock *MoqCmdable) ResetCFDelCalls() {
	mock.lockCFDel.Lock()
	mock.calls.CFDel = nil
	mock.lockCFDel.Unlock()
}

// CFExists calls CFExistsFunc.
func (mock *MoqCmdable) CFExists(ctx context.Context, key string, element interface{}) *redis.BoolCmd {
	if mock.CFExistsFunc == nil {
		panic("MoqCmdable.CFExistsFunc: method is nil but Cmdable.CFExists was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Key     string
		Element interface{}
	}{
		Ctx:     ctx,
		Key:     key,
		Element: element,
	}
	mock.lockCFExists.Lock()
	mock.calls.CFExists = append(mock.calls.CFExists, callInfo)
	mock.lockCFExists.Unlock()
	return mock.CFExistsFunc(ctx, key, element)
}

// CFExistsCalls gets all the calls that were made to CFExists.
// Check the length with:
//
//	len(mockedCmdable.CFExistsCalls())
func (mock *MoqCmdable) CFExistsCalls() []struct {
	Ctx     context.Context
	Key     string
	Element interface{}
} {
	var calls []struct {
		Ctx     context.Context
		Key     string
		Element interface{}
	}
	mock.lockCFExists.RLock()
	calls = mock.calls.CFExists
	mock.lockCFExists.RUnlock()
	return calls
}

// ResetCFExistsCalls reset all the calls that were made to CFExists.
func (mock *MoqCmdable) ResetCFExistsCalls() {
	mock.lockCFExists.Lock()
	mock.calls.CFExists = nil
	mock.lockCFExists.Unlock()
}

// CFInfo calls CFInfoFunc.
func (mock *MoqCmdable) CFInfo(ctx context.Context, key string) *redis.CFInfoCmd {
	if mock.CFInfoFunc == nil {
		panic("MoqCmdable.CFInfoFunc: method is nil but Cmdable.CFInfo was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockCFInfo.Lock()
	mock.calls.CFInfo = append(mock.calls.CFInfo, callInfo)
	mock.lockCFInfo.Unlock()
	return mock.CFInfoFunc(ctx, key)
}

// CFInfoCalls gets all the calls that were made to CFInfo.
// Check the length with:
//
//	len(mockedCmdable.CFInfoCalls())
func (mock *MoqCmdable) CFInfoCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockCFInfo.RLock()
	calls = mock.calls.CFInfo
	mock.lockCFInfo.RUnlock()
	return calls
}

// ResetCFInfoCalls reset all the calls that were made to CFInfo.
func (mock *MoqCmdable) ResetCFInfoCalls() {
	mock.lockCFInfo.Lock()
	mock.calls.CFInfo = nil
	mock.lockCFInfo.Unlock()
}

// CFInsert calls CFInsertFunc.
func (mock *MoqCmdable) CFInsert(ctx context.Context, key string, options *redis.CFInsertOptions, elements ...interface{}) *redis.BoolSliceCmd {
	if mock.CFInsertFunc == nil {
		panic("MoqCmdable.CFInsertFunc: method is nil but Cmdable.CFInsert was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Key      string
		Options  *redis.CFInsertOptions
		Elements []interface{}
	}{
		Ctx:      ctx,
		Key:      key,
		Options:  options,
		Elements: elements,
	}
	mock.lockCFInsert.Lock()
	mock.calls.CFInsert = append(mock.calls.CFInsert, callInfo)
	mock.lockCFInsert.Unlock()
	return mock.CFInsertFunc(ctx, key, options, elements...)
}

// CFInsertCalls gets all the calls that were made to CFInsert.
// Check the length with:
//
//	len(mockedCmdable.CFInsertCalls())
func (mock *MoqCmdable) CFInsertCalls() []struct {
	Ctx      context.Context
	Key      string
	Options  *redis.CFInsertOptions
	Elements []interface{}
} {
	var calls []struct {
		Ctx      context.Context
		Key      string
		Options  *redis.CFInsertOptions
		Elements []interface{}
	}
	mock.lockCFInsert.RLock()
	calls = mock.calls.CFInsert
	mock.lockCFInsert.RUnlock()
	return calls
}

// ResetCFInsertCalls reset all the calls that were made to CFInsert.
func (mock *MoqCmdable) ResetCFInsertCalls() {
	mock.lockCFInsert.Lock()
	mock.calls.CFInsert = nil
	mock.lockCFInsert.Unlock()
}

// CFInsertNX calls CFInsertNXFunc.
func (mock *MoqCmdable) CFInsertNX(ctx context.Context, key string, options *redis.CFInsertOptions, elements ...interface{}) *redis.IntSliceCmd {
	if mock.CFInsertNXFunc == nil {
		panic("MoqCmdable.CFInsertNXFunc: method is nil but Cmdable.CFInsertNX was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Key      string
		Options  *redis.CFInsertOptions
		Elements []interface{}
	}{
		Ctx:      ctx,
		Key:      key,
		Options:  options,
		Elements: elements,
	}
	mock.lockCFInsertNX.Lock()
	mock.calls.CFInsertNX = append(mock.calls.CFInsertNX, callInfo)
	mock.lockCFInsertNX.Unlock()
	return mock.CFInsertNXFunc(ctx, key, options, elements...)
}

// CFInsertNXCalls gets all the calls that were made to CFInsertNX.
// Check the length with:
//
//	len(mockedCmdable.CFInsertNXCalls())
func (mock *MoqCmdable) CFInsertNXCalls() []struct {
	Ctx      context.Context
	Key      string
	Options  *redis.CFInsertOptions
	Elements []interface{}
} {
	var calls []struct {
		Ctx      context.Context
		Key      string
		Options  *redis.CFInsertOptions
		Elements []interface{}
	}
	mock.lockCFInsertNX.RLock()
	calls = mock.calls.CFInsertNX
	mock.lockCFInsertNX.RUnlock()
	return calls
}

// ResetCFInsertNXCalls reset all the calls that were made to CFInsertNX.
func (mock *MoqCmdable) ResetCFInsertNXCalls() {
	mock.lockCFInsertNX.Lock()
	mock.calls.CFInsertNX = nil
	mock.lockCFInsertNX.Unlock()
}

// CFLoadChunk calls CFLoadChunkFunc.
func (mock *MoqCmdable) CFLoadChunk(ctx context.Context, key string, iterator int64, data interface{}) *redis.StatusCmd {
	if mock.CFLoadChunkFunc == nil {
		panic("MoqCmdable.CFLoadChunkFunc: method is nil but Cmdable.CFLoadChunk was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Key      string
		Iterator int64
		Data     interface{}
	}{
		Ctx:      ctx,
		Key:      key,
		Iterator: iterator,
		Data:     data,
	}
	mock.lockCFLoadChunk.Lock()
	mock.calls.CFLoadChunk = append(mock.calls.CFLoadChunk, callInfo)
	mock.lockCFLoadChunk.Unlock()
	return mock.CFLoadChunkFunc(ctx, key, iterator, data)
}

// CFLoadChunkCalls gets all the calls that were made to CFLoadChunk.
// Check the length with:
//
//	len(mockedCmdable.CFLoadChunkCalls())
func (mock *MoqCmdable) CFLoadChunkCalls() []struct {
	Ctx      context.Context
	Key      string
	Iterator int64
	Data     interface{}
} {
	var calls []struct {
		Ctx      context.Context
		Key      string
		Iterator int64
		Data     interface{}
	}
	mock.lockCFLoadChunk.RLock()
	calls = mock.calls.CFLoadChunk
	mock.lockCFLoadChunk.RUnlock()
	return calls
}

// ResetCFLoadChunkCalls reset all the calls that were made to CFLoadChunk.
func (mock *MoqCmdable) ResetCFLoadChunkCalls() {
	mock.lockCFLoadChunk.Lock()
	mock.calls.CFLoadChunk = nil
	mock.lockCFLoadChunk.Unlock()
}

// CFMExists calls CFMExistsFunc.
func (mock *MoqCmdable) CFMExists(ctx context.Context, key string, elements ...interface{}) *redis.BoolSliceCmd {
	if mock.CFMExistsFunc == nil {
		panic("MoqCmdable.CFMExistsFunc: method is nil but Cmdable.CFMExists was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Key      string
		Elements []interface{}
	}{
		Ctx:      ctx,
		Key:      key,
		Elements: elements,
	}
	mock.lockCFMExists.Lock()
	mock.calls.CFMExists = append(mock.calls.CFMExists, callInfo)
	mock.lockCFMExists.Unlock()
	return mock.CFMExistsFunc(ctx, key, elements...)
}

// CFMExistsCalls gets all the calls that were made to CFMExists.
// Check the length with:
//
//	len(mockedCmdable.CFMExistsCalls())
func (mock *MoqCmdable) CFMExistsCalls() []struct {
	Ctx      context.Context
	Key      string
	Elements []interface{}
} {
	var calls []struct {
		Ctx      context.Context
		Key      string
		Elements []interface{}
	}
	mock.lockCFMExists.RLock()
	calls = mock.calls.CFMExists
	mock.lockCFMExists.RUnlock()
	return calls
}

// ResetCFMExistsCalls reset all the calls that were made to CFMExists.
func (mock *MoqCmdable) ResetCFMExistsCalls() {
	mock.lockCFMExists.Lock()
	mock.calls.CFMExists = nil
	mock.lockCFMExists.Unlock()
}

// CFReserve calls CFReserveFunc.
func (mock *MoqCmdable) CFReserve(ctx context.Context, key string, capacity int64) *redis.StatusCmd {
	if mock.CFReserveFunc == nil {
		panic("MoqCmdable.CFReserveFunc: method is nil but Cmdable.CFReserve was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Key      string
		Capacity int64
	}{
		Ctx:      ctx,
		Key:      key,
		Capacity: capacity,
	}
	mock.lockCFReserve.Lock()
	mock.calls.CFReserve = append(mock.calls.CFReserve, callInfo)
	mock.lockCFReserve.Unlock()
	return mock.CFReserveFunc(ctx, key, capacity)
}

// CFReserveCalls gets all the calls that were made to CFReserve.
// Check the length with:
//
//	len(mockedCmdable.CFReserveCalls())
func (mock *MoqCmdable) CFReserveCalls() []struct {
	Ctx      context.Context
	Key      string
	Capacity int64
} {
	var calls []struct {
		Ctx      context.Context
		Key      string
		Capacity int64
	}
	mock.lockCFReserve.RLock()
	calls = mock.calls.CFReserve
	mock.lockCFReserve.RUnlock()
	return calls
}

// ResetCFReserveCalls reset all the calls that were made to CFReserve.
func (mock *MoqCmdable) ResetCFReserveCalls() {
	mock.lockCFReserve.Lock()
	mock.calls.CFReserve = nil
	mock.lockCFReserve.Unlock()
}

// CFReserveBucketSize calls CFReserveBucketSizeFunc.
func (mock *MoqCmdable) CFReserveBucketSize(ctx context.Context, key string, capacity int64, bucketsize int64) *redis.StatusCmd {
	if mock.CFReserveBucketSizeFunc == nil {
		panic("MoqCmdable.CFReserveBucketSizeFunc: method is nil but Cmdable.CFReserveBucketSize was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Key        string
		Capacity   int64
		Bucketsize int64
	}{
		Ctx:        ctx,
		Key:        key,
		Capacity:   capacity,
		Bucketsize: bucketsize,
	}
	mock.lockCFReserveBucketSize.Lock()
	mock.calls.CFReserveBucketSize = append(mock.calls.CFReserveBucketSize, callInfo)
	mock.lockCFReserveBucketSize.Unlock()
	return mock.CFReserveBucketSizeFunc(ctx, key, capacity, bucketsize)
}

// CFReserveBucketSizeCalls gets all the calls that were made to CFReserveBucketSize.
// Check the length with:
//
//	len(mockedCmdable.CFReserveBucketSizeCalls())
func (mock *MoqCmdable) CFReserveBucketSizeCalls() []struct {
	Ctx        context.Context
	Key        string
	Capacity   int64
	Bucketsize int64
} {
	var calls []struct {
		Ctx        context.Context
		Key        string
		Capacity   int64
		Bucketsize int64
	}
	mock.lockCFReserveBucketSize.RLock()
	calls = mock.calls.CFReserveBucketSize
	mock.lockCFReserveBucketSize.RUnlock()
	return calls
}

// ResetCFReserveBucketSizeCalls reset all the calls that were made to CFReserveBucketSize.
func (mock *MoqCmdable) ResetCFReserveBucketSizeCalls() {
	mock.lockCFReserveBucketSize.Lock()
	mock.calls.CFReserveBucketSize = nil
	mock.lockCFReserveBucketSize.Unlock()
}

// CFReserveExpansion calls CFReserveExpansionFunc.
func (mock *MoqCmdable) CFReserveExpansion(ctx context.Context, key string, capacity int64, expansion int64) *redis.StatusCmd {
	if mock.CFReserveExpansionFunc == nil {
		panic("MoqCmdable.CFReserveExpansionFunc: method is nil but Cmdable.CFReserveExpansion was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Key       string
		Capacity  int64
		Expansion int64
	}{
		Ctx:       ctx,
		Key:       key,
		Capacity:  capacity,
		Expansion: expansion,
	}
	mock.lockCFReserveExpansion.Lock()
	mock.calls.CFReserveExpansion = append(mock.calls.CFReserveExpansion, callInfo)
	mock.lockCFReserveExpansion.Unlock()
	return mock.CFReserveExpansionFunc(ctx, key, capacity, expansion)
}

// CFReserveExpansionCalls gets all the calls that were made to CFReserveExpansion.
// Check the length with:
//
//	len(mockedCmdable.CFReserveExpansionCalls())
func (mock *MoqCmdable) CFReserveExpansionCalls() []struct {
	Ctx       context.Context
	Key       string
	Capacity  int64
	Expansion int64
} {
	var calls []struct {
		Ctx       context.Context
		Key       string
		Capacity  int64
		Expansion int64
	}
	mock.lockCFReserveExpansion.RLock()
	calls = mock.calls.CFReserveExpansion
	mock.lockCFReserveExpansion.RUnlock()
	return calls
}

// ResetCFReserveExpansionCalls reset all the calls that were made to CFReserveExpansion.
func (mock *MoqCmdable) ResetCFReserveExpansionCalls() {
	mock.lockCFReserveExpansion.Lock()
	mock.calls.CFReserveExpansion = nil
	mock.lockCFReserveExpansion.Unlock()
}

// CFReserveMaxIterations calls CFReserveMaxIterationsFunc.
func (mock *MoqCmdable) CFReserveMaxIterations(ctx context.Context, key string, capacity int64, maxiterations int64) *redis.StatusCmd {
	if mock.CFReserveMaxIterationsFunc == nil {
		panic("MoqCmdable.CFReserveMaxIterationsFunc: method is nil but Cmdable.CFReserveMaxIterations was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		Key           string
		Capacity      int64
		Maxiterations int64
	}{
		Ctx:           ctx,
		Key:           key,
		Capacity:      capacity,
		Maxiterations: maxiterations,
	}
	mock.lockCFReserveMaxIterations.Lock()
	mock.calls.CFReserveMaxIterations = append(mock.calls.CFReserveMaxIterations, callInfo)
	mock.lockCFReserveMaxIterations.Unlock()
	return mock.CFReserveMaxIterationsFunc(ctx, key, capacity, maxiterations)
}

// CFReserveMaxIterationsCalls gets all the calls that were made to CFReserveMaxIterations.
// Check the length with:
//
//	len(mockedCmdable.CFReserveMaxIterationsCalls())
func (mock *MoqCmdable) CFReserveMaxIterationsCalls() []struct {
	Ctx           context.Context
	Key           string
	Capacity      int64
	Maxiterations int64
} {
	var calls []struct {
		Ctx           context.Context
		Key           string
		Capacity      int64
		Maxiterations int64
	}
	mock.lockCFReserveMaxIterations.RLock()
	calls = mock.calls.CFReserveMaxIterations
	mock.lockCFReserveMaxIterations.RUnlock()
	return calls
}

// ResetCFReserveMaxIterationsCalls reset all the calls that were made to CFReserveMaxIterations.
func (mock *MoqCmdable) ResetCFReserveMaxIterationsCalls() {
	mock.lockCFReserveMaxIterations.Lock()
	mock.calls.CFReserveMaxIterations = nil
	mock.lockCFReserveMaxIterations.Unlock()
}

// CFReserveWithArgs calls CFReserveWithArgsFunc.
func (mock *MoqCmdable) CFReserveWithArgs(ctx context.Context, key string, options *redis.CFReserveOptions) *redis.StatusCmd {
	if mock.CFReserveWithArgsFunc == nil {
		panic("MoqCmdable.CFReserveWithArgsFunc: method is nil but Cmdable.CFReserveWithArgs was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Key     string
		Options *redis.CFReserveOptions
	}{
		Ctx:     ctx,
		Key:     key,
		Options: options,
	}
	mock.lockCFReserveWithArgs.Lock()
	mock.calls.CFReserveWithArgs = append(mock.calls.CFReserveWithArgs, callInfo)
	mock.lockCFReserveWithArgs.Unlock()
	return mock.CFReserveWithArgsFunc(ctx, key, options)
}

// CFReserveWithArgsCalls gets all the calls that were made to CFReserveWithArgs.
// Check the length with:
//
//	len(mockedCmdable.CFReserveWithArgsCalls())
func (mock *MoqCmdable) CFReserveWithArgsCalls() []struct {
	Ctx     context.Context
	Key     string
	Options *redis.CFReserveOptions
} {
	var calls []struct {
		Ctx     context.Context
		Key     string
		Options *redis.CFReserveOptions
	}
	mock.lockCFReserveWithArgs.RLock()
	calls = mock.calls.CFReserveWithArgs
	mock.lockCFReserveWithArgs.RUnlock()
	return calls
}

// ResetCFReserveWithArgsCalls reset all the calls that were made to CFReserveWithArgs.
func (mock *MoqCmdable) ResetCFReserveWithArgsCalls() {
	mock.lockCFReserveWithArgs.Lock()
	mock.calls.CFReserveWithArgs = nil
	mock.lockCFReserveWithArgs.Unlock()
}

// CFScanDump calls CFScanDumpFunc.
func (mock *MoqCmdable) CFScanDump(ctx context.Context, key string, iterator int64) *redis.ScanDumpCmd {
	if mock.CFScanDumpFunc == nil {
		panic("MoqCmdable.CFScanDumpFunc: method is nil but Cmdable.CFScanDump was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Key      string
		Iterator int64
	}{
		Ctx:      ctx,
		Key:      key,
		Iterator: iterator,
	}
	mock.lockCFScanDump.Lock()
	mock.calls.CFScanDump = append(mock.calls.CFScanDump, callInfo)
	mock.lockCFScanDump.Unlock()
	return mock.CFScanDumpFunc(ctx, key, iterator)
}

// CFScanDumpCalls gets all the calls that were made to CFScanDump.
// Check the length with:
//
//	len(mockedCmdable.CFScanDumpCalls())
func (mock *MoqCmdable) CFScanDumpCalls() []struct {
	Ctx      context.Context
	Key      string
	Iterator int64
} {
	var calls []struct {
		Ctx      context.Context
		Key      string
		Iterator int64
	}
	mock.lockCFScanDump.RLock()
	calls = mock.calls.CFScanDump
	mock.lockCFScanDump.RUnlock()
	return calls
}

// ResetCFScanDumpCalls reset all the calls that were made to CFScanDump.
func (mock *MoqCmdable) ResetCFScanDumpCalls() {
	mock.lockCFScanDump.Lock()
	mock.calls.CFScanDump = nil
	mock.lockCFScanDump.Unlock()
}

// CMSIncrBy calls CMSIncrByFunc.
func (mock *MoqCmdable) CMSIncrBy(ctx context.Context, key string, elements ...interface{}) *redis.IntSliceCmd {
	if mock.CMSIncrByFunc == nil {
		panic("MoqCmdable.CMSIncrByFunc: method is nil but Cmdable.CMSIncrBy was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Key      string
		Elements []interface{}
	}{
		Ctx:      ctx,
		Key:      key,
		Elements: elements,
	}
	mock.lockCMSIncrBy.Lock()
	mock.calls.CMSIncrBy = append(mock.calls.CMSIncrBy, callInfo)
	mock.lockCMSIncrBy.Unlock()
	return mock.CMSIncrByFunc(ctx, key, elements...)
}

// CMSIncrByCalls gets all the calls that were made to CMSIncrBy.
// Check the length with:
//
//	len(mockedCmdable.CMSIncrByCalls())
func (mock *MoqCmdable) CMSIncrByCalls() []struct {
	Ctx      context.Context
	Key      string
	Elements []interface{}
} {
	var calls []struct {
		Ctx      context.Context
		Key      string
		Elements []interface{}
	}
	mock.lockCMSIncrBy.RLock()
	calls = mock.calls.CMSIncrBy
	mock.lockCMSIncrBy.RUnlock()
	return calls
}

// ResetCMSIncrByCalls reset all the calls that were made to CMSIncrBy.
func (mock *MoqCmdable) ResetCMSIncrByCalls() {
	mock.lockCMSIncrBy.Lock()
	mock.calls.CMSIncrBy = nil
	mock.lockCMSIncrBy.Unlock()
}

// CMSInfo calls CMSInfoFunc.
func (mock *MoqCmdable) CMSInfo(ctx context.Context, key string) *redis.CMSInfoCmd {
	if mock.CMSInfoFunc == nil {
		panic("MoqCmdable.CMSInfoFunc: method is nil but Cmdable.CMSInfo was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockCMSInfo.Lock()
	mock.calls.CMSInfo = append(mock.calls.CMSInfo, callInfo)
	mock.lockCMSInfo.Unlock()
	return mock.CMSInfoFunc(ctx, key)
}

// CMSInfoCalls gets all the calls that were made to CMSInfo.
// Check the length with:
//
//	len(mockedCmdable.CMSInfoCalls())
func (mock *MoqCmdable) CMSInfoCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockCMSInfo.RLock()
	calls = mock.calls.CMSInfo
	mock.lockCMSInfo.RUnlock()
	return calls
}

// ResetCMSInfoCalls reset all the calls that were made to CMSInfo.
func (mock *MoqCmdable) ResetCMSInfoCalls() {
	mock.lockCMSInfo.Lock()
	mock.calls.CMSInfo = nil
	mock.lockCMSInfo.Unlock()
}

// CMSInitByDim calls CMSInitByDimFunc.
func (mock *MoqCmdable) CMSInitByDim(ctx context.Context, key string, width int64, height int64) *redis.StatusCmd {
	if mock.CMSInitByDimFunc == nil {
		panic("MoqCmdable.CMSInitByDimFunc: method is nil but Cmdable.CMSInitByDim was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		Width  int64
		Height int64
	}{
		Ctx:    ctx,
		Key:    key,
		Width:  width,
		Height: height,
	}
	mock.lockCMSInitByDim.Lock()
	mock.calls.CMSInitByDim = append(mock.calls.CMSInitByDim, callInfo)
	mock.lockCMSInitByDim.Unlock()
	return mock.CMSInitByDimFunc(ctx, key, width, height)
}

// CMSInitByDimCalls gets all the calls that were made to CMSInitByDim.
// Check the length with:
//
//	len(mockedCmdable.CMSInitByDimCalls())
func (mock *MoqCmdable) CMSInitByDimCalls() []struct {
	Ctx    context.Context
	Key    string
	Width  int64
	Height int64
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		Width  int64
		Height int64
	}
	mock.lockCMSInitByDim.RLock()
	calls = mock.calls.CMSInitByDim
	mock.lockCMSInitByDim.RUnlock()
	return calls
}

// ResetCMSInitByDimCalls reset all the calls that were made to CMSInitByDim.
func (mock *MoqCmdable) ResetCMSInitByDimCalls() {
	mock.lockCMSInitByDim.Lock()
	mock.calls.CMSInitByDim = nil
	mock.lockCMSInitByDim.Unlock()
}

// CMSInitByProb calls CMSInitByProbFunc.
func (mock *MoqCmdable) CMSInitByProb(ctx context.Context, key string, errorRate float64, probability float64) *redis.StatusCmd {
	if mock.CMSInitByProbFunc == nil {
		panic("MoqCmdable.CMSInitByProbFunc: method is nil but Cmdable.CMSInitByProb was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		Key         string
		ErrorRate   float64
		Probability float64
	}{
		Ctx:         ctx,
		Key:         key,
		ErrorRate:   errorRate,
		Probability: probability,
	}
	mock.lockCMSInitByProb.Lock()
	mock.calls.CMSInitByProb = append(mock.calls.CMSInitByProb, callInfo)
	mock.lockCMSInitByProb.Unlock()
	return mock.CMSInitByProbFunc(ctx, key, errorRate, probability)
}

// CMSInitByProbCalls gets all the calls that were made to CMSInitByProb.
// Check the length with:
//
//	len(mockedCmdable.CMSInitByProbCalls())
func (mock *MoqCmdable) CMSInitByProbCalls() []struct {
	Ctx         context.Context
	Key         string
	ErrorRate   float64
	Probability float64
} {
	var calls []struct {
		Ctx         context.Context
		Key         string
		ErrorRate   float64
		Probability float64
	}
	mock.lockCMSInitByProb.RLock()
	calls = mock.calls.CMSInitByProb
	mock.lockCMSInitByProb.RUnlock()
	return calls
}

// ResetCMSInitByProbCalls reset all the calls that were made to CMSInitByProb.
func (mock *MoqCmdable) ResetCMSInitByProbCalls() {
	mock.lockCMSInitByProb.Lock()
	mock.calls.CMSInitByProb = nil
	mock.lockCMSInitByProb.Unlock()
}

// CMSMerge calls CMSMergeFunc.
func (mock *MoqCmdable) CMSMerge(ctx context.Context, destKey string, sourceKeys ...string) *redis.StatusCmd {
	if mock.CMSMergeFunc == nil {
		panic("MoqCmdable.CMSMergeFunc: method is nil but Cmdable.CMSMerge was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		DestKey    string
		SourceKeys []string
	}{
		Ctx:        ctx,
		DestKey:    destKey,
		SourceKeys: sourceKeys,
	}
	mock.lockCMSMerge.Lock()
	mock.calls.CMSMerge = append(mock.calls.CMSMerge, callInfo)
	mock.lockCMSMerge.Unlock()
	return mock.CMSMergeFunc(ctx, destKey, sourceKeys...)
}

// CMSMergeCalls gets all the calls that were made to CMSMerge.
// Check the length with:
//
//	len(mockedCmdable.CMSMergeCalls())
func (mock *MoqCmdable) CMSMergeCalls() []struct {
	Ctx        context.Context
	DestKey    string
	SourceKeys []string
} {
	var calls []struct {
		Ctx        context.Context
		DestKey    string
		SourceKeys []string
	}
	mock.lockCMSMerge.RLock()
	calls = mock.calls.CMSMerge
	mock.lockCMSMerge.RUnlock()
	return calls
}

// ResetCMSMergeCalls reset all the calls that were made to CMSMerge.
func (mock *MoqCmdable) ResetCMSMergeCalls() {
	mock.lockCMSMerge.Lock()
	mock.calls.CMSMerge = nil
	mock.lockCMSMerge.Unlock()
}

// CMSMergeWithWeight calls CMSMergeWithWeightFunc.
func (mock *MoqCmdable) CMSMergeWithWeight(ctx context.Context, destKey string, sourceKeys map[string]int64) *redis.StatusCmd {
	if mock.CMSMergeWithWeightFunc == nil {
		panic("MoqCmdable.CMSMergeWithWeightFunc: method is nil but Cmdable.CMSMergeWithWeight was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		DestKey    string
		SourceKeys map[string]int64
	}{
		Ctx:        ctx,
		DestKey:    destKey,
		SourceKeys: sourceKeys,
	}
	mock.lockCMSMergeWithWeight.Lock()
	mock.calls.CMSMergeWithWeight = append(mock.calls.CMSMergeWithWeight, callInfo)
	mock.lockCMSMergeWithWeight.Unlock()
	return mock.CMSMergeWithWeightFunc(ctx, destKey, sourceKeys)
}

// CMSMergeWithWeightCalls gets all the calls that were made to CMSMergeWithWeight.
// Check the length with:
//
//	len(mockedCmdable.CMSMergeWithWeightCalls())
func (mock *MoqCmdable) CMSMergeWithWeightCalls() []struct {
	Ctx        context.Context
	DestKey    string
	SourceKeys map[string]int64
} {
	var calls []struct {
		Ctx        context.Context
		DestKey    string
		SourceKeys map[string]int64
	}
	mock.lockCMSMergeWithWeight.RLock()
	calls = mock.calls.CMSMergeWithWeight
	mock.lockCMSMergeWithWeight.RUnlock()
	return calls
}

// ResetCMSMergeWithWeightCalls reset all the calls that were made to CMSMergeWithWeight.
func (mock *MoqCmdable) ResetCMSMergeWithWeightCalls() {
	mock.lockCMSMergeWithWeight.Lock()
	mock.calls.CMSMergeWithWeight = nil
	mock.lockCMSMergeWithWeight.Unlock()
}

// CMSQuery calls CMSQueryFunc.
func (mock *MoqCmdable) CMSQuery(ctx context.Context, key string, elements ...interface{}) *redis.IntSliceCmd {
	if mock.CMSQueryFunc == nil {
		panic("MoqCmdable.CMSQueryFunc: method is nil but Cmdable.CMSQuery was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Key      string
		Elements []interface{}
	}{
		Ctx:      ctx,
		Key:      key,
		Elements: elements,
	}
	mock.lockCMSQuery.Lock()
	mock.calls.CMSQuery = append(mock.calls.CMSQuery, callInfo)
	mock.lockCMSQuery.Unlock()
	return mock.CMSQueryFunc(ctx, key, elements...)
}

// CMSQueryCalls gets all the calls that were made to CMSQuery.
// Check the length with:
//
//	len(mockedCmdable.CMSQueryCalls())
func (mock *MoqCmdable) CMSQueryCalls() []struct {
	Ctx      context.Context
	Key      string
	Elements []interface{}
} {
	var calls []struct {
		Ctx      context.Context
		Key      string
		Elements []interface{}
	}
	mock.lockCMSQuery.RLock()
	calls = mock.calls.CMSQuery
	mock.lockCMSQuery.RUnlock()
	return calls
}

// ResetCMSQueryCalls reset all the calls that were made to CMSQuery.
func (mock *MoqCmdable) ResetCMSQueryCalls() {
	mock.lockCMSQuery.Lock()
	mock.calls.CMSQuery = nil
	mock.lockCMSQuery.Unlock()
}

// ClientGetName calls ClientGetNameFunc.
func (mock *MoqCmdable) ClientGetName(ctx context.Context) *redis.StringCmd {
	if mock.ClientGetNameFunc == nil {
		panic("MoqCmdable.ClientGetNameFunc: method is nil but Cmdable.ClientGetName was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockClientGetName.Lock()
	mock.calls.ClientGetName = append(mock.calls.ClientGetName, callInfo)
	mock.lockClientGetName.Unlock()
	return mock.ClientGetNameFunc(ctx)
}

// ClientGetNameCalls gets all the calls that were made to ClientGetName.
// Check the length with:
//
//	len(mockedCmdable.ClientGetNameCalls())
func (mock *MoqCmdable) ClientGetNameCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockClientGetName.RLock()
	calls = mock.calls.ClientGetName
	mock.lockClientGetName.RUnlock()
	return calls
}

// ResetClientGetNameCalls reset all the calls that were made to ClientGetName.
func (mock *MoqCmdable) ResetClientGetNameCalls() {
	mock.lockClientGetName.Lock()
	mock.calls.ClientGetName = nil
	mock.lockClientGetName.Unlock()
}

// ClientID calls ClientIDFunc.
func (mock *MoqCmdable) ClientID(ctx context.Context) *redis.IntCmd {
	if mock.ClientIDFunc == nil {
		panic("MoqCmdable.ClientIDFunc: method is nil but Cmdable.ClientID was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockClientID.Lock()
	mock.calls.ClientID = append(mock.calls.ClientID, callInfo)
	mock.lockClientID.Unlock()
	return mock.ClientIDFunc(ctx)
}

// ClientIDCalls gets all the calls that were made to ClientID.
// Check the length with:
//
//	len(mockedCmdable.ClientIDCalls())
func (mock *MoqCmdable) ClientIDCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockClientID.RLock()
	calls = mock.calls.ClientID
	mock.lockClientID.RUnlock()
	return calls
}

// ResetClientIDCalls reset all the calls that were made to ClientID.
func (mock *MoqCmdable) ResetClientIDCalls() {
	mock.lockClientID.Lock()
	mock.calls.ClientID = nil
	mock.lockClientID.Unlock()
}

// ClientInfo calls ClientInfoFunc.
func (mock *MoqCmdable) ClientInfo(ctx context.Context) *redis.ClientInfoCmd {
	if mock.ClientInfoFunc == nil {
		panic("MoqCmdable.ClientInfoFunc: method is nil but Cmdable.ClientInfo was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockClientInfo.Lock()
	mock.calls.ClientInfo = append(mock.calls.ClientInfo, callInfo)
	mock.lockClientInfo.Unlock()
	return mock.ClientInfoFunc(ctx)
}

// ClientInfoCalls gets all the calls that were made to ClientInfo.
// Check the length with:
//
//	len(mockedCmdable.ClientInfoCalls())
func (mock *MoqCmdable) ClientInfoCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockClientInfo.RLock()
	calls = mock.calls.ClientInfo
	mock.lockClientInfo.RUnlock()
	return calls
}

// ResetClientInfoCalls reset all the calls that were made to ClientInfo.
func (mock *MoqCmdable) ResetClientInfoCalls() {
	mock.lockClientInfo.Lock()
	mock.calls.ClientInfo = nil
	mock.lockClientInfo.Unlock()
}

// ClientKill calls ClientKillFunc.
func (mock *MoqCmdable) ClientKill(ctx context.Context, ipPort string) *redis.StatusCmd {
	if mock.ClientKillFunc == nil {
		panic("MoqCmdable.ClientKillFunc: method is nil but Cmdable.ClientKill was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		IpPort string
	}{
		Ctx:    ctx,
		IpPort: ipPort,
	}
	mock.lockClientKill.Lock()
	mock.calls.ClientKill = append(mock.calls.ClientKill, callInfo)
	mock.lockClientKill.Unlock()
	return mock.ClientKillFunc(ctx, ipPort)
}

// ClientKillCalls gets all the calls that were made to ClientKill.
// Check the length with:
//
//	len(mockedCmdable.ClientKillCalls())
func (mock *MoqCmdable) ClientKillCalls() []struct {
	Ctx    context.Context
	IpPort string
} {
	var calls []struct {
		Ctx    context.Context
		IpPort string
	}
	mock.lockClientKill.RLock()
	calls = mock.calls.ClientKill
	mock.lockClientKill.RUnlock()
	return calls
}

// ResetClientKillCalls reset all the calls that were made to ClientKill.
func (mock *MoqCmdable) ResetClientKillCalls() {
	mock.lockClientKill.Lock()
	mock.calls.ClientKill = nil
	mock.lockClientKill.Unlock()
}

// ClientKillByFilter calls ClientKillByFilterFunc.
func (mock *MoqCmdable) ClientKillByFilter(ctx context.Context, keys ...string) *redis.IntCmd {
	if mock.ClientKillByFilterFunc == nil {
		panic("MoqCmdable.ClientKillByFilterFunc: method is nil but Cmdable.ClientKillByFilter was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Keys []string
	}{
		Ctx:  ctx,
		Keys: keys,
	}
	mock.lockClientKillByFilter.Lock()
	mock.calls.ClientKillByFilter = append(mock.calls.ClientKillByFilter, callInfo)
	mock.lockClientKillByFilter.Unlock()
	return mock.ClientKillByFilterFunc(ctx, keys...)
}

// ClientKillByFilterCalls gets all the calls that were made to ClientKillByFilter.
// Check the length with:
//
//	len(mockedCmdable.ClientKillByFilterCalls())
func (mock *MoqCmdable) ClientKillByFilterCalls() []struct {
	Ctx  context.Context
	Keys []string
} {
	var calls []struct {
		Ctx  context.Context
		Keys []string
	}
	mock.lockClientKillByFilter.RLock()
	calls = mock.calls.ClientKillByFilter
	mock.lockClientKillByFilter.RUnlock()
	return calls
}

// ResetClientKillByFilterCalls reset all the calls that were made to ClientKillByFilter.
func (mock *MoqCmdable) ResetClientKillByFilterCalls() {
	mock.lockClientKillByFilter.Lock()
	mock.calls.ClientKillByFilter = nil
	mock.lockClientKillByFilter.Unlock()
}

// ClientList calls ClientListFunc.
func (mock *MoqCmdable) ClientList(ctx context.Context) *redis.StringCmd {
	if mock.ClientListFunc == nil {
		panic("MoqCmdable.ClientListFunc: method is nil but Cmdable.ClientList was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockClientList.Lock()
	mock.calls.ClientList = append(mock.calls.ClientList, callInfo)
	mock.lockClientList.Unlock()
	return mock.ClientListFunc(ctx)
}

// ClientListCalls gets all the calls that were made to ClientList.
// Check the length with:
//
//	len(mockedCmdable.ClientListCalls())
func (mock *MoqCmdable) ClientListCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockClientList.RLock()
	calls = mock.calls.ClientList
	mock.lockClientList.RUnlock()
	return calls
}

// ResetClientListCalls reset all the calls that were made to ClientList.
func (mock *MoqCmdable) ResetClientListCalls() {
	mock.lockClientList.Lock()
	mock.calls.ClientList = nil
	mock.lockClientList.Unlock()
}

// ClientMaintNotifications calls ClientMaintNotificationsFunc.
func (mock *MoqCmdable) ClientMaintNotifications(ctx context.Context, enabled bool, endpointType string) *redis.StatusCmd {
	if mock.ClientMaintNotificationsFunc == nil {
		panic("MoqCmdable.ClientMaintNotificationsFunc: method is nil but Cmdable.ClientMaintNotifications was just called")
	}
	callInfo := struct {
		Ctx          context.Context
		Enabled      bool
		EndpointType string
	}{
		Ctx:          ctx,
		Enabled:      enabled,
		EndpointType: endpointType,
	}
	mock.lockClientMaintNotifications.Lock()
	mock.calls.ClientMaintNotifications = append(mock.calls.ClientMaintNotifications, callInfo)
	mock.lockClientMaintNotifications.Unlock()
	return mock.ClientMaintNotificationsFunc(ctx, enabled, endpointType)
}

// ClientMaintNotificationsCalls gets all the calls that were made to ClientMaintNotifications.
// Check the length with:
//
//	len(mockedCmdable.ClientMaintNotificationsCalls())
func (mock *MoqCmdable) ClientMaintNotificationsCalls() []struct {
	Ctx          context.Context
	Enabled      bool
	EndpointType string
} {
	var calls []struct {
		Ctx          context.Context
		Enabled      bool
		EndpointType string
	}
	mock.lockClientMaintNotifications.RLock()
	calls = mock.calls.ClientMaintNotifications
	mock.lockClientMaintNotifications.RUnlock()
	return calls
}

// ResetClientMaintNotificationsCalls reset all the calls that were made to ClientMaintNotifications.
func (mock *MoqCmdable) ResetClientMaintNotificationsCalls() {
	mock.lockClientMaintNotifications.Lock()
	mock.calls.ClientMaintNotifications = nil
	mock.lockClientMaintNotifications.Unlock()
}

// ClientPause calls ClientPauseFunc.
func (mock *MoqCmdable) ClientPause(ctx context.Context, dur time.Duration) *redis.BoolCmd {
	if mock.ClientPauseFunc == nil {
		panic("MoqCmdable.ClientPauseFunc: method is nil but Cmdable.ClientPause was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Dur time.Duration
	}{
		Ctx: ctx,
		Dur: dur,
	}
	mock.lockClientPause.Lock()
	mock.calls.ClientPause = append(mock.calls.ClientPause, callInfo)
	mock.lockClientPause.Unlock()
	return mock.ClientPauseFunc(ctx, dur)
}

// ClientPauseCalls gets all the calls that were made to ClientPause.
// Check the length with:
//
//	len(mockedCmdable.ClientPauseCalls())
func (mock *MoqCmdable) ClientPauseCalls() []struct {
	Ctx context.Context
	Dur time.Duration
} {
	var calls []struct {
		Ctx context.Context
		Dur time.Duration
	}
	mock.lockClientPause.RLock()
	calls = mock.calls.ClientPause
	mock.lockClientPause.RUnlock()
	return calls
}

// ResetClientPauseCalls reset all the calls that were made to ClientPause.
func (mock *MoqCmdable) ResetClientPauseCalls() {
	mock.lockClientPause.Lock()
	mock.calls.ClientPause = nil
	mock.lockClientPause.Unlock()
}

// ClientUnblock calls ClientUnblockFunc.
func (mock *MoqCmdable) ClientUnblock(ctx context.Context, id int64) *redis.IntCmd {
	if mock.ClientUnblockFunc == nil {
		panic("MoqCmdable.ClientUnblockFunc: method is nil but Cmdable.ClientUnblock was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  int64
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockClientUnblock.Lock()
	mock.calls.ClientUnblock = append(mock.calls.ClientUnblock, callInfo)
	mock.lockClientUnblock.Unlock()
	return mock.ClientUnblockFunc(ctx, id)
}

// ClientUnblockCalls gets all the calls that were made to ClientUnblock.
// Check the length with:
//
//	len(mockedCmdable.ClientUnblockCalls())
func (mock *MoqCmdable) ClientUnblockCalls() []struct {
	Ctx context.Context
	ID  int64
} {
	var calls []struct {
		Ctx context.Context
		ID  int64
	}
	mock.lockClientUnblock.RLock()
	calls = mock.calls.ClientUnblock
	mock.lockClientUnblock.RUnlock()
	return calls
}

// ResetClientUnblockCalls reset all the calls that were made to ClientUnblock.
func (mock *MoqCmdable) ResetClientUnblockCalls() {
	mock.lockClientUnblock.Lock()
	mock.calls.ClientUnblock = nil
	mock.lockClientUnblock.Unlock()
}

// ClientUnblockWithError calls ClientUnblockWithErrorFunc.
func (mock *MoqCmdable) ClientUnblockWithError(ctx context.Context, id int64) *redis.IntCmd {
	if mock.ClientUnblockWithErrorFunc == nil {
		panic("MoqCmdable.ClientUnblockWithErrorFunc: method is nil but Cmdable.ClientUnblockWithError was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  int64
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockClientUnblockWithError.Lock()
	mock.calls.ClientUnblockWithError = append(mock.calls.ClientUnblockWithError, callInfo)
	mock.lockClientUnblockWithError.Unlock()
	return mock.ClientUnblockWithErrorFunc(ctx, id)
}

// ClientUnblockWithErrorCalls gets all the calls that were made to ClientUnblockWithError.
// Check the length with:
//
//	len(mockedCmdable.ClientUnblockWithErrorCalls())
func (mock *MoqCmdable) ClientUnblockWithErrorCalls() []struct {
	Ctx context.Context
	ID  int64
} {
	var calls []struct {
		Ctx context.Context
		ID  int64
	}
	mock.lockClientUnblockWithError.RLock()
	calls = mock.calls.ClientUnblockWithError
	mock.lockClientUnblockWithError.RUnlock()
	return calls
}

// ResetClientUnblockWithErrorCalls reset all the calls that were made to ClientUnblockWithError.
func (mock *MoqCmdable) ResetClientUnblockWithErrorCalls() {
	mock.lockClientUnblockWithError.Lock()
	mock.calls.ClientUnblockWithError = nil
	mock.lockClientUnblockWithError.Unlock()
}

// ClientUnpause calls ClientUnpauseFunc.
func (mock *MoqCmdable) ClientUnpause(ctx context.Context) *redis.BoolCmd {
	if mock.ClientUnpauseFunc == nil {
		panic("MoqCmdable.ClientUnpauseFunc: method is nil but Cmdable.ClientUnpause was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockClientUnpause.Lock()
	mock.calls.ClientUnpause = append(mock.calls.ClientUnpause, callInfo)
	mock.lockClientUnpause.Unlock()
	return mock.ClientUnpauseFunc(ctx)
}

// ClientUnpauseCalls gets all the calls that were made to ClientUnpause.
// Check the length with:
//
//	len(mockedCmdable.ClientUnpauseCalls())
func (mock *MoqCmdable) ClientUnpauseCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockClientUnpause.RLock()
	calls = mock.calls.ClientUnpause
	mock.lockClientUnpause.RUnlock()
	return calls
}

// ResetClientUnpauseCalls reset all the calls that were made to ClientUnpause.
func (mock *MoqCmdable) ResetClientUnpauseCalls() {
	mock.lockClientUnpause.Lock()
	mock.calls.ClientUnpause = nil
	mock.lockClientUnpause.Unlock()
}

// ClusterAddSlots calls ClusterAddSlotsFunc.
func (mock *MoqCmdable) ClusterAddSlots(ctx context.Context, slots ...int) *redis.StatusCmd {
	if mock.ClusterAddSlotsFunc == nil {
		panic("MoqCmdable.ClusterAddSlotsFunc: method is nil but Cmdable.ClusterAddSlots was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Slots []int
	}{
		Ctx:   ctx,
		Slots: slots,
	}
	mock.lockClusterAddSlots.Lock()
	mock.calls.ClusterAddSlots = append(mock.calls.ClusterAddSlots, callInfo)
	mock.lockClusterAddSlots.Unlock()
	return mock.ClusterAddSlotsFunc(ctx, slots...)
}

// ClusterAddSlotsCalls gets all the calls that were made to ClusterAddSlots.
// Check the length with:
//
//	len(mockedCmdable.ClusterAddSlotsCalls())
func (mock *MoqCmdable) ClusterAddSlotsCalls() []struct {
	Ctx   context.Context
	Slots []int
} {
	var calls []struct {
		Ctx   context.Context
		Slots []int
	}
	mock.lockClusterAddSlots.RLock()
	calls = mock.calls.ClusterAddSlots
	mock.lockClusterAddSlots.RUnlock()
	return calls
}

// ResetClusterAddSlotsCalls reset all the calls that were made to ClusterAddSlots.
func (mock *MoqCmdable) ResetClusterAddSlotsCalls() {
	mock.lockClusterAddSlots.Lock()
	mock.calls.ClusterAddSlots = nil
	mock.lockClusterAddSlots.Unlock()
}

// ClusterAddSlotsRange calls ClusterAddSlotsRangeFunc.
func (mock *MoqCmdable) ClusterAddSlotsRange(ctx context.Context, min int, max int) *redis.StatusCmd {
	if mock.ClusterAddSlotsRangeFunc == nil {
		panic("MoqCmdable.ClusterAddSlotsRangeFunc: method is nil but Cmdable.ClusterAddSlotsRange was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Min int
		Max int
	}{
		Ctx: ctx,
		Min: min,
		Max: max,
	}
	mock.lockClusterAddSlotsRange.Lock()
	mock.calls.ClusterAddSlotsRange = append(mock.calls.ClusterAddSlotsRange, callInfo)
	mock.lockClusterAddSlotsRange.Unlock()
	return mock.ClusterAddSlotsRangeFunc(ctx, min, max)
}

// ClusterAddSlotsRangeCalls gets all the calls that were made to ClusterAddSlotsRange.
// Check the length with:
//
//	len(mockedCmdable.ClusterAddSlotsRangeCalls())
func (mock *MoqCmdable) ClusterAddSlotsRangeCalls() []struct {
	Ctx context.Context
	Min int
	Max int
} {
	var calls []struct {
		Ctx context.Context
		Min int
		Max int
	}
	mock.lockClusterAddSlotsRange.RLock()
	calls = mock.calls.ClusterAddSlotsRange
	mock.lockClusterAddSlotsRange.RUnlock()
	return calls
}

// ResetClusterAddSlotsRangeCalls reset all the calls that were made to ClusterAddSlotsRange.
func (mock *MoqCmdable) ResetClusterAddSlotsRangeCalls() {
	mock.lockClusterAddSlotsRange.Lock()
	mock.calls.ClusterAddSlotsRange = nil
	mock.lockClusterAddSlotsRange.Unlock()
}

// ClusterCountFailureReports calls ClusterCountFailureReportsFunc.
func (mock *MoqCmdable) ClusterCountFailureReports(ctx context.Context, nodeID string) *redis.IntCmd {
	if mock.ClusterCountFailureReportsFunc == nil {
		panic("MoqCmdable.ClusterCountFailureReportsFunc: method is nil but Cmdable.ClusterCountFailureReports was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		NodeID string
	}{
		Ctx:    ctx,
		NodeID: nodeID,
	}
	mock.lockClusterCountFailureReports.Lock()
	mock.calls.ClusterCountFailureReports = append(mock.calls.ClusterCountFailureReports, callInfo)
	mock.lockClusterCountFailureReports.Unlock()
	return mock.ClusterCountFailureReportsFunc(ctx, nodeID)
}

// ClusterCountFailureReportsCalls gets all the calls that were made to ClusterCountFailureReports.
// Check the length with:
//
//	len(mockedCmdable.ClusterCountFailureReportsCalls())
func (mock *MoqCmdable) ClusterCountFailureReportsCalls() []struct {
	Ctx    context.Context
	NodeID string
} {
	var calls []struct {
		Ctx    context.Context
		NodeID string
	}
	mock.lockClusterCountFailureReports.RLock()
	calls = mock.calls.ClusterCountFailureReports
	mock.lockClusterCountFailureReports.RUnlock()
	return calls
}

// ResetClusterCountFailureReportsCalls reset all the calls that were made to ClusterCountFailureReports.
func (mock *MoqCmdable) ResetClusterCountFailureReportsCalls() {
	mock.lockClusterCountFailureReports.Lock()
	mock.calls.ClusterCountFailureReports = nil
	mock.lockClusterCountFailureReports.Unlock()
}

// ClusterCountKeysInSlot calls ClusterCountKeysInSlotFunc.
func (mock *MoqCmdable) ClusterCountKeysInSlot(ctx context.Context, slot int) *redis.IntCmd {
	if mock.ClusterCountKeysInSlotFunc == nil {
		panic("MoqCmdable.ClusterCountKeysInSlotFunc: method is nil but Cmdable.ClusterCountKeysInSlot was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Slot int
	}{
		Ctx:  ctx,
		Slot: slot,
	}
	mock.lockClusterCountKeysInSlot.Lock()
	mock.calls.ClusterCountKeysInSlot = append(mock.calls.ClusterCountKeysInSlot, callInfo)
	mock.lockClusterCountKeysInSlot.Unlock()
	return mock.ClusterCountKeysInSlotFunc(ctx, slot)
}

// ClusterCountKeysInSlotCalls gets all the calls that were made to ClusterCountKeysInSlot.
// Check the length with:
//
//	len(mockedCmdable.ClusterCountKeysInSlotCalls())
func (mock *MoqCmdable) ClusterCountKeysInSlotCalls() []struct {
	Ctx  context.Context
	Slot int
} {
	var calls []struct {
		Ctx  context.Context
		Slot int
	}
	mock.lockClusterCountKeysInSlot.RLock()
	calls = mock.calls.ClusterCountKeysInSlot
	mock.lockClusterCountKeysInSlot.RUnlock()
	return calls
}

// ResetClusterCountKeysInSlotCalls reset all the calls that were made to ClusterCountKeysInSlot.
func (mock *MoqCmdable) ResetClusterCountKeysInSlotCalls() {
	mock.lockClusterCountKeysInSlot.Lock()
	mock.calls.ClusterCountKeysInSlot = nil
	mock.lockClusterCountKeysInSlot.Unlock()
}

// ClusterDelSlots calls ClusterDelSlotsFunc.
func (mock *MoqCmdable) ClusterDelSlots(ctx context.Context, slots ...int) *redis.StatusCmd {
	if mock.ClusterDelSlotsFunc == nil {
		panic("MoqCmdable.ClusterDelSlotsFunc: method is nil but Cmdable.ClusterDelSlots was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Slots []int
	}{
		Ctx:   ctx,
		Slots: slots,
	}
	mock.lockClusterDelSlots.Lock()
	mock.calls.ClusterDelSlots = append(mock.calls.ClusterDelSlots, callInfo)
	mock.lockClusterDelSlots.Unlock()
	return mock.ClusterDelSlotsFunc(ctx, slots...)
}

// ClusterDelSlotsCalls gets all the calls that were made to ClusterDelSlots.
// Check the length with:
//
//	len(mockedCmdable.ClusterDelSlotsCalls())
func (mock *MoqCmdable) ClusterDelSlotsCalls() []struct {
	Ctx   context.Context
	Slots []int
} {
	var calls []struct {
		Ctx   context.Context
		Slots []int
	}
	mock.lockClusterDelSlots.RLock()
	calls = mock.calls.ClusterDelSlots
	mock.lockClusterDelSlots.RUnlock()
	return calls
}

// ResetClusterDelSlotsCalls reset all the calls that were made to ClusterDelSlots.
func (mock *MoqCmdable) ResetClusterDelSlotsCalls() {
	mock.lockClusterDelSlots.Lock()
	mock.calls.ClusterDelSlots = nil
	mock.lockClusterDelSlots.Unlock()
}

// ClusterDelSlotsRange calls ClusterDelSlotsRangeFunc.
func (mock *MoqCmdable) ClusterDelSlotsRange(ctx context.Context, min int, max int) *redis.StatusCmd {
	if mock.ClusterDelSlotsRangeFunc == nil {
		panic("MoqCmdable.ClusterDelSlotsRangeFunc: method is nil but Cmdable.ClusterDelSlotsRange was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Min int
		Max int
	}{
		Ctx: ctx,
		Min: min,
		Max: max,
	}
	mock.lockClusterDelSlotsRange.Lock()
	mock.calls.ClusterDelSlotsRange = append(mock.calls.ClusterDelSlotsRange, callInfo)
	mock.lockClusterDelSlotsRange.Unlock()
	return mock.ClusterDelSlotsRangeFunc(ctx, min, max)
}

// ClusterDelSlotsRangeCalls gets all the calls that were made to ClusterDelSlotsRange.
// Check the length with:
//
//	len(mockedCmdable.ClusterDelSlotsRangeCalls())
func (mock *MoqCmdable) ClusterDelSlotsRangeCalls() []struct {
	Ctx context.Context
	Min int
	Max int
} {
	var calls []struct {
		Ctx context.Context
		Min int
		Max int
	}
	mock.lockClusterDelSlotsRange.RLock()
	calls = mock.calls.ClusterDelSlotsRange
	mock.lockClusterDelSlotsRange.RUnlock()
	return calls
}

// ResetClusterDelSlotsRangeCalls reset all the calls that were made to ClusterDelSlotsRange.
func (mock *MoqCmdable) ResetClusterDelSlotsRangeCalls() {
	mock.lockClusterDelSlotsRange.Lock()
	mock.calls.ClusterDelSlotsRange = nil
	mock.lockClusterDelSlotsRange.Unlock()
}

// ClusterFailover calls ClusterFailoverFunc.
func (mock *MoqCmdable) ClusterFailover(ctx context.Context) *redis.StatusCmd {
	if mock.ClusterFailoverFunc == nil {
		panic("MoqCmdable.ClusterFailoverFunc: method is nil but Cmdable.ClusterFailover was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockClusterFailover.Lock()
	mock.calls.ClusterFailover = append(mock.calls.ClusterFailover, callInfo)
	mock.lockClusterFailover.Unlock()
	return mock.ClusterFailoverFunc(ctx)
}

// ClusterFailoverCalls gets all the calls that were made to ClusterFailover.
// Check the length with:
//
//	len(mockedCmdable.ClusterFailoverCalls())
func (mock *MoqCmdable) ClusterFailoverCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockClusterFailover.RLock()
	calls = mock.calls.ClusterFailover
	mock.lockClusterFailover.RUnlock()
	return calls
}

// ResetClusterFailoverCalls reset all the calls that were made to ClusterFailover.
func (mock *MoqCmdable) ResetClusterFailoverCalls() {
	mock.lockClusterFailover.Lock()
	mock.calls.ClusterFailover = nil
	mock.lockClusterFailover.Unlock()
}

// ClusterForget calls ClusterForgetFunc.
func (mock *MoqCmdable) ClusterForget(ctx context.Context, nodeID string) *redis.StatusCmd {
	if mock.ClusterForgetFunc == nil {
		panic("MoqCmdable.ClusterForgetFunc: method is nil but Cmdable.ClusterForget was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		NodeID string
	}{
		Ctx:    ctx,
		NodeID: nodeID,
	}
	mock.lockClusterForget.Lock()
	mock.calls.ClusterForget = append(mock.calls.ClusterForget, callInfo)
	mock.lockClusterForget.Unlock()
	return mock.ClusterForgetFunc(ctx, nodeID)
}

// ClusterForgetCalls gets all the calls that were made to ClusterForget.
// Check the length with:
//
//	len(mockedCmdable.ClusterForgetCalls())
func (mock *MoqCmdable) ClusterForgetCalls() []struct {
	Ctx    context.Context
	NodeID string
} {
	var calls []struct {
		Ctx    context.Context
		NodeID string
	}
	mock.lockClusterForget.RLock()
	calls = mock.calls.ClusterForget
	mock.lockClusterForget.RUnlock()
	return calls
}

// ResetClusterForgetCalls reset all the calls that were made to ClusterForget.
func (mock *MoqCmdable) ResetClusterForgetCalls() {
	mock.lockClusterForget.Lock()
	mock.calls.ClusterForget = nil
	mock.lockClusterForget.Unlock()
}

// ClusterGetKeysInSlot calls ClusterGetKeysInSlotFunc.
func (mock *MoqCmdable) ClusterGetKeysInSlot(ctx context.Context, slot int, count int) *redis.StringSliceCmd {
	if mock.ClusterGetKeysInSlotFunc == nil {
		panic("MoqCmdable.ClusterGetKeysInSlotFunc: method is nil but Cmdable.ClusterGetKeysInSlot was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Slot  int
		Count int
	}{
		Ctx:   ctx,
		Slot:  slot,
		Count: count,
	}
	mock.lockClusterGetKeysInSlot.Lock()
	mock.calls.ClusterGetKeysInSlot = append(mock.calls.ClusterGetKeysInSlot, callInfo)
	mock.lockClusterGetKeysInSlot.Unlock()
	return mock.ClusterGetKeysInSlotFunc(ctx, slot, count)
}

// ClusterGetKeysInSlotCalls gets all the calls that were made to ClusterGetKeysInSlot.
// Check the length with:
//
//	len(mockedCmdable.ClusterGetKeysInSlotCalls())
func (mock *MoqCmdable) ClusterGetKeysInSlotCalls() []struct {
	Ctx   context.Context
	Slot  int
	Count int
} {
	var calls []struct {
		Ctx   context.Context
		Slot  int
		Count int
	}
	mock.lockClusterGetKeysInSlot.RLock()
	calls = mock.calls.ClusterGetKeysInSlot
	mock.lockClusterGetKeysInSlot.RUnlock()
	return calls
}

// ResetClusterGetKeysInSlotCalls reset all the calls that were made to ClusterGetKeysInSlot.
func (mock *MoqCmdable) ResetClusterGetKeysInSlotCalls() {
	mock.lockClusterGetKeysInSlot.Lock()
	mock.calls.ClusterGetKeysInSlot = nil
	mock.lockClusterGetKeysInSlot.Unlock()
}

// ClusterInfo calls ClusterInfoFunc.
func (mock *MoqCmdable) ClusterInfo(ctx context.Context) *redis.StringCmd {
	if mock.ClusterInfoFunc == nil {
		panic("MoqCmdable.ClusterInfoFunc: method is nil but Cmdable.ClusterInfo was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockClusterInfo.Lock()
	mock.calls.ClusterInfo = append(mock.calls.ClusterInfo, callInfo)
	mock.lockClusterInfo.Unlock()
	return mock.ClusterInfoFunc(ctx)
}

// ClusterInfoCalls gets all the calls that were made to ClusterInfo.
// Check the length with:
//
//	len(mockedCmdable.ClusterInfoCalls())
func (mock *MoqCmdable) ClusterInfoCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockClusterInfo.RLock()
	calls = mock.calls.ClusterInfo
	mock.lockClusterInfo.RUnlock()
	return calls
}

// ResetClusterInfoCalls reset all the calls that were made to ClusterInfo.
func (mock *MoqCmdable) ResetClusterInfoCalls() {
	mock.lockClusterInfo.Lock()
	mock.calls.ClusterInfo = nil
	mock.lockClusterInfo.Unlock()
}

// ClusterKeySlot calls ClusterKeySlotFunc.
func (mock *MoqCmdable) ClusterKeySlot(ctx context.Context, key string) *redis.IntCmd {
	if mock.ClusterKeySlotFunc == nil {
		panic("MoqCmdable.ClusterKeySlotFunc: method is nil but Cmdable.ClusterKeySlot was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockClusterKeySlot.Lock()
	mock.calls.ClusterKeySlot = append(mock.calls.ClusterKeySlot, callInfo)
	mock.lockClusterKeySlot.Unlock()
	return mock.ClusterKeySlotFunc(ctx, key)
}

// ClusterKeySlotCalls gets all the calls that were made to ClusterKeySlot.
// Check the length with:
//
//	len(mockedCmdable.ClusterKeySlotCalls())
func (mock *MoqCmdable) ClusterKeySlotCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockClusterKeySlot.RLock()
	calls = mock.calls.ClusterKeySlot
	mock.lockClusterKeySlot.RUnlock()
	return calls
}

// ResetClusterKeySlotCalls reset all the calls that were made to ClusterKeySlot.
func (mock *MoqCmdable) ResetClusterKeySlotCalls() {
	mock.lockClusterKeySlot.Lock()
	mock.calls.ClusterKeySlot = nil
	mock.lockClusterKeySlot.Unlock()
}

// ClusterLinks calls ClusterLinksFunc.
func (mock *MoqCmdable) ClusterLinks(ctx context.Context) *redis.ClusterLinksCmd {
	if mock.ClusterLinksFunc == nil {
		panic("MoqCmdable.ClusterLinksFunc: method is nil but Cmdable.ClusterLinks was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockClusterLinks.Lock()
	mock.calls.ClusterLinks = append(mock.calls.ClusterLinks, callInfo)
	mock.lockClusterLinks.Unlock()
	return mock.ClusterLinksFunc(ctx)
}

// ClusterLinksCalls gets all the calls that were made to ClusterLinks.
// Check the length with:
//
//	len(mockedCmdable.ClusterLinksCalls())
func (mock *MoqCmdable) ClusterLinksCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockClusterLinks.RLock()
	calls = mock.calls.ClusterLinks
	mock.lockClusterLinks.RUnlock()
	return calls
}

// ResetClusterLinksCalls reset all the calls that were made to ClusterLinks.
func (mock *MoqCmdable) ResetClusterLinksCalls() {
	mock.lockClusterLinks.Lock()
	mock.calls.ClusterLinks = nil
	mock.lockClusterLinks.Unlock()
}

// ClusterMeet calls ClusterMeetFunc.
func (mock *MoqCmdable) ClusterMeet(ctx context.Context, host string, port string) *redis.StatusCmd {
	if mock.ClusterMeetFunc == nil {
		panic("MoqCmdable.ClusterMeetFunc: method is nil but Cmdable.ClusterMeet was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Host string
		Port string
	}{
		Ctx:  ctx,
		Host: host,
		Port: port,
	}
	mock.lockClusterMeet.Lock()
	mock.calls.ClusterMeet = append(mock.calls.ClusterMeet, callInfo)
	mock.lockClusterMeet.Unlock()
	return mock.ClusterMeetFunc(ctx, host, port)
}

// ClusterMeetCalls gets all the calls that were made to ClusterMeet.
// Check the length with:
//
//	len(mockedCmdable.ClusterMeetCalls())
func (mock *MoqCmdable) ClusterMeetCalls() []struct {
	Ctx  context.Context
	Host string
	Port string
} {
	var calls []struct {
		Ctx  context.Context
		Host string
		Port string
	}
	mock.lockClusterMeet.RLock()
	calls = mock.calls.ClusterMeet
	mock.lockClusterMeet.RUnlock()
	return calls
}

// ResetClusterMeetCalls reset all the calls that were made to ClusterMeet.
func (mock *MoqCmdable) ResetClusterMeetCalls() {
	mock.lockClusterMeet.Lock()
	mock.calls.ClusterMeet = nil
	mock.lockClusterMeet.Unlock()
}

// ClusterMyID calls ClusterMyIDFunc.
func (mock *MoqCmdable) ClusterMyID(ctx context.Context) *redis.StringCmd {
	if mock.ClusterMyIDFunc == nil {
		panic("MoqCmdable.ClusterMyIDFunc: method is nil but Cmdable.ClusterMyID was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockClusterMyID.Lock()
	mock.calls.ClusterMyID = append(mock.calls.ClusterMyID, callInfo)
	mock.lockClusterMyID.Unlock()
	return mock.ClusterMyIDFunc(ctx)
}

// ClusterMyIDCalls gets all the calls that were made to ClusterMyID.
// Check the length with:
//
//	len(mockedCmdable.ClusterMyIDCalls())
func (mock *MoqCmdable) ClusterMyIDCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockClusterMyID.RLock()
	calls = mock.calls.ClusterMyID
	mock.lockClusterMyID.RUnlock()
	return calls
}

// ResetClusterMyIDCalls reset all the calls that were made to ClusterMyID.
func (mock *MoqCmdable) ResetClusterMyIDCalls() {
	mock.lockClusterMyID.Lock()
	mock.calls.ClusterMyID = nil
	mock.lockClusterMyID.Unlock()
}

// ClusterMyShardID calls ClusterMyShardIDFunc.
func (mock *MoqCmdable) ClusterMyShardID(ctx context.Context) *redis.StringCmd {
	if mock.ClusterMyShardIDFunc == nil {
		panic("MoqCmdable.ClusterMyShardIDFunc: method is nil but Cmdable.ClusterMyShardID was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockClusterMyShardID.Lock()
	mock.calls.ClusterMyShardID = append(mock.calls.ClusterMyShardID, callInfo)
	mock.lockClusterMyShardID.Unlock()
	return mock.ClusterMyShardIDFunc(ctx)
}

// ClusterMyShardIDCalls gets all the calls that were made to ClusterMyShardID.
// Check the length with:
//
//	len(mockedCmdable.ClusterMyShardIDCalls())
func (mock *MoqCmdable) ClusterMyShardIDCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockClusterMyShardID.RLock()
	calls = mock.calls.ClusterMyShardID
	mock.lockClusterMyShardID.RUnlock()
	return calls
}

// ResetClusterMyShardIDCalls reset all the calls that were made to ClusterMyShardID.
func (mock *MoqCmdable) ResetClusterMyShardIDCalls() {
	mock.lockClusterMyShardID.Lock()
	mock.calls.ClusterMyShardID = nil
	mock.lockClusterMyShardID.Unlock()
}

// ClusterNodes calls ClusterNodesFunc.
func (mock *MoqCmdable) ClusterNodes(ctx context.Context) *redis.StringCmd {
	if mock.ClusterNodesFunc == nil {
		panic("MoqCmdable.ClusterNodesFunc: method is nil but Cmdable.ClusterNodes was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockClusterNodes.Lock()
	mock.calls.ClusterNodes = append(mock.calls.ClusterNodes, callInfo)
	mock.lockClusterNodes.Unlock()
	return mock.ClusterNodesFunc(ctx)
}

// ClusterNodesCalls gets all the calls that were made to ClusterNodes.
// Check the length with:
//
//	len(mockedCmdable.ClusterNodesCalls())
func (mock *MoqCmdable) ClusterNodesCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockClusterNodes.RLock()
	calls = mock.calls.ClusterNodes
	mock.lockClusterNodes.RUnlock()
	return calls
}

// ResetClusterNodesCalls reset all the calls that were made to ClusterNodes.
func (mock *MoqCmdable) ResetClusterNodesCalls() {
	mock.lockClusterNodes.Lock()
	mock.calls.ClusterNodes = nil
	mock.lockClusterNodes.Unlock()
}

// ClusterReplicate calls ClusterReplicateFunc.
func (mock *MoqCmdable) ClusterReplicate(ctx context.Context, nodeID string) *redis.StatusCmd {
	if mock.ClusterReplicateFunc == nil {
		panic("MoqCmdable.ClusterReplicateFunc: method is nil but Cmdable.ClusterReplicate was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		NodeID string
	}{
		Ctx:    ctx,
		NodeID: nodeID,
	}
	mock.lockClusterReplicate.Lock()
	mock.calls.ClusterReplicate = append(mock.calls.ClusterReplicate, callInfo)
	mock.lockClusterReplicate.Unlock()
	return mock.ClusterReplicateFunc(ctx, nodeID)
}

// ClusterReplicateCalls gets all the calls that were made to ClusterReplicate.
// Check the length with:
//
//	len(mockedCmdable.ClusterReplicateCalls())
func (mock *MoqCmdable) ClusterReplicateCalls() []struct {
	Ctx    context.Context
	NodeID string
} {
	var calls []struct {
		Ctx    context.Context
		NodeID string
	}
	mock.lockClusterReplicate.RLock()
	calls = mock.calls.ClusterReplicate
	mock.lockClusterReplicate.RUnlock()
	return calls
}

// ResetClusterReplicateCalls reset all the calls that were made to ClusterReplicate.
func (mock *MoqCmdable) ResetClusterReplicateCalls() {
	mock.lockClusterReplicate.Lock()
	mock.calls.ClusterReplicate = nil
	mock.lockClusterReplicate.Unlock()
}

// ClusterResetHard calls ClusterResetHardFunc.
func (mock *MoqCmdable) ClusterResetHard(ctx context.Context) *redis.StatusCmd {
	if mock.ClusterResetHardFunc == nil {
		panic("MoqCmdable.ClusterResetHardFunc: method is nil but Cmdable.ClusterResetHard was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockClusterResetHard.Lock()
	mock.calls.ClusterResetHard = append(mock.calls.ClusterResetHard, callInfo)
	mock.lockClusterResetHard.Unlock()
	return mock.ClusterResetHardFunc(ctx)
}

// ClusterResetHardCalls gets all the calls that were made to ClusterResetHard.
// Check the length with:
//
//	len(mockedCmdable.ClusterResetHardCalls())
func (mock *MoqCmdable) ClusterResetHardCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockClusterResetHard.RLock()
	calls = mock.calls.ClusterResetHard
	mock.lockClusterResetHard.RUnlock()
	return calls
}

// ResetClusterResetHardCalls reset all the calls that were made to ClusterResetHard.
func (mock *MoqCmdable) ResetClusterResetHardCalls() {
	mock.lockClusterResetHard.Lock()
	mock.calls.ClusterResetHard = nil
	mock.lockClusterResetHard.Unlock()
}

// ClusterResetSoft calls ClusterResetSoftFunc.
func (mock *MoqCmdable) ClusterResetSoft(ctx context.Context) *redis.StatusCmd {
	if mock.ClusterResetSoftFunc == nil {
		panic("MoqCmdable.ClusterResetSoftFunc: method is nil but Cmdable.ClusterResetSoft was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockClusterResetSoft.Lock()
	mock.calls.ClusterResetSoft = append(mock.calls.ClusterResetSoft, callInfo)
	mock.lockClusterResetSoft.Unlock()
	return mock.ClusterResetSoftFunc(ctx)
}

// ClusterResetSoftCalls gets all the calls that were made to ClusterResetSoft.
// Check the length with:
//
//	len(mockedCmdable.ClusterResetSoftCalls())
func (mock *MoqCmdable) ClusterResetSoftCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockClusterResetSoft.RLock()
	calls = mock.calls.ClusterResetSoft
	mock.lockClusterResetSoft.RUnlock()
	return calls
}

// ResetClusterResetSoftCalls reset all the calls that were made to ClusterResetSoft.
func (mock *MoqCmdable) ResetClusterResetSoftCalls() {
	mock.lockClusterResetSoft.Lock()
	mock.calls.ClusterResetSoft = nil
	mock.lockClusterResetSoft.Unlock()
}

// ClusterSaveConfig calls ClusterSaveConfigFunc.
func (mock *MoqCmdable) ClusterSaveConfig(ctx context.Context) *redis.StatusCmd {
	if mock.ClusterSaveConfigFunc == nil {
		panic("MoqCmdable.ClusterSaveConfigFunc: method is nil but Cmdable.ClusterSaveConfig was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockClusterSaveConfig.Lock()
	mock.calls.ClusterSaveConfig = append(mock.calls.ClusterSaveConfig, callInfo)
	mock.lockClusterSaveConfig.Unlock()
	return mock.ClusterSaveConfigFunc(ctx)
}

// ClusterSaveConfigCalls gets all the calls that were made to ClusterSaveConfig.
// Check the length with:
//
//	len(mockedCmdable.ClusterSaveConfigCalls())
func (mock *MoqCmdable) ClusterSaveConfigCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockClusterSaveConfig.RLock()
	calls = mock.calls.ClusterSaveConfig
	mock.lockClusterSaveConfig.RUnlock()
	return calls
}

// ResetClusterSaveConfigCalls reset all the calls that were made to ClusterSaveConfig.
func (mock *MoqCmdable) ResetClusterSaveConfigCalls() {
	mock.lockClusterSaveConfig.Lock()
	mock.calls.ClusterSaveConfig = nil
	mock.lockClusterSaveConfig.Unlock()
}

// ClusterShards calls ClusterShardsFunc.
func (mock *MoqCmdable) ClusterShards(ctx context.Context) *redis.ClusterShardsCmd {
	if mock.ClusterShardsFunc == nil {
		panic("MoqCmdable.ClusterShardsFunc: method is nil but Cmdable.ClusterShards was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockClusterShards.Lock()
	mock.calls.ClusterShards = append(mock.calls.ClusterShards, callInfo)
	mock.lockClusterShards.Unlock()
	return mock.ClusterShardsFunc(ctx)
}

// ClusterShardsCalls gets all the calls that were made to ClusterShards.
// Check the length with:
//
//	len(mockedCmdable.ClusterShardsCalls())
func (mock *MoqCmdable) ClusterShardsCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockClusterShards.RLock()
	calls = mock.calls.ClusterShards
	mock.lockClusterShards.RUnlock()
	return calls
}

// ResetClusterShardsCalls reset all the calls that were made to ClusterShards.
func (mock *MoqCmdable) ResetClusterShardsCalls() {
	mock.lockClusterShards.Lock()
	mock.calls.ClusterShards = nil
	mock.lockClusterShards.Unlock()
}

// ClusterSlaves calls ClusterSlavesFunc.
func (mock *MoqCmdable) ClusterSlaves(ctx context.Context, nodeID string) *redis.StringSliceCmd {
	if mock.ClusterSlavesFunc == nil {
		panic("MoqCmdable.ClusterSlavesFunc: method is nil but Cmdable.ClusterSlaves was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		NodeID string
	}{
		Ctx:    ctx,
		NodeID: nodeID,
	}
	mock.lockClusterSlaves.Lock()
	mock.calls.ClusterSlaves = append(mock.calls.ClusterSlaves, callInfo)
	mock.lockClusterSlaves.Unlock()
	return mock.ClusterSlavesFunc(ctx, nodeID)
}

// ClusterSlavesCalls gets all the calls that were made to ClusterSlaves.
// Check the length with:
//
//	len(mockedCmdable.ClusterSlavesCalls())
func (mock *MoqCmdable) ClusterSlavesCalls() []struct {
	Ctx    context.Context
	NodeID string
} {
	var calls []struct {
		Ctx    context.Context
		NodeID string
	}
	mock.lockClusterSlaves.RLock()
	calls = mock.calls.ClusterSlaves
	mock.lockClusterSlaves.RUnlock()
	return calls
}

// ResetClusterSlavesCalls reset all the calls that were made to ClusterSlaves.
func (mock *MoqCmdable) ResetClusterSlavesCalls() {
	mock.lockClusterSlaves.Lock()
	mock.calls.ClusterSlaves = nil
	mock.lockClusterSlaves.Unlock()
}

// ClusterSlots calls ClusterSlotsFunc.
func (mock *MoqCmdable) ClusterSlots(ctx context.Context) *redis.ClusterSlotsCmd {
	if mock.ClusterSlotsFunc == nil {
		panic("MoqCmdable.ClusterSlotsFunc: method is nil but Cmdable.ClusterSlots was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockClusterSlots.Lock()
	mock.calls.ClusterSlots = append(mock.calls.ClusterSlots, callInfo)
	mock.lockClusterSlots.Unlock()
	return mock.ClusterSlotsFunc(ctx)
}

// ClusterSlotsCalls gets all the calls that were made to ClusterSlots.
// Check the length with:
//
//	len(mockedCmdable.ClusterSlotsCalls())
func (mock *MoqCmdable) ClusterSlotsCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockClusterSlots.RLock()
	calls = mock.calls.ClusterSlots
	mock.lockClusterSlots.RUnlock()
	return calls
}

// ResetClusterSlotsCalls reset all the calls that were made to ClusterSlots.
func (mock *MoqCmdable) ResetClusterSlotsCalls() {
	mock.lockClusterSlots.Lock()
	mock.calls.ClusterSlots = nil
	mock.lockClusterSlots.Unlock()
}

// Command calls CommandFunc.
func (mock *MoqCmdable) Command(ctx context.Context) *redis.CommandsInfoCmd {
	if mock.CommandFunc == nil {
		panic("MoqCmdable.CommandFunc: method is nil but Cmdable.Command was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockCommand.Lock()
	mock.calls.Command = append(mock.calls.Command, callInfo)
	mock.lockCommand.Unlock()
	return mock.CommandFunc(ctx)
}

// CommandCalls gets all the calls that were made to Command.
// Check the length with:
//
//	len(mockedCmdable.CommandCalls())
func (mock *MoqCmdable) CommandCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockCommand.RLock()
	calls = mock.calls.Command
	mock.lockCommand.RUnlock()
	return calls
}

// ResetCommandCalls reset all the calls that were made to Command.
func (mock *MoqCmdable) ResetCommandCalls() {
	mock.lockCommand.Lock()
	mock.calls.Command = nil
	mock.lockCommand.Unlock()
}

// CommandGetKeys calls CommandGetKeysFunc.
func (mock *MoqCmdable) CommandGetKeys(ctx context.Context, commands ...interface{}) *redis.StringSliceCmd {
	if mock.CommandGetKeysFunc == nil {
		panic("MoqCmdable.CommandGetKeysFunc: method is nil but Cmdable.CommandGetKeys was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Commands []interface{}
	}{
		Ctx:      ctx,
		Commands: commands,
	}
	mock.lockCommandGetKeys.Lock()
	mock.calls.CommandGetKeys = append(mock.calls.CommandGetKeys, callInfo)
	mock.lockCommandGetKeys.Unlock()
	return mock.CommandGetKeysFunc(ctx, commands...)
}

// CommandGetKeysCalls gets all the calls that were made to CommandGetKeys.
// Check the length with:
//
//	len(mockedCmdable.CommandGetKeysCalls())
func (mock *MoqCmdable) CommandGetKeysCalls() []struct {
	Ctx      context.Context
	Commands []interface{}
} {
	var calls []struct {
		Ctx      context.Context
		Commands []interface{}
	}
	mock.lockCommandGetKeys.RLock()
	calls = mock.calls.CommandGetKeys
	mock.lockCommandGetKeys.RUnlock()
	return calls
}

// ResetCommandGetKeysCalls reset all the calls that were made to CommandGetKeys.
func (mock *MoqCmdable) ResetCommandGetKeysCalls() {
	mock.lockCommandGetKeys.Lock()
	mock.calls.CommandGetKeys = nil
	mock.lockCommandGetKeys.Unlock()
}

// CommandGetKeysAndFlags calls CommandGetKeysAndFlagsFunc.
func (mock *MoqCmdable) CommandGetKeysAndFlags(ctx context.Context, commands ...interface{}) *redis.KeyFlagsCmd {
	if mock.CommandGetKeysAndFlagsFunc == nil {
		panic("MoqCmdable.CommandGetKeysAndFlagsFunc: method is nil but Cmdable.CommandGetKeysAndFlags was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Commands []interface{}
	}{
		Ctx:      ctx,
		Commands: commands,
	}
	mock.lockCommandGetKeysAndFlags.Lock()
	mock.calls.CommandGetKeysAndFlags = append(mock.calls.CommandGetKeysAndFlags, callInfo)
	mock.lockCommandGetKeysAndFlags.Unlock()
	return mock.CommandGetKeysAndFlagsFunc(ctx, commands...)
}

// CommandGetKeysAndFlagsCalls gets all the calls that were made to CommandGetKeysAndFlags.
// Check the length with:
//
//	len(mockedCmdable.CommandGetKeysAndFlagsCalls())
func (mock *MoqCmdable) CommandGetKeysAndFlagsCalls() []struct {
	Ctx      context.Context
	Commands []interface{}
} {
	var calls []struct {
		Ctx      context.Context
		Commands []interface{}
	}
	mock.lockCommandGetKeysAndFlags.RLock()
	calls = mock.calls.CommandGetKeysAndFlags
	mock.lockCommandGetKeysAndFlags.RUnlock()
	return calls
}

// ResetCommandGetKeysAndFlagsCalls reset all the calls that were made to CommandGetKeysAndFlags.
func (mock *MoqCmdable) ResetCommandGetKeysAndFlagsCalls() {
	mock.lockCommandGetKeysAndFlags.Lock()
	mock.calls.CommandGetKeysAndFlags = nil
	mock.lockCommandGetKeysAndFlags.Unlock()
}

// CommandList calls CommandListFunc.
func (mock *MoqCmdable) CommandList(ctx context.Context, filter *redis.FilterBy) *redis.StringSliceCmd {
	if mock.CommandListFunc == nil {
		panic("MoqCmdable.CommandListFunc: method is nil but Cmdable.CommandList was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Filter *redis.FilterBy
	}{
		Ctx:    ctx,
		Filter: filter,
	}
	mock.lockCommandList.Lock()
	mock.calls.CommandList = append(mock.calls.CommandList, callInfo)
	mock.lockCommandList.Unlock()
	return mock.CommandListFunc(ctx, filter)
}

// CommandListCalls gets all the calls that were made to CommandList.
// Check the length with:
//
//	len(mockedCmdable.CommandListCalls())
func (mock *MoqCmdable) CommandListCalls() []struct {
	Ctx    context.Context
	Filter *redis.FilterBy
} {
	var calls []struct {
		Ctx    context.Context
		Filter *redis.FilterBy
	}
	mock.lockCommandList.RLock()
	calls = mock.calls.CommandList
	mock.lockCommandList.RUnlock()
	return calls
}

// ResetCommandListCalls reset all the calls that were made to CommandList.
func (mock *MoqCmdable) ResetCommandListCalls() {
	mock.lockCommandList.Lock()
	mock.calls.CommandList = nil
	mock.lockCommandList.Unlock()
}

// ConfigGet calls ConfigGetFunc.
func (mock *MoqCmdable) ConfigGet(ctx context.Context, parameter string) *redis.MapStringStringCmd {
	if mock.ConfigGetFunc == nil {
		panic("MoqCmdable.ConfigGetFunc: method is nil but Cmdable.ConfigGet was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Parameter string
	}{
		Ctx:       ctx,
		Parameter: parameter,
	}
	mock.lockConfigGet.Lock()
	mock.calls.ConfigGet = append(mock.calls.ConfigGet, callInfo)
	mock.lockConfigGet.Unlock()
	return mock.ConfigGetFunc(ctx, parameter)
}

// ConfigGetCalls gets all the calls that were made to ConfigGet.
// Check the length with:
//
//	len(mockedCmdable.ConfigGetCalls())
func (mock *MoqCmdable) ConfigGetCalls() []struct {
	Ctx       context.Context
	Parameter string
} {
	var calls []struct {
		Ctx       context.Context
		Parameter string
	}
	mock.lockConfigGet.RLock()
	calls = mock.calls.ConfigGet
	mock.lockConfigGet.RUnlock()
	return calls
}

// ResetConfigGetCalls reset all the calls that were made to ConfigGet.
func (mock *MoqCmdable) ResetConfigGetCalls() {
	mock.lockConfigGet.Lock()
	mock.calls.ConfigGet = nil
	mock.lockConfigGet.Unlock()
}

// ConfigResetStat calls ConfigResetStatFunc.
func (mock *MoqCmdable) ConfigResetStat(ctx context.Context) *redis.StatusCmd {
	if mock.ConfigResetStatFunc == nil {
		panic("MoqCmdable.ConfigResetStatFunc: method is nil but Cmdable.ConfigResetStat was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockConfigResetStat.Lock()
	mock.calls.ConfigResetStat = append(mock.calls.ConfigResetStat, callInfo)
	mock.lockConfigResetStat.Unlock()
	return mock.ConfigResetStatFunc(ctx)
}

// ConfigResetStatCalls gets all the calls that were made to ConfigResetStat.
// Check the length with:
//
//	len(mockedCmdable.ConfigResetStatCalls())
func (mock *MoqCmdable) ConfigResetStatCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockConfigResetStat.RLock()
	calls = mock.calls.ConfigResetStat
	mock.lockConfigResetStat.RUnlock()
	return calls
}

// ResetConfigResetStatCalls reset all the calls that were made to ConfigResetStat.
func (mock *MoqCmdable) ResetConfigResetStatCalls() {
	mock.lockConfigResetStat.Lock()
	mock.calls.ConfigResetStat = nil
	mock.lockConfigResetStat.Unlock()
}

// ConfigRewrite calls ConfigRewriteFunc.
func (mock *MoqCmdable) ConfigRewrite(ctx context.Context) *redis.StatusCmd {
	if mock.ConfigRewriteFunc == nil {
		panic("MoqCmdable.ConfigRewriteFunc: method is nil but Cmdable.ConfigRewrite was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockConfigRewrite.Lock()
	mock.calls.ConfigRewrite = append(mock.calls.ConfigRewrite, callInfo)
	mock.lockConfigRewrite.Unlock()
	return mock.ConfigRewriteFunc(ctx)
}

// ConfigRewriteCalls gets all the calls that were made to ConfigRewrite.
// Check the length with:
//
//	len(mockedCmdable.ConfigRewriteCalls())
func (mock *MoqCmdable) ConfigRewriteCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockConfigRewrite.RLock()
	calls = mock.calls.ConfigRewrite
	mock.lockConfigRewrite.RUnlock()
	return calls
}

// ResetConfigRewriteCalls reset all the calls that were made to ConfigRewrite.
func (mock *MoqCmdable) ResetConfigRewriteCalls() {
	mock.lockConfigRewrite.Lock()
	mock.calls.ConfigRewrite = nil
	mock.lockConfigRewrite.Unlock()
}

// ConfigSet calls ConfigSetFunc.
func (mock *MoqCmdable) ConfigSet(ctx context.Context, parameter string, value string) *redis.StatusCmd {
	if mock.ConfigSetFunc == nil {
		panic("MoqCmdable.ConfigSetFunc: method is nil but Cmdable.ConfigSet was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Parameter string
		Value     string
	}{
		Ctx:       ctx,
		Parameter: parameter,
		Value:     value,
	}
	mock.lockConfigSet.Lock()
	mock.calls.ConfigSet = append(mock.calls.ConfigSet, callInfo)
	mock.lockConfigSet.Unlock()
	return mock.ConfigSetFunc(ctx, parameter, value)
}

// ConfigSetCalls gets all the calls that were made to ConfigSet.
// Check the length with:
//
//	len(mockedCmdable.ConfigSetCalls())
func (mock *MoqCmdable) ConfigSetCalls() []struct {
	Ctx       context.Context
	Parameter string
	Value     string
} {
	var calls []struct {
		Ctx       context.Context
		Parameter string
		Value     string
	}
	mock.lockConfigSet.RLock()
	calls = mock.calls.ConfigSet
	mock.lockConfigSet.RUnlock()
	return calls
}

// ResetConfigSetCalls reset all the calls that were made to ConfigSet.
func (mock *MoqCmdable) ResetConfigSetCalls() {
	mock.lockConfigSet.Lock()
	mock.calls.ConfigSet = nil
	mock.lockConfigSet.Unlock()
}

// Copy calls CopyFunc.
func (mock *MoqCmdable) Copy(ctx context.Context, sourceKey string, destKey string, db int, replace bool) *redis.IntCmd {
	if mock.CopyFunc == nil {
		panic("MoqCmdable.CopyFunc: method is nil but Cmdable.Copy was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		SourceKey string
		DestKey   string
		Db        int
		Replace   bool
	}{
		Ctx:       ctx,
		SourceKey: sourceKey,
		DestKey:   destKey,
		Db:        db,
		Replace:   replace,
	}
	mock.lockCopy.Lock()
	mock.calls.Copy = append(mock.calls.Copy, callInfo)
	mock.lockCopy.Unlock()
	return mock.CopyFunc(ctx, sourceKey, destKey, db, replace)
}

// CopyCalls gets all the calls that were made to Copy.
// Check the length with:
//
//	len(mockedCmdable.CopyCalls())
func (mock *MoqCmdable) CopyCalls() []struct {
	Ctx       context.Context
	SourceKey string
	DestKey   string
	Db        int
	Replace   bool
} {
	var calls []struct {
		Ctx       context.Context
		SourceKey string
		DestKey   string
		Db        int
		Replace   bool
	}
	mock.lockCopy.RLock()
	calls = mock.calls.Copy
	mock.lockCopy.RUnlock()
	return calls
}

// ResetCopyCalls reset all the calls that were made to Copy.
func (mock *MoqCmdable) ResetCopyCalls() {
	mock.lockCopy.Lock()
	mock.calls.Copy = nil
	mock.lockCopy.Unlock()
}

// DBSize calls DBSizeFunc.
func (mock *MoqCmdable) DBSize(ctx context.Context) *redis.IntCmd {
	if mock.DBSizeFunc == nil {
		panic("MoqCmdable.DBSizeFunc: method is nil but Cmdable.DBSize was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockDBSize.Lock()
	mock.calls.DBSize = append(mock.calls.DBSize, callInfo)
	mock.lockDBSize.Unlock()
	return mock.DBSizeFunc(ctx)
}

// DBSizeCalls gets all the calls that were made to DBSize.
// Check the length with:
//
//	len(mockedCmdable.DBSizeCalls())
func (mock *MoqCmdable) DBSizeCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockDBSize.RLock()
	calls = mock.calls.DBSize
	mock.lockDBSize.RUnlock()
	return calls
}

// ResetDBSizeCalls reset all the calls that were made to DBSize.
func (mock *MoqCmdable) ResetDBSizeCalls() {
	mock.lockDBSize.Lock()
	mock.calls.DBSize = nil
	mock.lockDBSize.Unlock()
}

// DebugObject calls DebugObjectFunc.
func (mock *MoqCmdable) DebugObject(ctx context.Context, key string) *redis.StringCmd {
	if mock.DebugObjectFunc == nil {
		panic("MoqCmdable.DebugObjectFunc: method is nil but Cmdable.DebugObject was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockDebugObject.Lock()
	mock.calls.DebugObject = append(mock.calls.DebugObject, callInfo)
	mock.lockDebugObject.Unlock()
	return mock.DebugObjectFunc(ctx, key)
}

// DebugObjectCalls gets all the calls that were made to DebugObject.
// Check the length with:
//
//	len(mockedCmdable.DebugObjectCalls())
func (mock *MoqCmdable) DebugObjectCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockDebugObject.RLock()
	calls = mock.calls.DebugObject
	mock.lockDebugObject.RUnlock()
	return calls
}

// ResetDebugObjectCalls reset all the calls that were made to DebugObject.
func (mock *MoqCmdable) ResetDebugObjectCalls() {
	mock.lockDebugObject.Lock()
	mock.calls.DebugObject = nil
	mock.lockDebugObject.Unlock()
}

// Decr calls DecrFunc.
func (mock *MoqCmdable) Decr(ctx context.Context, key string) *redis.IntCmd {
	if mock.DecrFunc == nil {
		panic("MoqCmdable.DecrFunc: method is nil but Cmdable.Decr was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockDecr.Lock()
	mock.calls.Decr = append(mock.calls.Decr, callInfo)
	mock.lockDecr.Unlock()
	return mock.DecrFunc(ctx, key)
}

// DecrCalls gets all the calls that were made to Decr.
// Check the length with:
//
//	len(mockedCmdable.DecrCalls())
func (mock *MoqCmdable) DecrCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockDecr.RLock()
	calls = mock.calls.Decr
	mock.lockDecr.RUnlock()
	return calls
}

// ResetDecrCalls reset all the calls that were made to Decr.
func (mock *MoqCmdable) ResetDecrCalls() {
	mock.lockDecr.Lock()
	mock.calls.Decr = nil
	mock.lockDecr.Unlock()
}

// DecrBy calls DecrByFunc.
func (mock *MoqCmdable) DecrBy(ctx context.Context, key string, decrement int64) *redis.IntCmd {
	if mock.DecrByFunc == nil {
		panic("MoqCmdable.DecrByFunc: method is nil but Cmdable.DecrBy was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Key       string
		Decrement int64
	}{
		Ctx:       ctx,
		Key:       key,
		Decrement: decrement,
	}
	mock.lockDecrBy.Lock()
	mock.calls.DecrBy = append(mock.calls.DecrBy, callInfo)
	mock.lockDecrBy.Unlock()
	return mock.DecrByFunc(ctx, key, decrement)
}

// DecrByCalls gets all the calls that were made to DecrBy.
// Check the length with:
//
//	len(mockedCmdable.DecrByCalls())
func (mock *MoqCmdable) DecrByCalls() []struct {
	Ctx       context.Context
	Key       string
	Decrement int64
} {
	var calls []struct {
		Ctx       context.Context
		Key       string
		Decrement int64
	}
	mock.lockDecrBy.RLock()
	calls = mock.calls.DecrBy
	mock.lockDecrBy.RUnlock()
	return calls
}

// ResetDecrByCalls reset all the calls that were made to DecrBy.
func (mock *MoqCmdable) ResetDecrByCalls() {
	mock.lockDecrBy.Lock()
	mock.calls.DecrBy = nil
	mock.lockDecrBy.Unlock()
}

// Del calls DelFunc.
func (mock *MoqCmdable) Del(ctx context.Context, keys ...string) *redis.IntCmd {
	if mock.DelFunc == nil {
		panic("MoqCmdable.DelFunc: method is nil but Cmdable.Del was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Keys []string
	}{
		Ctx:  ctx,
		Keys: keys,
	}
	mock.lockDel.Lock()
	mock.calls.Del = append(mock.calls.Del, callInfo)
	mock.lockDel.Unlock()
	return mock.DelFunc(ctx, keys...)
}

// DelCalls gets all the calls that were made to Del.
// Check the length with:
//
//	len(mockedCmdable.DelCalls())
func (mock *MoqCmdable) DelCalls() []struct {
	Ctx  context.Context
	Keys []string
} {
	var calls []struct {
		Ctx  context.Context
		Keys []string
	}
	mock.lockDel.RLock()
	calls = mock.calls.Del
	mock.lockDel.RUnlock()
	return calls
}

// ResetDelCalls reset all the calls that were made to Del.
func (mock *MoqCmdable) ResetDelCalls() {
	mock.lockDel.Lock()
	mock.calls.Del = nil
	mock.lockDel.Unlock()
}

// DelExArgs calls DelExArgsFunc.
func (mock *MoqCmdable) DelExArgs(ctx context.Context, key string, a redis.DelExArgs) *redis.IntCmd {
	if mock.DelExArgsFunc == nil {
		panic("MoqCmdable.DelExArgsFunc: method is nil but Cmdable.DelExArgs was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
		A   redis.DelExArgs
	}{
		Ctx: ctx,
		Key: key,
		A:   a,
	}
	mock.lockDelExArgs.Lock()
	mock.calls.DelExArgs = append(mock.calls.DelExArgs, callInfo)
	mock.lockDelExArgs.Unlock()
	return mock.DelExArgsFunc(ctx, key, a)
}

// DelExArgsCalls gets all the calls that were made to DelExArgs.
// Check the length with:
//
//	len(mockedCmdable.DelExArgsCalls())
func (mock *MoqCmdable) DelExArgsCalls() []struct {
	Ctx context.Context
	Key string
	A   redis.DelExArgs
} {
	var calls []struct {
		Ctx context.Context
		Key string
		A   redis.DelExArgs
	}
	mock.lockDelExArgs.RLock()
	calls = mock.calls.DelExArgs
	mock.lockDelExArgs.RUnlock()
	return calls
}

// ResetDelExArgsCalls reset all the calls that were made to DelExArgs.
func (mock *MoqCmdable) ResetDelExArgsCalls() {
	mock.lockDelExArgs.Lock()
	mock.calls.DelExArgs = nil
	mock.lockDelExArgs.Unlock()
}

// Digest calls DigestFunc.
func (mock *MoqCmdable) Digest(ctx context.Context, key string) *redis.DigestCmd {
	if mock.DigestFunc == nil {
		panic("MoqCmdable.DigestFunc: method is nil but Cmdable.Digest was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockDigest.Lock()
	mock.calls.Digest = append(mock.calls.Digest, callInfo)
	mock.lockDigest.Unlock()
	return mock.DigestFunc(ctx, key)
}

// DigestCalls gets all the calls that were made to Digest.
// Check the length with:
//
//	len(mockedCmdable.DigestCalls())
func (mock *MoqCmdable) DigestCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockDigest.RLock()
	calls = mock.calls.Digest
	mock.lockDigest.RUnlock()
	return calls
}

// ResetDigestCalls reset all the calls that were made to Digest.
func (mock *MoqCmdable) ResetDigestCalls() {
	mock.lockDigest.Lock()
	mock.calls.Digest = nil
	mock.lockDigest.Unlock()
}

// Dump calls DumpFunc.
func (mock *MoqCmdable) Dump(ctx context.Context, key string) *redis.StringCmd {
	if mock.DumpFunc == nil {
		panic("MoqCmdable.DumpFunc: method is nil but Cmdable.Dump was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockDump.Lock()
	mock.calls.Dump = append(mock.calls.Dump, callInfo)
	mock.lockDump.Unlock()
	return mock.DumpFunc(ctx, key)
}

// DumpCalls gets all the calls that were made to Dump.
// Check the length with:
//
//	len(mockedCmdable.DumpCalls())
func (mock *MoqCmdable) DumpCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockDump.RLock()
	calls = mock.calls.Dump
	mock.lockDump.RUnlock()
	return calls
}

// ResetDumpCalls reset all the calls that were made to Dump.
func (mock *MoqCmdable) ResetDumpCalls() {
	mock.lockDump.Lock()
	mock.calls.Dump = nil
	mock.lockDump.Unlock()
}

// Echo calls EchoFunc.
func (mock *MoqCmdable) Echo(ctx context.Context, message interface{}) *redis.StringCmd {
	if mock.EchoFunc == nil {
		panic("MoqCmdable.EchoFunc: method is nil but Cmdable.Echo was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Message interface{}
	}{
		Ctx:     ctx,
		Message: message,
	}
	mock.lockEcho.Lock()
	mock.calls.Echo = append(mock.calls.Echo, callInfo)
	mock.lockEcho.Unlock()
	return mock.EchoFunc(ctx, message)
}

// EchoCalls gets all the calls that were made to Echo.
// Check the length with:
//
//	len(mockedCmdable.EchoCalls())
func (mock *MoqCmdable) EchoCalls() []struct {
	Ctx     context.Context
	Message interface{}
} {
	var calls []struct {
		Ctx     context.Context
		Message interface{}
	}
	mock.lockEcho.RLock()
	calls = mock.calls.Echo
	mock.lockEcho.RUnlock()
	return calls
}

// ResetEchoCalls reset all the calls that were made to Echo.
func (mock *MoqCmdable) ResetEchoCalls() {
	mock.lockEcho.Lock()
	mock.calls.Echo = nil
	mock.lockEcho.Unlock()
}

// Eval calls EvalFunc.
func (mock *MoqCmdable) Eval(ctx context.Context, script string, keys []string, args ...interface{}) *redis.Cmd {
	if mock.EvalFunc == nil {
		panic("MoqCmdable.EvalFunc: method is nil but Cmdable.Eval was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Script string
		Keys   []string
		Args   []interface{}
	}{
		Ctx:    ctx,
		Script: script,
		Keys:   keys,
		Args:   args,
	}
	mock.lockEval.Lock()
	mock.calls.Eval = append(mock.calls.Eval, callInfo)
	mock.lockEval.Unlock()
	return mock.EvalFunc(ctx, script, keys, args...)
}

// EvalCalls gets all the calls that were made to Eval.
// Check the length with:
//
//	len(mockedCmdable.EvalCalls())
func (mock *MoqCmdable) EvalCalls() []struct {
	Ctx    context.Context
	Script string
	Keys   []string
	Args   []interface{}
} {
	var calls []struct {
		Ctx    context.Context
		Script string
		Keys   []string
		Args   []interface{}
	}
	mock.lockEval.RLock()
	calls = mock.calls.Eval
	mock.lockEval.RUnlock()
	return calls
}

// ResetEvalCalls reset all the calls that were made to Eval.
func (mock *MoqCmdable) ResetEvalCalls() {
	mock.lockEval.Lock()
	mock.calls.Eval = nil
	mock.lockEval.Unlock()
}

// EvalRO calls EvalROFunc.
func (mock *MoqCmdable) EvalRO(ctx context.Context, script string, keys []string, args ...interface{}) *redis.Cmd {
	if mock.EvalROFunc == nil {
		panic("MoqCmdable.EvalROFunc: method is nil but Cmdable.EvalRO was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Script string
		Keys   []string
		Args   []interface{}
	}{
		Ctx:    ctx,
		Script: script,
		Keys:   keys,
		Args:   args,
	}
	mock.lockEvalRO.Lock()
	mock.calls.EvalRO = append(mock.calls.EvalRO, callInfo)
	mock.lockEvalRO.Unlock()
	return mock.EvalROFunc(ctx, script, keys, args...)
}

// EvalROCalls gets all the calls that were made to EvalRO.
// Check the length with:
//
//	len(mockedCmdable.EvalROCalls())
func (mock *MoqCmdable) EvalROCalls() []struct {
	Ctx    context.Context
	Script string
	Keys   []string
	Args   []interface{}
} {
	var calls []struct {
		Ctx    context.Context
		Script string
		Keys   []string
		Args   []interface{}
	}
	mock.lockEvalRO.RLock()
	calls = mock.calls.EvalRO
	mock.lockEvalRO.RUnlock()
	return calls
}

// ResetEvalROCalls reset all the calls that were made to EvalRO.
func (mock *MoqCmdable) ResetEvalROCalls() {
	mock.lockEvalRO.Lock()
	mock.calls.EvalRO = nil
	mock.lockEvalRO.Unlock()
}

// EvalSha calls EvalShaFunc.
func (mock *MoqCmdable) EvalSha(ctx context.Context, sha1 string, keys []string, args ...interface{}) *redis.Cmd {
	if mock.EvalShaFunc == nil {
		panic("MoqCmdable.EvalShaFunc: method is nil but Cmdable.EvalSha was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Sha1 string
		Keys []string
		Args []interface{}
	}{
		Ctx:  ctx,
		Sha1: sha1,
		Keys: keys,
		Args: args,
	}
	mock.lockEvalSha.Lock()
	mock.calls.EvalSha = append(mock.calls.EvalSha, callInfo)
	mock.lockEvalSha.Unlock()
	return mock.EvalShaFunc(ctx, sha1, keys, args...)
}

// EvalShaCalls gets all the calls that were made to EvalSha.
// Check the length with:
//
//	len(mockedCmdable.EvalShaCalls())
func (mock *MoqCmdable) EvalShaCalls() []struct {
	Ctx  context.Context
	Sha1 string
	Keys []string
	Args []interface{}
} {
	var calls []struct {
		Ctx  context.Context
		Sha1 string
		Keys []string
		Args []interface{}
	}
	mock.lockEvalSha.RLock()
	calls = mock.calls.EvalSha
	mock.lockEvalSha.RUnlock()
	return calls
}

// ResetEvalShaCalls reset all the calls that were made to EvalSha.
func (mock *MoqCmdable) ResetEvalShaCalls() {
	mock.lockEvalSha.Lock()
	mock.calls.EvalSha = nil
	mock.lockEvalSha.Unlock()
}

// EvalShaRO calls EvalShaROFunc.
func (mock *MoqCmdable) EvalShaRO(ctx context.Context, sha1 string, keys []string, args ...interface{}) *redis.Cmd {
	if mock.EvalShaROFunc == nil {
		panic("MoqCmdable.EvalShaROFunc: method is nil but Cmdable.EvalShaRO was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Sha1 string
		Keys []string
		Args []interface{}
	}{
		Ctx:  ctx,
		Sha1: sha1,
		Keys: keys,
		Args: args,
	}
	mock.lockEvalShaRO.Lock()
	mock.calls.EvalShaRO = append(mock.calls.EvalShaRO, callInfo)
	mock.lockEvalShaRO.Unlock()
	return mock.EvalShaROFunc(ctx, sha1, keys, args...)
}

// EvalShaROCalls gets all the calls that were made to EvalShaRO.
// Check the length with:
//
//	len(mockedCmdable.EvalShaROCalls())
func (mock *MoqCmdable) EvalShaROCalls() []struct {
	Ctx  context.Context
	Sha1 string
	Keys []string
	Args []interface{}
} {
	var calls []struct {
		Ctx  context.Context
		Sha1 string
		Keys []string
		Args []interface{}
	}
	mock.lockEvalShaRO.RLock()
	calls = mock.calls.EvalShaRO
	mock.lockEvalShaRO.RUnlock()
	return calls
}

// ResetEvalShaROCalls reset all the calls that were made to EvalShaRO.
func (mock *MoqCmdable) ResetEvalShaROCalls() {
	mock.lockEvalShaRO.Lock()
	mock.calls.EvalShaRO = nil
	mock.lockEvalShaRO.Unlock()
}

// Exists calls ExistsFunc.
func (mock *MoqCmdable) Exists(ctx context.Context, keys ...string) *redis.IntCmd {
	if mock.ExistsFunc == nil {
		panic("MoqCmdable.ExistsFunc: method is nil but Cmdable.Exists was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Keys []string
	}{
		Ctx:  ctx,
		Keys: keys,
	}
	mock.lockExists.Lock()
	mock.calls.Exists = append(mock.calls.Exists, callInfo)
	mock.lockExists.Unlock()
	return mock.ExistsFunc(ctx, keys...)
}

// ExistsCalls gets all the calls that were made to Exists.
// Check the length with:
//
//	len(mockedCmdable.ExistsCalls())
func (mock *MoqCmdable) ExistsCalls() []struct {
	Ctx  context.Context
	Keys []string
} {
	var calls []struct {
		Ctx  context.Context
		Keys []string
	}
	mock.lockExists.RLock()
	calls = mock.calls.Exists
	mock.lockExists.RUnlock()
	return calls
}

// ResetExistsCalls reset all the calls that were made to Exists.
func (mock *MoqCmdable) ResetExistsCalls() {
	mock.lockExists.Lock()
	mock.calls.Exists = nil
	mock.lockExists.Unlock()
}

// Expire calls ExpireFunc.
func (mock *MoqCmdable) Expire(ctx context.Context, key string, expiration time.Duration) *redis.BoolCmd {
	if mock.ExpireFunc == nil {
		panic("MoqCmdable.ExpireFunc: method is nil but Cmdable.Expire was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Key        string
		Expiration time.Duration
	}{
		Ctx:        ctx,
		Key:        key,
		Expiration: expiration,
	}
	mock.lockExpire.Lock()
	mock.calls.Expire = append(mock.calls.Expire, callInfo)
	mock.lockExpire.Unlock()
	return mock.ExpireFunc(ctx, key, expiration)
}

// ExpireCalls gets all the calls that were made to Expire.
// Check the length with:
//
//	len(mockedCmdable.ExpireCalls())
func (mock *MoqCmdable) ExpireCalls() []struct {
	Ctx        context.Context
	Key        string
	Expiration time.Duration
} {
	var calls []struct {
		Ctx        context.Context
		Key        string
		Expiration time.Duration
	}
	mock.lockExpire.RLock()
	calls = mock.calls.Expire
	mock.lockExpire.RUnlock()
	return calls
}

// ResetExpireCalls reset all the calls that were made to Expire.
func (mock *MoqCmdable) ResetExpireCalls() {
	mock.lockExpire.Lock()
	mock.calls.Expire = nil
	mock.lockExpire.Unlock()
}

// ExpireAt calls ExpireAtFunc.
func (mock *MoqCmdable) ExpireAt(ctx context.Context, key string, tm time.Time) *redis.BoolCmd {
	if mock.ExpireAtFunc == nil {
		panic("MoqCmdable.ExpireAtFunc: method is nil but Cmdable.ExpireAt was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
		Tm  time.Time
	}{
		Ctx: ctx,
		Key: key,
		Tm:  tm,
	}
	mock.lockExpireAt.Lock()
	mock.calls.ExpireAt = append(mock.calls.ExpireAt, callInfo)
	mock.lockExpireAt.Unlock()
	return mock.ExpireAtFunc(ctx, key, tm)
}

// ExpireAtCalls gets all the calls that were made to ExpireAt.
// Check the length with:
//
//	len(mockedCmdable.ExpireAtCalls())
func (mock *MoqCmdable) ExpireAtCalls() []struct {
	Ctx context.Context
	Key string
	Tm  time.Time
} {
	var calls []struct {
		Ctx context.Context
		Key string
		Tm  time.Time
	}
	mock.lockExpireAt.RLock()
	calls = mock.calls.ExpireAt
	mock.lockExpireAt.RUnlock()
	return calls
}

// ResetExpireAtCalls reset all the calls that were made to ExpireAt.
func (mock *MoqCmdable) ResetExpireAtCalls() {
	mock.lockExpireAt.Lock()
	mock.calls.ExpireAt = nil
	mock.lockExpireAt.Unlock()
}

// ExpireGT calls ExpireGTFunc.
func (mock *MoqCmdable) ExpireGT(ctx context.Context, key string, expiration time.Duration) *redis.BoolCmd {
	if mock.ExpireGTFunc == nil {
		panic("MoqCmdable.ExpireGTFunc: method is nil but Cmdable.ExpireGT was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Key        string
		Expiration time.Duration
	}{
		Ctx:        ctx,
		Key:        key,
		Expiration: expiration,
	}
	mock.lockExpireGT.Lock()
	mock.calls.ExpireGT = append(mock.calls.ExpireGT, callInfo)
	mock.lockExpireGT.Unlock()
	return mock.ExpireGTFunc(ctx, key, expiration)
}

// ExpireGTCalls gets all the calls that were made to ExpireGT.
// Check the length with:
//
//	len(mockedCmdable.ExpireGTCalls())
func (mock *MoqCmdable) ExpireGTCalls() []struct {
	Ctx        context.Context
	Key        string
	Expiration time.Duration
} {
	var calls []struct {
		Ctx        context.Context
		Key        string
		Expiration time.Duration
	}
	mock.lockExpireGT.RLock()
	calls = mock.calls.ExpireGT
	mock.lockExpireGT.RUnlock()
	return calls
}

// ResetExpireGTCalls reset all the calls that were made to ExpireGT.
func (mock *MoqCmdable) ResetExpireGTCalls() {
	mock.lockExpireGT.Lock()
	mock.calls.ExpireGT = nil
	mock.lockExpireGT.Unlock()
}

// ExpireLT calls ExpireLTFunc.
func (mock *MoqCmdable) ExpireLT(ctx context.Context, key string, expiration time.Duration) *redis.BoolCmd {
	if mock.ExpireLTFunc == nil {
		panic("MoqCmdable.ExpireLTFunc: method is nil but Cmdable.ExpireLT was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Key        string
		Expiration time.Duration
	}{
		Ctx:        ctx,
		Key:        key,
		Expiration: expiration,
	}
	mock.lockExpireLT.Lock()
	mock.calls.ExpireLT = append(mock.calls.ExpireLT, callInfo)
	mock.lockExpireLT.Unlock()
	return mock.ExpireLTFunc(ctx, key, expiration)
}

// ExpireLTCalls gets all the calls that were made to ExpireLT.
// Check the length with:
//
//	len(mockedCmdable.ExpireLTCalls())
func (mock *MoqCmdable) ExpireLTCalls() []struct {
	Ctx        context.Context
	Key        string
	Expiration time.Duration
} {
	var calls []struct {
		Ctx        context.Context
		Key        string
		Expiration time.Duration
	}
	mock.lockExpireLT.RLock()
	calls = mock.calls.ExpireLT
	mock.lockExpireLT.RUnlock()
	return calls
}

// ResetExpireLTCalls reset all the calls that were made to ExpireLT.
func (mock *MoqCmdable) ResetExpireLTCalls() {
	mock.lockExpireLT.Lock()
	mock.calls.ExpireLT = nil
	mock.lockExpireLT.Unlock()
}

// ExpireNX calls ExpireNXFunc.
func (mock *MoqCmdable) ExpireNX(ctx context.Context, key string, expiration time.Duration) *redis.BoolCmd {
	if mock.ExpireNXFunc == nil {
		panic("MoqCmdable.ExpireNXFunc: method is nil but Cmdable.ExpireNX was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Key        string
		Expiration time.Duration
	}{
		Ctx:        ctx,
		Key:        key,
		Expiration: expiration,
	}
	mock.lockExpireNX.Lock()
	mock.calls.ExpireNX = append(mock.calls.ExpireNX, callInfo)
	mock.lockExpireNX.Unlock()
	return mock.ExpireNXFunc(ctx, key, expiration)
}

// ExpireNXCalls gets all the calls that were made to ExpireNX.
// Check the length with:
//
//	len(mockedCmdable.ExpireNXCalls())
func (mock *MoqCmdable) ExpireNXCalls() []struct {
	Ctx        context.Context
	Key        string
	Expiration time.Duration
} {
	var calls []struct {
		Ctx        context.Context
		Key        string
		Expiration time.Duration
	}
	mock.lockExpireNX.RLock()
	calls = mock.calls.ExpireNX
	mock.lockExpireNX.RUnlock()
	return calls
}

// ResetExpireNXCalls reset all the calls that were made to ExpireNX.
func (mock *MoqCmdable) ResetExpireNXCalls() {
	mock.lockExpireNX.Lock()
	mock.calls.ExpireNX = nil
	mock.lockExpireNX.Unlock()
}

// ExpireTime calls ExpireTimeFunc.
func (mock *MoqCmdable) ExpireTime(ctx context.Context, key string) *redis.DurationCmd {
	if mock.ExpireTimeFunc == nil {
		panic("MoqCmdable.ExpireTimeFunc: method is nil but Cmdable.ExpireTime was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockExpireTime.Lock()
	mock.calls.ExpireTime = append(mock.calls.ExpireTime, callInfo)
	mock.lockExpireTime.Unlock()
	return mock.ExpireTimeFunc(ctx, key)
}

// ExpireTimeCalls gets all the calls that were made to ExpireTime.
// Check the length with:
//
//	len(mockedCmdable.ExpireTimeCalls())
func (mock *MoqCmdable) ExpireTimeCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockExpireTime.RLock()
	calls = mock.calls.ExpireTime
	mock.lockExpireTime.RUnlock()
	return calls
}

// ResetExpireTimeCalls reset all the calls that were made to ExpireTime.
func (mock *MoqCmdable) ResetExpireTimeCalls() {
	mock.lockExpireTime.Lock()
	mock.calls.ExpireTime = nil
	mock.lockExpireTime.Unlock()
}

// ExpireXX calls ExpireXXFunc.
func (mock *MoqCmdable) ExpireXX(ctx context.Context, key string, expiration time.Duration) *redis.BoolCmd {
	if mock.ExpireXXFunc == nil {
		panic("MoqCmdable.ExpireXXFunc: method is nil but Cmdable.ExpireXX was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Key        string
		Expiration time.Duration
	}{
		Ctx:        ctx,
		Key:        key,
		Expiration: expiration,
	}
	mock.lockExpireXX.Lock()
	mock.calls.ExpireXX = append(mock.calls.ExpireXX, callInfo)
	mock.lockExpireXX.Unlock()
	return mock.ExpireXXFunc(ctx, key, expiration)
}

// ExpireXXCalls gets all the calls that were made to ExpireXX.
// Check the length with:
//
//	len(mockedCmdable.ExpireXXCalls())
func (mock *MoqCmdable) ExpireXXCalls() []struct {
	Ctx        context.Context
	Key        string
	Expiration time.Duration
} {
	var calls []struct {
		Ctx        context.Context
		Key        string
		Expiration time.Duration
	}
	mock.lockExpireXX.RLock()
	calls = mock.calls.ExpireXX
	mock.lockExpireXX.RUnlock()
	return calls
}

// ResetExpireXXCalls reset all the calls that were made to ExpireXX.
func (mock *MoqCmdable) ResetExpireXXCalls() {
	mock.lockExpireXX.Lock()
	mock.calls.ExpireXX = nil
	mock.lockExpireXX.Unlock()
}

// FCall calls FCallFunc.
func (mock *MoqCmdable) FCall(ctx context.Context, function string, keys []string, args ...interface{}) *redis.Cmd {
	if mock.FCallFunc == nil {
		panic("MoqCmdable.FCallFunc: method is nil but Cmdable.FCall was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Function string
		Keys     []string
		Args     []interface{}
	}{
		Ctx:      ctx,
		Function: function,
		Keys:     keys,
		Args:     args,
	}
	mock.lockFCall.Lock()
	mock.calls.FCall = append(mock.calls.FCall, callInfo)
	mock.lockFCall.Unlock()
	return mock.FCallFunc(ctx, function, keys, args...)
}

// FCallCalls gets all the calls that were made to FCall.
// Check the length with:
//
//	len(mockedCmdable.FCallCalls())
func (mock *MoqCmdable) FCallCalls() []struct {
	Ctx      context.Context
	Function string
	Keys     []string
	Args     []interface{}
} {
	var calls []struct {
		Ctx      context.Context
		Function string
		Keys     []string
		Args     []interface{}
	}
	mock.lockFCall.RLock()
	calls = mock.calls.FCall
	mock.lockFCall.RUnlock()
	return calls
}

// ResetFCallCalls reset all the calls that were made to FCall.
func (mock *MoqCmdable) ResetFCallCalls() {
	mock.lockFCall.Lock()
	mock.calls.FCall = nil
	mock.lockFCall.Unlock()
}

// FCallRO calls FCallROFunc.
func (mock *MoqCmdable) FCallRO(ctx context.Context, function string, keys []string, args ...interface{}) *redis.Cmd {
	if mock.FCallROFunc == nil {
		panic("MoqCmdable.FCallROFunc: method is nil but Cmdable.FCallRO was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Function string
		Keys     []string
		Args     []interface{}
	}{
		Ctx:      ctx,
		Function: function,
		Keys:     keys,
		Args:     args,
	}
	mock.lockFCallRO.Lock()
	mock.calls.FCallRO = append(mock.calls.FCallRO, callInfo)
	mock.lockFCallRO.Unlock()
	return mock.FCallROFunc(ctx, function, keys, args...)
}

// FCallROCalls gets all the calls that were made to FCallRO.
// Check the length with:
//
//	len(mockedCmdable.FCallROCalls())
func (mock *MoqCmdable) FCallROCalls() []struct {
	Ctx      context.Context
	Function string
	Keys     []string
	Args     []interface{}
} {
	var calls []struct {
		Ctx      context.Context
		Function string
		Keys     []string
		Args     []interface{}
	}
	mock.lockFCallRO.RLock()
	calls = mock.calls.FCallRO
	mock.lockFCallRO.RUnlock()
	return calls
}

// ResetFCallROCalls reset all the calls that were made to FCallRO.
func (mock *MoqCmdable) ResetFCallROCalls() {
	mock.lockFCallRO.Lock()
	mock.calls.FCallRO = nil
	mock.lockFCallRO.Unlock()
}

// FCallRo calls FCallRoFunc.
func (mock *MoqCmdable) FCallRo(ctx context.Context, function string, keys []string, args ...interface{}) *redis.Cmd {
	if mock.FCallRoFunc == nil {
		panic("MoqCmdable.FCallRoFunc: method is nil but Cmdable.FCallRo was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Function string
		Keys     []string
		Args     []interface{}
	}{
		Ctx:      ctx,
		Function: function,
		Keys:     keys,
		Args:     args,
	}
	mock.lockFCallRo.Lock()
	mock.calls.FCallRo = append(mock.calls.FCallRo, callInfo)
	mock.lockFCallRo.Unlock()
	return mock.FCallRoFunc(ctx, function, keys, args...)
}

// FCallRoCalls gets all the calls that were made to FCallRo.
// Check the length with:
//
//	len(mockedCmdable.FCallRoCalls())
func (mock *MoqCmdable) FCallRoCalls() []struct {
	Ctx      context.Context
	Function string
	Keys     []string
	Args     []interface{}
} {
	var calls []struct {
		Ctx      context.Context
		Function string
		Keys     []string
		Args     []interface{}
	}
	mock.lockFCallRo.RLock()
	calls = mock.calls.FCallRo
	mock.lockFCallRo.RUnlock()
	return calls
}

// ResetFCallRoCalls reset all the calls that were made to FCallRo.
func (mock *MoqCmdable) ResetFCallRoCalls() {
	mock.lockFCallRo.Lock()
	mock.calls.FCallRo = nil
	mock.lockFCallRo.Unlock()
}

// FTAggregate calls FTAggregateFunc.
func (mock *MoqCmdable) FTAggregate(ctx context.Context, index string, query string) *redis.MapStringInterfaceCmd {
	if mock.FTAggregateFunc == nil {
		panic("MoqCmdable.FTAggregateFunc: method is nil but Cmdable.FTAggregate was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Index string
		Query string
	}{
		Ctx:   ctx,
		Index: index,
		Query: query,
	}
	mock.lockFTAggregate.Lock()
	mock.calls.FTAggregate = append(mock.calls.FTAggregate, callInfo)
	mock.lockFTAggregate.Unlock()
	return mock.FTAggregateFunc(ctx, index, query)
}

// FTAggregateCalls gets all the calls that were made to FTAggregate.
// Check the length with:
//
//	len(mockedCmdable.FTAggregateCalls())
func (mock *MoqCmdable) FTAggregateCalls() []struct {
	Ctx   context.Context
	Index string
	Query string
} {
	var calls []struct {
		Ctx   context.Context
		Index string
		Query string
	}
	mock.lockFTAggregate.RLock()
	calls = mock.calls.FTAggregate
	mock.lockFTAggregate.RUnlock()
	return calls
}

// ResetFTAggregateCalls reset all the calls that were made to FTAggregate.
func (mock *MoqCmdable) ResetFTAggregateCalls() {
	mock.lockFTAggregate.Lock()
	mock.calls.FTAggregate = nil
	mock.lockFTAggregate.Unlock()
}

// FTAggregateWithArgs calls FTAggregateWithArgsFunc.
func (mock *MoqCmdable) FTAggregateWithArgs(ctx context.Context, index string, query string, options *redis.FTAggregateOptions) *redis.AggregateCmd {
	if mock.FTAggregateWithArgsFunc == nil {
		panic("MoqCmdable.FTAggregateWithArgsFunc: method is nil but Cmdable.FTAggregateWithArgs was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Index   string
		Query   string
		Options *redis.FTAggregateOptions
	}{
		Ctx:     ctx,
		Index:   index,
		Query:   query,
		Options: options,
	}
	mock.lockFTAggregateWithArgs.Lock()
	mock.calls.FTAggregateWithArgs = append(mock.calls.FTAggregateWithArgs, callInfo)
	mock.lockFTAggregateWithArgs.Unlock()
	return mock.FTAggregateWithArgsFunc(ctx, index, query, options)
}

// FTAggregateWithArgsCalls gets all the calls that were made to FTAggregateWithArgs.
// Check the length with:
//
//	len(mockedCmdable.FTAggregateWithArgsCalls())
func (mock *MoqCmdable) FTAggregateWithArgsCalls() []struct {
	Ctx     context.Context
	Index   string
	Query   string
	Options *redis.FTAggregateOptions
} {
	var calls []struct {
		Ctx     context.Context
		Index   string
		Query   string
		Options *redis.FTAggregateOptions
	}
	mock.lockFTAggregateWithArgs.RLock()
	calls = mock.calls.FTAggregateWithArgs
	mock.lockFTAggregateWithArgs.RUnlock()
	return calls
}

// ResetFTAggregateWithArgsCalls reset all the calls that were made to FTAggregateWithArgs.
func (mock *MoqCmdable) ResetFTAggregateWithArgsCalls() {
	mock.lockFTAggregateWithArgs.Lock()
	mock.calls.FTAggregateWithArgs = nil
	mock.lockFTAggregateWithArgs.Unlock()
}

// FTAliasAdd calls FTAliasAddFunc.
func (mock *MoqCmdable) FTAliasAdd(ctx context.Context, index string, alias string) *redis.StatusCmd {
	if mock.FTAliasAddFunc == nil {
		panic("MoqCmdable.FTAliasAddFunc: method is nil but Cmdable.FTAliasAdd was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Index string
		Alias string
	}{
		Ctx:   ctx,
		Index: index,
		Alias: alias,
	}
	mock.lockFTAliasAdd.Lock()
	mock.calls.FTAliasAdd = append(mock.calls.FTAliasAdd, callInfo)
	mock.lockFTAliasAdd.Unlock()
	return mock.FTAliasAddFunc(ctx, index, alias)
}

// FTAliasAddCalls gets all the calls that were made to FTAliasAdd.
// Check the length with:
//
//	len(mockedCmdable.FTAliasAddCalls())
func (mock *MoqCmdable) FTAliasAddCalls() []struct {
	Ctx   context.Context
	Index string
	Alias string
} {
	var calls []struct {
		Ctx   context.Context
		Index string
		Alias string
	}
	mock.lockFTAliasAdd.RLock()
	calls = mock.calls.FTAliasAdd
	mock.lockFTAliasAdd.RUnlock()
	return calls
}

// ResetFTAliasAddCalls reset all the calls that were made to FTAliasAdd.
func (mock *MoqCmdable) ResetFTAliasAddCalls() {
	mock.lockFTAliasAdd.Lock()
	mock.calls.FTAliasAdd = nil
	mock.lockFTAliasAdd.Unlock()
}

// FTAliasDel calls FTAliasDelFunc.
func (mock *MoqCmdable) FTAliasDel(ctx context.Context, alias string) *redis.StatusCmd {
	if mock.FTAliasDelFunc == nil {
		panic("MoqCmdable.FTAliasDelFunc: method is nil but Cmdable.FTAliasDel was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Alias string
	}{
		Ctx:   ctx,
		Alias: alias,
	}
	mock.lockFTAliasDel.Lock()
	mock.calls.FTAliasDel = append(mock.calls.FTAliasDel, callInfo)
	mock.lockFTAliasDel.Unlock()
	return mock.FTAliasDelFunc(ctx, alias)
}

// FTAliasDelCalls gets all the calls that were made to FTAliasDel.
// Check the length with:
//
//	len(mockedCmdable.FTAliasDelCalls())
func (mock *MoqCmdable) FTAliasDelCalls() []struct {
	Ctx   context.Context
	Alias string
} {
	var calls []struct {
		Ctx   context.Context
		Alias string
	}
	mock.lockFTAliasDel.RLock()
	calls = mock.calls.FTAliasDel
	mock.lockFTAliasDel.RUnlock()
	return calls
}

// ResetFTAliasDelCalls reset all the calls that were made to FTAliasDel.
func (mock *MoqCmdable) ResetFTAliasDelCalls() {
	mock.lockFTAliasDel.Lock()
	mock.calls.FTAliasDel = nil
	mock.lockFTAliasDel.Unlock()
}

// FTAliasUpdate calls FTAliasUpdateFunc.
func (mock *MoqCmdable) FTAliasUpdate(ctx context.Context, index string, alias string) *redis.StatusCmd {
	if mock.FTAliasUpdateFunc == nil {
		panic("MoqCmdable.FTAliasUpdateFunc: method is nil but Cmdable.FTAliasUpdate was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Index string
		Alias string
	}{
		Ctx:   ctx,
		Index: index,
		Alias: alias,
	}
	mock.lockFTAliasUpdate.Lock()
	mock.calls.FTAliasUpdate = append(mock.calls.FTAliasUpdate, callInfo)
	mock.lockFTAliasUpdate.Unlock()
	return mock.FTAliasUpdateFunc(ctx, index, alias)
}

// FTAliasUpdateCalls gets all the calls that were made to FTAliasUpdate.
// Check the length with:
//
//	len(mockedCmdable.FTAliasUpdateCalls())
func (mock *MoqCmdable) FTAliasUpdateCalls() []struct {
	Ctx   context.Context
	Index string
	Alias string
} {
	var calls []struct {
		Ctx   context.Context
		Index string
		Alias string
	}
	mock.lockFTAliasUpdate.RLock()
	calls = mock.calls.FTAliasUpdate
	mock.lockFTAliasUpdate.RUnlock()
	return calls
}

// ResetFTAliasUpdateCalls reset all the calls that were made to FTAliasUpdate.
func (mock *MoqCmdable) ResetFTAliasUpdateCalls() {
	mock.lockFTAliasUpdate.Lock()
	mock.calls.FTAliasUpdate = nil
	mock.lockFTAliasUpdate.Unlock()
}

// FTAlter calls FTAlterFunc.
func (mock *MoqCmdable) FTAlter(ctx context.Context, index string, skipInitialScan bool, definition []interface{}) *redis.StatusCmd {
	if mock.FTAlterFunc == nil {
		panic("MoqCmdable.FTAlterFunc: method is nil but Cmdable.FTAlter was just called")
	}
	callInfo := struct {
		Ctx             context.Context
		Index           string
		SkipInitialScan bool
		Definition      []interface{}
	}{
		Ctx:             ctx,
		Index:           index,
		SkipInitialScan: skipInitialScan,
		Definition:      definition,
	}
	mock.lockFTAlter.Lock()
	mock.calls.FTAlter = append(mock.calls.FTAlter, callInfo)
	mock.lockFTAlter.Unlock()
	return mock.FTAlterFunc(ctx, index, skipInitialScan, definition)
}

// FTAlterCalls gets all the calls that were made to FTAlter.
// Check the length with:
//
//	len(mockedCmdable.FTAlterCalls())
func (mock *MoqCmdable) FTAlterCalls() []struct {
	Ctx             context.Context
	Index           string
	SkipInitialScan bool
	Definition      []interface{}
} {
	var calls []struct {
		Ctx             context.Context
		Index           string
		SkipInitialScan bool
		Definition      []interface{}
	}
	mock.lockFTAlter.RLock()
	calls = mock.calls.FTAlter
	mock.lockFTAlter.RUnlock()
	return calls
}

// ResetFTAlterCalls reset all the calls that were made to FTAlter.
func (mock *MoqCmdable) ResetFTAlterCalls() {
	mock.lockFTAlter.Lock()
	mock.calls.FTAlter = nil
	mock.lockFTAlter.Unlock()
}

// FTConfigGet calls FTConfigGetFunc.
func (mock *MoqCmdable) FTConfigGet(ctx context.Context, option string) *redis.MapMapStringInterfaceCmd {
	if mock.FTConfigGetFunc == nil {
		panic("MoqCmdable.FTConfigGetFunc: method is nil but Cmdable.FTConfigGet was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Option string
	}{
		Ctx:    ctx,
		Option: option,
	}
	mock.lockFTConfigGet.Lock()
	mock.calls.FTConfigGet = append(mock.calls.FTConfigGet, callInfo)
	mock.lockFTConfigGet.Unlock()
	return mock.FTConfigGetFunc(ctx, option)
}

// FTConfigGetCalls gets all the calls that were made to FTConfigGet.
// Check the length with:
//
//	len(mockedCmdable.FTConfigGetCalls())
func (mock *MoqCmdable) FTConfigGetCalls() []struct {
	Ctx    context.Context
	Option string
} {
	var calls []struct {
		Ctx    context.Context
		Option string
	}
	mock.lockFTConfigGet.RLock()
	calls = mock.calls.FTConfigGet
	mock.lockFTConfigGet.RUnlock()
	return calls
}

// ResetFTConfigGetCalls reset all the calls that were made to FTConfigGet.
func (mock *MoqCmdable) ResetFTConfigGetCalls() {
	mock.lockFTConfigGet.Lock()
	mock.calls.FTConfigGet = nil
	mock.lockFTConfigGet.Unlock()
}

// FTConfigSet calls FTConfigSetFunc.
func (mock *MoqCmdable) FTConfigSet(ctx context.Context, option string, value interface{}) *redis.StatusCmd {
	if mock.FTConfigSetFunc == nil {
		panic("MoqCmdable.FTConfigSetFunc: method is nil but Cmdable.FTConfigSet was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Option string
		Value  interface{}
	}{
		Ctx:    ctx,
		Option: option,
		Value:  value,
	}
	mock.lockFTConfigSet.Lock()
	mock.calls.FTConfigSet = append(mock.calls.FTConfigSet, callInfo)
	mock.lockFTConfigSet.Unlock()
	return mock.FTConfigSetFunc(ctx, option, value)
}

// FTConfigSetCalls gets all the calls that were made to FTConfigSet.
// Check the length with:
//
//	len(mockedCmdable.FTConfigSetCalls())
func (mock *MoqCmdable) FTConfigSetCalls() []struct {
	Ctx    context.Context
	Option string
	Value  interface{}
} {
	var calls []struct {
		Ctx    context.Context
		Option string
		Value  interface{}
	}
	mock.lockFTConfigSet.RLock()
	calls = mock.calls.FTConfigSet
	mock.lockFTConfigSet.RUnlock()
	return calls
}

// ResetFTConfigSetCalls reset all the calls that were made to FTConfigSet.
func (mock *MoqCmdable) ResetFTConfigSetCalls() {
	mock.lockFTConfigSet.Lock()
	mock.calls.FTConfigSet = nil
	mock.lockFTConfigSet.Unlock()
}

// FTCreate calls FTCreateFunc.
func (mock *MoqCmdable) FTCreate(ctx context.Context, index string, options *redis.FTCreateOptions, schema ...*redis.FieldSchema) *redis.StatusCmd {
	if mock.FTCreateFunc == nil {
		panic("MoqCmdable.FTCreateFunc: method is nil but Cmdable.FTCreate was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Index   string
		Options *redis.FTCreateOptions
		Schema  []*redis.FieldSchema
	}{
		Ctx:     ctx,
		Index:   index,
		Options: options,
		Schema:  schema,
	}
	mock.lockFTCreate.Lock()
	mock.calls.FTCreate = append(mock.calls.FTCreate, callInfo)
	mock.lockFTCreate.Unlock()
	return mock.FTCreateFunc(ctx, index, options, schema...)
}

// FTCreateCalls gets all the calls that were made to FTCreate.
// Check the length with:
//
//	len(mockedCmdable.FTCreateCalls())
func (mock *MoqCmdable) FTCreateCalls() []struct {
	Ctx     context.Context
	Index   string
	Options *redis.FTCreateOptions
	Schema  []*redis.FieldSchema
} {
	var calls []struct {
		Ctx     context.Context
		Index   string
		Options *redis.FTCreateOptions
		Schema  []*redis.FieldSchema
	}
	mock.lockFTCreate.RLock()
	calls = mock.calls.FTCreate
	mock.lockFTCreate.RUnlock()
	return calls
}

// ResetFTCreateCalls reset all the calls that were made to FTCreate.
func (mock *MoqCmdable) ResetFTCreateCalls() {
	mock.lockFTCreate.Lock()
	mock.calls.FTCreate = nil
	mock.lockFTCreate.Unlock()
}

// FTCursorDel calls FTCursorDelFunc.
func (mock *MoqCmdable) FTCursorDel(ctx context.Context, index string, cursorId int) *redis.StatusCmd {
	if mock.FTCursorDelFunc == nil {
		panic("MoqCmdable.FTCursorDelFunc: method is nil but Cmdable.FTCursorDel was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Index    string
		CursorId int
	}{
		Ctx:      ctx,
		Index:    index,
		CursorId: cursorId,
	}
	mock.lockFTCursorDel.Lock()
	mock.calls.FTCursorDel = append(mock.calls.FTCursorDel, callInfo)
	mock.lockFTCursorDel.Unlock()
	return mock.FTCursorDelFunc(ctx, index, cursorId)
}

// FTCursorDelCalls gets all the calls that were made to FTCursorDel.
// Check the length with:
//
//	len(mockedCmdable.FTCursorDelCalls())
func (mock *MoqCmdable) FTCursorDelCalls() []struct {
	Ctx      context.Context
	Index    string
	CursorId int
} {
	var calls []struct {
		Ctx      context.Context
		Index    string
		CursorId int
	}
	mock.lockFTCursorDel.RLock()
	calls = mock.calls.FTCursorDel
	mock.lockFTCursorDel.RUnlock()
	return calls
}

// ResetFTCursorDelCalls reset all the calls that were made to FTCursorDel.
func (mock *MoqCmdable) ResetFTCursorDelCalls() {
	mock.lockFTCursorDel.Lock()
	mock.calls.FTCursorDel = nil
	mock.lockFTCursorDel.Unlock()
}

// FTCursorRead calls FTCursorReadFunc.
func (mock *MoqCmdable) FTCursorRead(ctx context.Context, index string, cursorId int, count int) *redis.MapStringInterfaceCmd {
	if mock.FTCursorReadFunc == nil {
		panic("MoqCmdable.FTCursorReadFunc: method is nil but Cmdable.FTCursorRead was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Index    string
		CursorId int
		Count    int
	}{
		Ctx:      ctx,
		Index:    index,
		CursorId: cursorId,
		Count:    count,
	}
	mock.lockFTCursorRead.Lock()
	mock.calls.FTCursorRead = append(mock.calls.FTCursorRead, callInfo)
	mock.lockFTCursorRead.Unlock()
	return mock.FTCursorReadFunc(ctx, index, cursorId, count)
}

// FTCursorReadCalls gets all the calls that were made to FTCursorRead.
// Check the length with:
//
//	len(mockedCmdable.FTCursorReadCalls())
func (mock *MoqCmdable) FTCursorReadCalls() []struct {
	Ctx      context.Context
	Index    string
	CursorId int
	Count    int
} {
	var calls []struct {
		Ctx      context.Context
		Index    string
		CursorId int
		Count    int
	}
	mock.lockFTCursorRead.RLock()
	calls = mock.calls.FTCursorRead
	mock.lockFTCursorRead.RUnlock()
	return calls
}

// ResetFTCursorReadCalls reset all the calls that were made to FTCursorRead.
func (mock *MoqCmdable) ResetFTCursorReadCalls() {
	mock.lockFTCursorRead.Lock()
	mock.calls.FTCursorRead = nil
	mock.lockFTCursorRead.Unlock()
}

// FTDictAdd calls FTDictAddFunc.
func (mock *MoqCmdable) FTDictAdd(ctx context.Context, dict string, term ...interface{}) *redis.IntCmd {
	if mock.FTDictAddFunc == nil {
		panic("MoqCmdable.FTDictAddFunc: method is nil but Cmdable.FTDictAdd was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Dict string
		Term []interface{}
	}{
		Ctx:  ctx,
		Dict: dict,
		Term: term,
	}
	mock.lockFTDictAdd.Lock()
	mock.calls.FTDictAdd = append(mock.calls.FTDictAdd, callInfo)
	mock.lockFTDictAdd.Unlock()
	return mock.FTDictAddFunc(ctx, dict, term...)
}

// FTDictAddCalls gets all the calls that were made to FTDictAdd.
// Check the length with:
//
//	len(mockedCmdable.FTDictAddCalls())
func (mock *MoqCmdable) FTDictAddCalls() []struct {
	Ctx  context.Context
	Dict string
	Term []interface{}
} {
	var calls []struct {
		Ctx  context.Context
		Dict string
		Term []interface{}
	}
	mock.lockFTDictAdd.RLock()
	calls = mock.calls.FTDictAdd
	mock.lockFTDictAdd.RUnlock()
	return calls
}

// ResetFTDictAddCalls reset all the calls that were made to FTDictAdd.
func (mock *MoqCmdable) ResetFTDictAddCalls() {
	mock.lockFTDictAdd.Lock()
	mock.calls.FTDictAdd = nil
	mock.lockFTDictAdd.Unlock()
}

// FTDictDel calls FTDictDelFunc.
func (mock *MoqCmdable) FTDictDel(ctx context.Context, dict string, term ...interface{}) *redis.IntCmd {
	if mock.FTDictDelFunc == nil {
		panic("MoqCmdable.FTDictDelFunc: method is nil but Cmdable.FTDictDel was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Dict string
		Term []interface{}
	}{
		Ctx:  ctx,
		Dict: dict,
		Term: term,
	}
	mock.lockFTDictDel.Lock()
	mock.calls.FTDictDel = append(mock.calls.FTDictDel, callInfo)
	mock.lockFTDictDel.Unlock()
	return mock.FTDictDelFunc(ctx, dict, term...)
}

// FTDictDelCalls gets all the calls that were made to FTDictDel.
// Check the length with:
//
//	len(mockedCmdable.FTDictDelCalls())
func (mock *MoqCmdable) FTDictDelCalls() []struct {
	Ctx  context.Context
	Dict string
	Term []interface{}
} {
	var calls []struct {
		Ctx  context.Context
		Dict string
		Term []interface{}
	}
	mock.lockFTDictDel.RLock()
	calls = mock.calls.FTDictDel
	mock.lockFTDictDel.RUnlock()
	return calls
}

// ResetFTDictDelCalls reset all the calls that were made to FTDictDel.
func (mock *MoqCmdable) ResetFTDictDelCalls() {
	mock.lockFTDictDel.Lock()
	mock.calls.FTDictDel = nil
	mock.lockFTDictDel.Unlock()
}

// FTDictDump calls FTDictDumpFunc.
func (mock *MoqCmdable) FTDictDump(ctx context.Context, dict string) *redis.StringSliceCmd {
	if mock.FTDictDumpFunc == nil {
		panic("MoqCmdable.FTDictDumpFunc: method is nil but Cmdable.FTDictDump was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Dict string
	}{
		Ctx:  ctx,
		Dict: dict,
	}
	mock.lockFTDictDump.Lock()
	mock.calls.FTDictDump = append(mock.calls.FTDictDump, callInfo)
	mock.lockFTDictDump.Unlock()
	return mock.FTDictDumpFunc(ctx, dict)
}

// FTDictDumpCalls gets all the calls that were made to FTDictDump.
// Check the length with:
//
//	len(mockedCmdable.FTDictDumpCalls())
func (mock *MoqCmdable) FTDictDumpCalls() []struct {
	Ctx  context.Context
	Dict string
} {
	var calls []struct {
		Ctx  context.Context
		Dict string
	}
	mock.lockFTDictDump.RLock()
	calls = mock.calls.FTDictDump
	mock.lockFTDictDump.RUnlock()
	return calls
}

// ResetFTDictDumpCalls reset all the calls that were made to FTDictDump.
func (mock *MoqCmdable) ResetFTDictDumpCalls() {
	mock.lockFTDictDump.Lock()
	mock.calls.FTDictDump = nil
	mock.lockFTDictDump.Unlock()
}

// FTDropIndex calls FTDropIndexFunc.
func (mock *MoqCmdable) FTDropIndex(ctx context.Context, index string) *redis.StatusCmd {
	if mock.FTDropIndexFunc == nil {
		panic("MoqCmdable.FTDropIndexFunc: method is nil but Cmdable.FTDropIndex was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Index string
	}{
		Ctx:   ctx,
		Index: index,
	}
	mock.lockFTDropIndex.Lock()
	mock.calls.FTDropIndex = append(mock.calls.FTDropIndex, callInfo)
	mock.lockFTDropIndex.Unlock()
	return mock.FTDropIndexFunc(ctx, index)
}

// FTDropIndexCalls gets all the calls that were made to FTDropIndex.
// Check the length with:
//
//	len(mockedCmdable.FTDropIndexCalls())
func (mock *MoqCmdable) FTDropIndexCalls() []struct {
	Ctx   context.Context
	Index string
} {
	var calls []struct {
		Ctx   context.Context
		Index string
	}
	mock.lockFTDropIndex.RLock()
	calls = mock.calls.FTDropIndex
	mock.lockFTDropIndex.RUnlock()
	return calls
}

// ResetFTDropIndexCalls reset all the calls that were made to FTDropIndex.
func (mock *MoqCmdable) ResetFTDropIndexCalls() {
	mock.lockFTDropIndex.Lock()
	mock.calls.FTDropIndex = nil
	mock.lockFTDropIndex.Unlock()
}

// FTDropIndexWithArgs calls FTDropIndexWithArgsFunc.
func (mock *MoqCmdable) FTDropIndexWithArgs(ctx context.Context, index string, options *redis.FTDropIndexOptions) *redis.StatusCmd {
	if mock.FTDropIndexWithArgsFunc == nil {
		panic("MoqCmdable.FTDropIndexWithArgsFunc: method is nil but Cmdable.FTDropIndexWithArgs was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Index   string
		Options *redis.FTDropIndexOptions
	}{
		Ctx:     ctx,
		Index:   index,
		Options: options,
	}
	mock.lockFTDropIndexWithArgs.Lock()
	mock.calls.FTDropIndexWithArgs = append(mock.calls.FTDropIndexWithArgs, callInfo)
	mock.lockFTDropIndexWithArgs.Unlock()
	return mock.FTDropIndexWithArgsFunc(ctx, index, options)
}

// FTDropIndexWithArgsCalls gets all the calls that were made to FTDropIndexWithArgs.
// Check the length with:
//
//	len(mockedCmdable.FTDropIndexWithArgsCalls())
func (mock *MoqCmdable) FTDropIndexWithArgsCalls() []struct {
	Ctx     context.Context
	Index   string
	Options *redis.FTDropIndexOptions
} {
	var calls []struct {
		Ctx     context.Context
		Index   string
		Options *redis.FTDropIndexOptions
	}
	mock.lockFTDropIndexWithArgs.RLock()
	calls = mock.calls.FTDropIndexWithArgs
	mock.lockFTDropIndexWithArgs.RUnlock()
	return calls
}

// ResetFTDropIndexWithArgsCalls reset all the calls that were made to FTDropIndexWithArgs.
func (mock *MoqCmdable) ResetFTDropIndexWithArgsCalls() {
	mock.lockFTDropIndexWithArgs.Lock()
	mock.calls.FTDropIndexWithArgs = nil
	mock.lockFTDropIndexWithArgs.Unlock()
}

// FTExplain calls FTExplainFunc.
func (mock *MoqCmdable) FTExplain(ctx context.Context, index string, query string) *redis.StringCmd {
	if mock.FTExplainFunc == nil {
		panic("MoqCmdable.FTExplainFunc: method is nil but Cmdable.FTExplain was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Index string
		Query string
	}{
		Ctx:   ctx,
		Index: index,
		Query: query,
	}
	mock.lockFTExplain.Lock()
	mock.calls.FTExplain = append(mock.calls.FTExplain, callInfo)
	mock.lockFTExplain.Unlock()
	return mock.FTExplainFunc(ctx, index, query)
}

// FTExplainCalls gets all the calls that were made to FTExplain.
// Check the length with:
//
//	len(mockedCmdable.FTExplainCalls())
func (mock *MoqCmdable) FTExplainCalls() []struct {
	Ctx   context.Context
	Index string
	Query string
} {
	var calls []struct {
		Ctx   context.Context
		Index string
		Query string
	}
	mock.lockFTExplain.RLock()
	calls = mock.calls.FTExplain
	mock.lockFTExplain.RUnlock()
	return calls
}

// ResetFTExplainCalls reset all the calls that were made to FTExplain.
func (mock *MoqCmdable) ResetFTExplainCalls() {
	mock.lockFTExplain.Lock()
	mock.calls.FTExplain = nil
	mock.lockFTExplain.Unlock()
}

// FTExplainWithArgs calls FTExplainWithArgsFunc.
func (mock *MoqCmdable) FTExplainWithArgs(ctx context.Context, index string, query string, options *redis.FTExplainOptions) *redis.StringCmd {
	if mock.FTExplainWithArgsFunc == nil {
		panic("MoqCmdable.FTExplainWithArgsFunc: method is nil but Cmdable.FTExplainWithArgs was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Index   string
		Query   string
		Options *redis.FTExplainOptions
	}{
		Ctx:     ctx,
		Index:   index,
		Query:   query,
		Options: options,
	}
	mock.lockFTExplainWithArgs.Lock()
	mock.calls.FTExplainWithArgs = append(mock.calls.FTExplainWithArgs, callInfo)
	mock.lockFTExplainWithArgs.Unlock()
	return mock.FTExplainWithArgsFunc(ctx, index, query, options)
}

// FTExplainWithArgsCalls gets all the calls that were made to FTExplainWithArgs.
// Check the length with:
//
//	len(mockedCmdable.FTExplainWithArgsCalls())
func (mock *MoqCmdable) FTExplainWithArgsCalls() []struct {
	Ctx     context.Context
	Index   string
	Query   string
	Options *redis.FTExplainOptions
} {
	var calls []struct {
		Ctx     context.Context
		Index   string
		Query   string
		Options *redis.FTExplainOptions
	}
	mock.lockFTExplainWithArgs.RLock()
	calls = mock.calls.FTExplainWithArgs
	mock.lockFTExplainWithArgs.RUnlock()
	return calls
}

// ResetFTExplainWithArgsCalls reset all the calls that were made to FTExplainWithArgs.
func (mock *MoqCmdable) ResetFTExplainWithArgsCalls() {
	mock.lockFTExplainWithArgs.Lock()
	mock.calls.FTExplainWithArgs = nil
	mock.lockFTExplainWithArgs.Unlock()
}

// FTHybrid calls FTHybridFunc.
func (mock *MoqCmdable) FTHybrid(ctx context.Context, index string, searchExpr string, vectorField string, vectorData redis.Vector) *redis.FTHybridCmd {
	if mock.FTHybridFunc == nil {
		panic("MoqCmdable.FTHybridFunc: method is nil but Cmdable.FTHybrid was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		Index       string
		SearchExpr  string
		VectorField string
		VectorData  redis.Vector
	}{
		Ctx:         ctx,
		Index:       index,
		SearchExpr:  searchExpr,
		VectorField: vectorField,
		VectorData:  vectorData,
	}
	mock.lockFTHybrid.Lock()
	mock.calls.FTHybrid = append(mock.calls.FTHybrid, callInfo)
	mock.lockFTHybrid.Unlock()
	return mock.FTHybridFunc(ctx, index, searchExpr, vectorField, vectorData)
}

// FTHybridCalls gets all the calls that were made to FTHybrid.
// Check the length with:
//
//	len(mockedCmdable.FTHybridCalls())
func (mock *MoqCmdable) FTHybridCalls() []struct {
	Ctx         context.Context
	Index       string
	SearchExpr  string
	VectorField string
	VectorData  redis.Vector
} {
	var calls []struct {
		Ctx         context.Context
		Index       string
		SearchExpr  string
		VectorField string
		VectorData  redis.Vector
	}
	mock.lockFTHybrid.RLock()
	calls = mock.calls.FTHybrid
	mock.lockFTHybrid.RUnlock()
	return calls
}

// ResetFTHybridCalls reset all the calls that were made to FTHybrid.
func (mock *MoqCmdable) ResetFTHybridCalls() {
	mock.lockFTHybrid.Lock()
	mock.calls.FTHybrid = nil
	mock.lockFTHybrid.Unlock()
}

// FTHybridWithArgs calls FTHybridWithArgsFunc.
func (mock *MoqCmdable) FTHybridWithArgs(ctx context.Context, index string, options *redis.FTHybridOptions) *redis.FTHybridCmd {
	if mock.FTHybridWithArgsFunc == nil {
		panic("MoqCmdable.FTHybridWithArgsFunc: method is nil but Cmdable.FTHybridWithArgs was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Index   string
		Options *redis.FTHybridOptions
	}{
		Ctx:     ctx,
		Index:   index,
		Options: options,
	}
	mock.lockFTHybridWithArgs.Lock()
	mock.calls.FTHybridWithArgs = append(mock.calls.FTHybridWithArgs, callInfo)
	mock.lockFTHybridWithArgs.Unlock()
	return mock.FTHybridWithArgsFunc(ctx, index, options)
}

// FTHybridWithArgsCalls gets all the calls that were made to FTHybridWithArgs.
// Check the length with:
//
//	len(mockedCmdable.FTHybridWithArgsCalls())
func (mock *MoqCmdable) FTHybridWithArgsCalls() []struct {
	Ctx     context.Context
	Index   string
	Options *redis.FTHybridOptions
} {
	var calls []struct {
		Ctx     context.Context
		Index   string
		Options *redis.FTHybridOptions
	}
	mock.lockFTHybridWithArgs.RLock()
	calls = mock.calls.FTHybridWithArgs
	mock.lockFTHybridWithArgs.RUnlock()
	return calls
}

// ResetFTHybridWithArgsCalls reset all the calls that were made to FTHybridWithArgs.
func (mock *MoqCmdable) ResetFTHybridWithArgsCalls() {
	mock.lockFTHybridWithArgs.Lock()
	mock.calls.FTHybridWithArgs = nil
	mock.lockFTHybridWithArgs.Unlock()
}

// FTInfo calls FTInfoFunc.
func (mock *MoqCmdable) FTInfo(ctx context.Context, index string) *redis.FTInfoCmd {
	if mock.FTInfoFunc == nil {
		panic("MoqCmdable.FTInfoFunc: method is nil but Cmdable.FTInfo was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Index string
	}{
		Ctx:   ctx,
		Index: index,
	}
	mock.lockFTInfo.Lock()
	mock.calls.FTInfo = append(mock.calls.FTInfo, callInfo)
	mock.lockFTInfo.Unlock()
	return mock.FTInfoFunc(ctx, index)
}

// FTInfoCalls gets all the calls that were made to FTInfo.
// Check the length with:
//
//	len(mockedCmdable.FTInfoCalls())
func (mock *MoqCmdable) FTInfoCalls() []struct {
	Ctx   context.Context
	Index string
} {
	var calls []struct {
		Ctx   context.Context
		Index string
	}
	mock.lockFTInfo.RLock()
	calls = mock.calls.FTInfo
	mock.lockFTInfo.RUnlock()
	return calls
}

// ResetFTInfoCalls reset all the calls that were made to FTInfo.
func (mock *MoqCmdable) ResetFTInfoCalls() {
	mock.lockFTInfo.Lock()
	mock.calls.FTInfo = nil
	mock.lockFTInfo.Unlock()
}

// FTSearch calls FTSearchFunc.
func (mock *MoqCmdable) FTSearch(ctx context.Context, index string, query string) *redis.FTSearchCmd {
	if mock.FTSearchFunc == nil {
		panic("MoqCmdable.FTSearchFunc: method is nil but Cmdable.FTSearch was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Index string
		Query string
	}{
		Ctx:   ctx,
		Index: index,
		Query: query,
	}
	mock.lockFTSearch.Lock()
	mock.calls.FTSearch = append(mock.calls.FTSearch, callInfo)
	mock.lockFTSearch.Unlock()
	return mock.FTSearchFunc(ctx, index, query)
}

// FTSearchCalls gets all the calls that were made to FTSearch.
// Check the length with:
//
//	len(mockedCmdable.FTSearchCalls())
func (mock *MoqCmdable) FTSearchCalls() []struct {
	Ctx   context.Context
	Index string
	Query string
} {
	var calls []struct {
		Ctx   context.Context
		Index string
		Query string
	}
	mock.lockFTSearch.RLock()
	calls = mock.calls.FTSearch
	mock.lockFTSearch.RUnlock()
	return calls
}

// ResetFTSearchCalls reset all the calls that were made to FTSearch.
func (mock *MoqCmdable) ResetFTSearchCalls() {
	mock.lockFTSearch.Lock()
	mock.calls.FTSearch = nil
	mock.lockFTSearch.Unlock()
}

// FTSearchWithArgs calls FTSearchWithArgsFunc.
func (mock *MoqCmdable) FTSearchWithArgs(ctx context.Context, index string, query string, options *redis.FTSearchOptions) *redis.FTSearchCmd {
	if mock.FTSearchWithArgsFunc == nil {
		panic("MoqCmdable.FTSearchWithArgsFunc: method is nil but Cmdable.FTSearchWithArgs was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Index   string
		Query   string
		Options *redis.FTSearchOptions
	}{
		Ctx:     ctx,
		Index:   index,
		Query:   query,
		Options: options,
	}
	mock.lockFTSearchWithArgs.Lock()
	mock.calls.FTSearchWithArgs = append(mock.calls.FTSearchWithArgs, callInfo)
	mock.lockFTSearchWithArgs.Unlock()
	return mock.FTSearchWithArgsFunc(ctx, index, query, options)
}

// FTSearchWithArgsCalls gets all the calls that were made to FTSearchWithArgs.
// Check the length with:
//
//	len(mockedCmdable.FTSearchWithArgsCalls())
func (mock *MoqCmdable) FTSearchWithArgsCalls() []struct {
	Ctx     context.Context
	Index   string
	Query   string
	Options *redis.FTSearchOptions
} {
	var calls []struct {
		Ctx     context.Context
		Index   string
		Query   string
		Options *redis.FTSearchOptions
	}
	mock.lockFTSearchWithArgs.RLock()
	calls = mock.calls.FTSearchWithArgs
	mock.lockFTSearchWithArgs.RUnlock()
	return calls
}

// ResetFTSearchWithArgsCalls reset all the calls that were made to FTSearchWithArgs.
func (mock *MoqCmdable) ResetFTSearchWithArgsCalls() {
	mock.lockFTSearchWithArgs.Lock()
	mock.calls.FTSearchWithArgs = nil
	mock.lockFTSearchWithArgs.Unlock()
}

// FTSpellCheck calls FTSpellCheckFunc.
func (mock *MoqCmdable) FTSpellCheck(ctx context.Context, index string, query string) *redis.FTSpellCheckCmd {
	if mock.FTSpellCheckFunc == nil {
		panic("MoqCmdable.FTSpellCheckFunc: method is nil but Cmdable.FTSpellCheck was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Index string
		Query string
	}{
		Ctx:   ctx,
		Index: index,
		Query: query,
	}
	mock.lockFTSpellCheck.Lock()
	mock.calls.FTSpellCheck = append(mock.calls.FTSpellCheck, callInfo)
	mock.lockFTSpellCheck.Unlock()
	return mock.FTSpellCheckFunc(ctx, index, query)
}

// FTSpellCheckCalls gets all the calls that were made to FTSpellCheck.
// Check the length with:
//
//	len(mockedCmdable.FTSpellCheckCalls())
func (mock *MoqCmdable) FTSpellCheckCalls() []struct {
	Ctx   context.Context
	Index string
	Query string
} {
	var calls []struct {
		Ctx   context.Context
		Index string
		Query string
	}
	mock.lockFTSpellCheck.RLock()
	calls = mock.calls.FTSpellCheck
	mock.lockFTSpellCheck.RUnlock()
	return calls
}

// ResetFTSpellCheckCalls reset all the calls that were made to FTSpellCheck.
func (mock *MoqCmdable) ResetFTSpellCheckCalls() {
	mock.lockFTSpellCheck.Lock()
	mock.calls.FTSpellCheck = nil
	mock.lockFTSpellCheck.Unlock()
}

// FTSpellCheckWithArgs calls FTSpellCheckWithArgsFunc.
func (mock *MoqCmdable) FTSpellCheckWithArgs(ctx context.Context, index string, query string, options *redis.FTSpellCheckOptions) *redis.FTSpellCheckCmd {
	if mock.FTSpellCheckWithArgsFunc == nil {
		panic("MoqCmdable.FTSpellCheckWithArgsFunc: method is nil but Cmdable.FTSpellCheckWithArgs was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Index   string
		Query   string
		Options *redis.FTSpellCheckOptions
	}{
		Ctx:     ctx,
		Index:   index,
		Query:   query,
		Options: options,
	}
	mock.lockFTSpellCheckWithArgs.Lock()
	mock.calls.FTSpellCheckWithArgs = append(mock.calls.FTSpellCheckWithArgs, callInfo)
	mock.lockFTSpellCheckWithArgs.Unlock()
	return mock.FTSpellCheckWithArgsFunc(ctx, index, query, options)
}

// FTSpellCheckWithArgsCalls gets all the calls that were made to FTSpellCheckWithArgs.
// Check the length with:
//
//	len(mockedCmdable.FTSpellCheckWithArgsCalls())
func (mock *MoqCmdable) FTSpellCheckWithArgsCalls() []struct {
	Ctx     context.Context
	Index   string
	Query   string
	Options *redis.FTSpellCheckOptions
} {
	var calls []struct {
		Ctx     context.Context
		Index   string
		Query   string
		Options *redis.FTSpellCheckOptions
	}
	mock.lockFTSpellCheckWithArgs.RLock()
	calls = mock.calls.FTSpellCheckWithArgs
	mock.lockFTSpellCheckWithArgs.RUnlock()
	return calls
}

// ResetFTSpellCheckWithArgsCalls reset all the calls that were made to FTSpellCheckWithArgs.
func (mock *MoqCmdable) ResetFTSpellCheckWithArgsCalls() {
	mock.lockFTSpellCheckWithArgs.Lock()
	mock.calls.FTSpellCheckWithArgs = nil
	mock.lockFTSpellCheckWithArgs.Unlock()
}

// FTSynDump calls FTSynDumpFunc.
func (mock *MoqCmdable) FTSynDump(ctx context.Context, index string) *redis.FTSynDumpCmd {
	if mock.FTSynDumpFunc == nil {
		panic("MoqCmdable.FTSynDumpFunc: method is nil but Cmdable.FTSynDump was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Index string
	}{
		Ctx:   ctx,
		Index: index,
	}
	mock.lockFTSynDump.Lock()
	mock.calls.FTSynDump = append(mock.calls.FTSynDump, callInfo)
	mock.lockFTSynDump.Unlock()
	return mock.FTSynDumpFunc(ctx, index)
}

// FTSynDumpCalls gets all the calls that were made to FTSynDump.
// Check the length with:
//
//	len(mockedCmdable.FTSynDumpCalls())
func (mock *MoqCmdable) FTSynDumpCalls() []struct {
	Ctx   context.Context
	Index string
} {
	var calls []struct {
		Ctx   context.Context
		Index string
	}
	mock.lockFTSynDump.RLock()
	calls = mock.calls.FTSynDump
	mock.lockFTSynDump.RUnlock()
	return calls
}

// ResetFTSynDumpCalls reset all the calls that were made to FTSynDump.
func (mock *MoqCmdable) ResetFTSynDumpCalls() {
	mock.lockFTSynDump.Lock()
	mock.calls.FTSynDump = nil
	mock.lockFTSynDump.Unlock()
}

// FTSynUpdate calls FTSynUpdateFunc.
func (mock *MoqCmdable) FTSynUpdate(ctx context.Context, index string, synGroupId interface{}, terms []interface{}) *redis.StatusCmd {
	if mock.FTSynUpdateFunc == nil {
		panic("MoqCmdable.FTSynUpdateFunc: method is nil but Cmdable.FTSynUpdate was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Index      string
		SynGroupId interface{}
		Terms      []interface{}
	}{
		Ctx:        ctx,
		Index:      index,
		SynGroupId: synGroupId,
		Terms:      terms,
	}
	mock.lockFTSynUpdate.Lock()
	mock.calls.FTSynUpdate = append(mock.calls.FTSynUpdate, callInfo)
	mock.lockFTSynUpdate.Unlock()
	return mock.FTSynUpdateFunc(ctx, index, synGroupId, terms)
}

// FTSynUpdateCalls gets all the calls that were made to FTSynUpdate.
// Check the length with:
//
//	len(mockedCmdable.FTSynUpdateCalls())
func (mock *MoqCmdable) FTSynUpdateCalls() []struct {
	Ctx        context.Context
	Index      string
	SynGroupId interface{}
	Terms      []interface{}
} {
	var calls []struct {
		Ctx        context.Context
		Index      string
		SynGroupId interface{}
		Terms      []interface{}
	}
	mock.lockFTSynUpdate.RLock()
	calls = mock.calls.FTSynUpdate
	mock.lockFTSynUpdate.RUnlock()
	return calls
}

// ResetFTSynUpdateCalls reset all the calls that were made to FTSynUpdate.
func (mock *MoqCmdable) ResetFTSynUpdateCalls() {
	mock.lockFTSynUpdate.Lock()
	mock.calls.FTSynUpdate = nil
	mock.lockFTSynUpdate.Unlock()
}

// FTSynUpdateWithArgs calls FTSynUpdateWithArgsFunc.
func (mock *MoqCmdable) FTSynUpdateWithArgs(ctx context.Context, index string, synGroupId interface{}, options *redis.FTSynUpdateOptions, terms []interface{}) *redis.StatusCmd {
	if mock.FTSynUpdateWithArgsFunc == nil {
		panic("MoqCmdable.FTSynUpdateWithArgsFunc: method is nil but Cmdable.FTSynUpdateWithArgs was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Index      string
		SynGroupId interface{}
		Options    *redis.FTSynUpdateOptions
		Terms      []interface{}
	}{
		Ctx:        ctx,
		Index:      index,
		SynGroupId: synGroupId,
		Options:    options,
		Terms:      terms,
	}
	mock.lockFTSynUpdateWithArgs.Lock()
	mock.calls.FTSynUpdateWithArgs = append(mock.calls.FTSynUpdateWithArgs, callInfo)
	mock.lockFTSynUpdateWithArgs.Unlock()
	return mock.FTSynUpdateWithArgsFunc(ctx, index, synGroupId, options, terms)
}

// FTSynUpdateWithArgsCalls gets all the calls that were made to FTSynUpdateWithArgs.
// Check the length with:
//
//	len(mockedCmdable.FTSynUpdateWithArgsCalls())
func (mock *MoqCmdable) FTSynUpdateWithArgsCalls() []struct {
	Ctx        context.Context
	Index      string
	SynGroupId interface{}
	Options    *redis.FTSynUpdateOptions
	Terms      []interface{}
} {
	var calls []struct {
		Ctx        context.Context
		Index      string
		SynGroupId interface{}
		Options    *redis.FTSynUpdateOptions
		Terms      []interface{}
	}
	mock.lockFTSynUpdateWithArgs.RLock()
	calls = mock.calls.FTSynUpdateWithArgs
	mock.lockFTSynUpdateWithArgs.RUnlock()
	return calls
}

// ResetFTSynUpdateWithArgsCalls reset all the calls that were made to FTSynUpdateWithArgs.
func (mock *MoqCmdable) ResetFTSynUpdateWithArgsCalls() {
	mock.lockFTSynUpdateWithArgs.Lock()
	mock.calls.FTSynUpdateWithArgs = nil
	mock.lockFTSynUpdateWithArgs.Unlock()
}

// FTTagVals calls FTTagValsFunc.
func (mock *MoqCmdable) FTTagVals(ctx context.Context, index string, field string) *redis.StringSliceCmd {
	if mock.FTTagValsFunc == nil {
		panic("MoqCmdable.FTTagValsFunc: method is nil but Cmdable.FTTagVals was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Index string
		Field string
	}{
		Ctx:   ctx,
		Index: index,
		Field: field,
	}
	mock.lockFTTagVals.Lock()
	mock.calls.FTTagVals = append(mock.calls.FTTagVals, callInfo)
	mock.lockFTTagVals.Unlock()
	return mock.FTTagValsFunc(ctx, index, field)
}

// FTTagValsCalls gets all the calls that were made to FTTagVals.
// Check the length with:
//
//	len(mockedCmdable.FTTagValsCalls())
func (mock *MoqCmdable) FTTagValsCalls() []struct {
	Ctx   context.Context
	Index string
	Field string
} {
	var calls []struct {
		Ctx   context.Context
		Index string
		Field string
	}
	mock.lockFTTagVals.RLock()
	calls = mock.calls.FTTagVals
	mock.lockFTTagVals.RUnlock()
	return calls
}

// ResetFTTagValsCalls reset all the calls that were made to FTTagVals.
func (mock *MoqCmdable) ResetFTTagValsCalls() {
	mock.lockFTTagVals.Lock()
	mock.calls.FTTagVals = nil
	mock.lockFTTagVals.Unlock()
}

// FT_List calls FT_ListFunc.
func (mock *MoqCmdable) FT_List(ctx context.Context) *redis.StringSliceCmd {
	if mock.FT_ListFunc == nil {
		panic("MoqCmdable.FT_ListFunc: method is nil but Cmdable.FT_List was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockFT_List.Lock()
	mock.calls.FT_List = append(mock.calls.FT_List, callInfo)
	mock.lockFT_List.Unlock()
	return mock.FT_ListFunc(ctx)
}

// FT_ListCalls gets all the calls that were made to FT_List.
// Check the length with:
//
//	len(mockedCmdable.FT_ListCalls())
func (mock *MoqCmdable) FT_ListCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockFT_List.RLock()
	calls = mock.calls.FT_List
	mock.lockFT_List.RUnlock()
	return calls
}

// ResetFT_ListCalls reset all the calls that were made to FT_List.
func (mock *MoqCmdable) ResetFT_ListCalls() {
	mock.lockFT_List.Lock()
	mock.calls.FT_List = nil
	mock.lockFT_List.Unlock()
}

// FlushAll calls FlushAllFunc.
func (mock *MoqCmdable) FlushAll(ctx context.Context) *redis.StatusCmd {
	if mock.FlushAllFunc == nil {
		panic("MoqCmdable.FlushAllFunc: method is nil but Cmdable.FlushAll was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockFlushAll.Lock()
	mock.calls.FlushAll = append(mock.calls.FlushAll, callInfo)
	mock.lockFlushAll.Unlock()
	return mock.FlushAllFunc(ctx)
}

// FlushAllCalls gets all the calls that were made to FlushAll.
// Check the length with:
//
//	len(mockedCmdable.FlushAllCalls())
func (mock *MoqCmdable) FlushAllCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockFlushAll.RLock()
	calls = mock.calls.FlushAll
	mock.lockFlushAll.RUnlock()
	return calls
}

// ResetFlushAllCalls reset all the calls that were made to FlushAll.
func (mock *MoqCmdable) ResetFlushAllCalls() {
	mock.lockFlushAll.Lock()
	mock.calls.FlushAll = nil
	mock.lockFlushAll.Unlock()
}

// FlushAllAsync calls FlushAllAsyncFunc.
func (mock *MoqCmdable) FlushAllAsync(ctx context.Context) *redis.StatusCmd {
	if mock.FlushAllAsyncFunc == nil {
		panic("MoqCmdable.FlushAllAsyncFunc: method is nil but Cmdable.FlushAllAsync was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockFlushAllAsync.Lock()
	mock.calls.FlushAllAsync = append(mock.calls.FlushAllAsync, callInfo)
	mock.lockFlushAllAsync.Unlock()
	return mock.FlushAllAsyncFunc(ctx)
}

// FlushAllAsyncCalls gets all the calls that were made to FlushAllAsync.
// Check the length with:
//
//	len(mockedCmdable.FlushAllAsyncCalls())
func (mock *MoqCmdable) FlushAllAsyncCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockFlushAllAsync.RLock()
	calls = mock.calls.FlushAllAsync
	mock.lockFlushAllAsync.RUnlock()
	return calls
}

// ResetFlushAllAsyncCalls reset all the calls that were made to FlushAllAsync.
func (mock *MoqCmdable) ResetFlushAllAsyncCalls() {
	mock.lockFlushAllAsync.Lock()
	mock.calls.FlushAllAsync = nil
	mock.lockFlushAllAsync.Unlock()
}

// FlushDB calls FlushDBFunc.
func (mock *MoqCmdable) FlushDB(ctx context.Context) *redis.StatusCmd {
	if mock.FlushDBFunc == nil {
		panic("MoqCmdable.FlushDBFunc: method is nil but Cmdable.FlushDB was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockFlushDB.Lock()
	mock.calls.FlushDB = append(mock.calls.FlushDB, callInfo)
	mock.lockFlushDB.Unlock()
	return mock.FlushDBFunc(ctx)
}

// FlushDBCalls gets all the calls that were made to FlushDB.
// Check the length with:
//
//	len(mockedCmdable.FlushDBCalls())
func (mock *MoqCmdable) FlushDBCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockFlushDB.RLock()
	calls = mock.calls.FlushDB
	mock.lockFlushDB.RUnlock()
	return calls
}

// ResetFlushDBCalls reset all the calls that were made to FlushDB.
func (mock *MoqCmdable) ResetFlushDBCalls() {
	mock.lockFlushDB.Lock()
	mock.calls.FlushDB = nil
	mock.lockFlushDB.Unlock()
}

// FlushDBAsync calls FlushDBAsyncFunc.
func (mock *MoqCmdable) FlushDBAsync(ctx context.Context) *redis.StatusCmd {
	if mock.FlushDBAsyncFunc == nil {
		panic("MoqCmdable.FlushDBAsyncFunc: method is nil but Cmdable.FlushDBAsync was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockFlushDBAsync.Lock()
	mock.calls.FlushDBAsync = append(mock.calls.FlushDBAsync, callInfo)
	mock.lockFlushDBAsync.Unlock()
	return mock.FlushDBAsyncFunc(ctx)
}

// FlushDBAsyncCalls gets all the calls that were made to FlushDBAsync.
// Check the length with:
//
//	len(mockedCmdable.FlushDBAsyncCalls())
func (mock *MoqCmdable) FlushDBAsyncCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockFlushDBAsync.RLock()
	calls = mock.calls.FlushDBAsync
	mock.lockFlushDBAsync.RUnlock()
	return calls
}

// ResetFlushDBAsyncCalls reset all the calls that were made to FlushDBAsync.
func (mock *MoqCmdable) ResetFlushDBAsyncCalls() {
	mock.lockFlushDBAsync.Lock()
	mock.calls.FlushDBAsync = nil
	mock.lockFlushDBAsync.Unlock()
}

// FunctionDelete calls FunctionDeleteFunc.
func (mock *MoqCmdable) FunctionDelete(ctx context.Context, libName string) *redis.StringCmd {
	if mock.FunctionDeleteFunc == nil {
		panic("MoqCmdable.FunctionDeleteFunc: method is nil but Cmdable.FunctionDelete was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		LibName string
	}{
		Ctx:     ctx,
		LibName: libName,
	}
	mock.lockFunctionDelete.Lock()
	mock.calls.FunctionDelete = append(mock.calls.FunctionDelete, callInfo)
	mock.lockFunctionDelete.Unlock()
	return mock.FunctionDeleteFunc(ctx, libName)
}

// FunctionDeleteCalls gets all the calls that were made to FunctionDelete.
// Check the length with:
//
//	len(mockedCmdable.FunctionDeleteCalls())
func (mock *MoqCmdable) FunctionDeleteCalls() []struct {
	Ctx     context.Context
	LibName string
} {
	var calls []struct {
		Ctx     context.Context
		LibName string
	}
	mock.lockFunctionDelete.RLock()
	calls = mock.calls.FunctionDelete
	mock.lockFunctionDelete.RUnlock()
	return calls
}

// ResetFunctionDeleteCalls reset all the calls that were made to FunctionDelete.
func (mock *MoqCmdable) ResetFunctionDeleteCalls() {
	mock.lockFunctionDelete.Lock()
	mock.calls.FunctionDelete = nil
	mock.lockFunctionDelete.Unlock()
}

// FunctionDump calls FunctionDumpFunc.
func (mock *MoqCmdable) FunctionDump(ctx context.Context) *redis.StringCmd {
	if mock.FunctionDumpFunc == nil {
		panic("MoqCmdable.FunctionDumpFunc: method is nil but Cmdable.FunctionDump was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockFunctionDump.Lock()
	mock.calls.FunctionDump = append(mock.calls.FunctionDump, callInfo)
	mock.lockFunctionDump.Unlock()
	return mock.FunctionDumpFunc(ctx)
}

// FunctionDumpCalls gets all the calls that were made to FunctionDump.
// Check the length with:
//
//	len(mockedCmdable.FunctionDumpCalls())
func (mock *MoqCmdable) FunctionDumpCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockFunctionDump.RLock()
	calls = mock.calls.FunctionDump
	mock.lockFunctionDump.RUnlock()
	return calls
}

// ResetFunctionDumpCalls reset all the calls that were made to FunctionDump.
func (mock *MoqCmdable) ResetFunctionDumpCalls() {
	mock.lockFunctionDump.Lock()
	mock.calls.FunctionDump = nil
	mock.lockFunctionDump.Unlock()
}

// FunctionFlush calls FunctionFlushFunc.
func (mock *MoqCmdable) FunctionFlush(ctx context.Context) *redis.StringCmd {
	if mock.FunctionFlushFunc == nil {
		panic("MoqCmdable.FunctionFlushFunc: method is nil but Cmdable.FunctionFlush was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockFunctionFlush.Lock()
	mock.calls.FunctionFlush = append(mock.calls.FunctionFlush, callInfo)
	mock.lockFunctionFlush.Unlock()
	return mock.FunctionFlushFunc(ctx)
}

// FunctionFlushCalls gets all the calls that were made to FunctionFlush.
// Check the length with:
//
//	len(mockedCmdable.FunctionFlushCalls())
func (mock *MoqCmdable) FunctionFlushCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockFunctionFlush.RLock()
	calls = mock.calls.FunctionFlush
	mock.lockFunctionFlush.RUnlock()
	return calls
}

// ResetFunctionFlushCalls reset all the calls that were made to FunctionFlush.
func (mock *MoqCmdable) ResetFunctionFlushCalls() {
	mock.lockFunctionFlush.Lock()
	mock.calls.FunctionFlush = nil
	mock.lockFunctionFlush.Unlock()
}

// FunctionFlushAsync calls FunctionFlushAsyncFunc.
func (mock *MoqCmdable) FunctionFlushAsync(ctx context.Context) *redis.StringCmd {
	if mock.FunctionFlushAsyncFunc == nil {
		panic("MoqCmdable.FunctionFlushAsyncFunc: method is nil but Cmdable.FunctionFlushAsync was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockFunctionFlushAsync.Lock()
	mock.calls.FunctionFlushAsync = append(mock.calls.FunctionFlushAsync, callInfo)
	mock.lockFunctionFlushAsync.Unlock()
	return mock.FunctionFlushAsyncFunc(ctx)
}

// FunctionFlushAsyncCalls gets all the calls that were made to FunctionFlushAsync.
// Check the length with:
//
//	len(mockedCmdable.FunctionFlushAsyncCalls())
func (mock *MoqCmdable) FunctionFlushAsyncCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockFunctionFlushAsync.RLock()
	calls = mock.calls.FunctionFlushAsync
	mock.lockFunctionFlushAsync.RUnlock()
	return calls
}

// ResetFunctionFlushAsyncCalls reset all the calls that were made to FunctionFlushAsync.
func (mock *MoqCmdable) ResetFunctionFlushAsyncCalls() {
	mock.lockFunctionFlushAsync.Lock()
	mock.calls.FunctionFlushAsync = nil
	mock.lockFunctionFlushAsync.Unlock()
}

// FunctionKill calls FunctionKillFunc.
func (mock *MoqCmdable) FunctionKill(ctx context.Context) *redis.StringCmd {
	if mock.FunctionKillFunc == nil {
		panic("MoqCmdable.FunctionKillFunc: method is nil but Cmdable.FunctionKill was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockFunctionKill.Lock()
	mock.calls.FunctionKill = append(mock.calls.FunctionKill, callInfo)
	mock.lockFunctionKill.Unlock()
	return mock.FunctionKillFunc(ctx)
}

// FunctionKillCalls gets all the calls that were made to FunctionKill.
// Check the length with:
//
//	len(mockedCmdable.FunctionKillCalls())
func (mock *MoqCmdable) FunctionKillCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockFunctionKill.RLock()
	calls = mock.calls.FunctionKill
	mock.lockFunctionKill.RUnlock()
	return calls
}

// ResetFunctionKillCalls reset all the calls that were made to FunctionKill.
func (mock *MoqCmdable) ResetFunctionKillCalls() {
	mock.lockFunctionKill.Lock()
	mock.calls.FunctionKill = nil
	mock.lockFunctionKill.Unlock()
}

// FunctionList calls FunctionListFunc.
func (mock *MoqCmdable) FunctionList(ctx context.Context, q redis.FunctionListQuery) *redis.FunctionListCmd {
	if mock.FunctionListFunc == nil {
		panic("MoqCmdable.FunctionListFunc: method is nil but Cmdable.FunctionList was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Q   redis.FunctionListQuery
	}{
		Ctx: ctx,
		Q:   q,
	}
	mock.lockFunctionList.Lock()
	mock.calls.FunctionList = append(mock.calls.FunctionList, callInfo)
	mock.lockFunctionList.Unlock()
	return mock.FunctionListFunc(ctx, q)
}

// FunctionListCalls gets all the calls that were made to FunctionList.
// Check the length with:
//
//	len(mockedCmdable.FunctionListCalls())
func (mock *MoqCmdable) FunctionListCalls() []struct {
	Ctx context.Context
	Q   redis.FunctionListQuery
} {
	var calls []struct {
		Ctx context.Context
		Q   redis.FunctionListQuery
	}
	mock.lockFunctionList.RLock()
	calls = mock.calls.FunctionList
	mock.lockFunctionList.RUnlock()
	return calls
}

// ResetFunctionListCalls reset all the calls that were made to FunctionList.
func (mock *MoqCmdable) ResetFunctionListCalls() {
	mock.lockFunctionList.Lock()
	mock.calls.FunctionList = nil
	mock.lockFunctionList.Unlock()
}

// FunctionLoad calls FunctionLoadFunc.
func (mock *MoqCmdable) FunctionLoad(ctx context.Context, code string) *redis.StringCmd {
	if mock.FunctionLoadFunc == nil {
		panic("MoqCmdable.FunctionLoadFunc: method is nil but Cmdable.FunctionLoad was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Code string
	}{
		Ctx:  ctx,
		Code: code,
	}
	mock.lockFunctionLoad.Lock()
	mock.calls.FunctionLoad = append(mock.calls.FunctionLoad, callInfo)
	mock.lockFunctionLoad.Unlock()
	return mock.FunctionLoadFunc(ctx, code)
}

// FunctionLoadCalls gets all the calls that were made to FunctionLoad.
// Check the length with:
//
//	len(mockedCmdable.FunctionLoadCalls())
func (mock *MoqCmdable) FunctionLoadCalls() []struct {
	Ctx  context.Context
	Code string
} {
	var calls []struct {
		Ctx  context.Context
		Code string
	}
	mock.lockFunctionLoad.RLock()
	calls = mock.calls.FunctionLoad
	mock.lockFunctionLoad.RUnlock()
	return calls
}

// ResetFunctionLoadCalls reset all the calls that were made to FunctionLoad.
func (mock *MoqCmdable) ResetFunctionLoadCalls() {
	mock.lockFunctionLoad.Lock()
	mock.calls.FunctionLoad = nil
	mock.lockFunctionLoad.Unlock()
}

// FunctionLoadReplace calls FunctionLoadReplaceFunc.
func (mock *MoqCmdable) FunctionLoadReplace(ctx context.Context, code string) *redis.StringCmd {
	if mock.FunctionLoadReplaceFunc == nil {
		panic("MoqCmdable.FunctionLoadReplaceFunc: method is nil but Cmdable.FunctionLoadReplace was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Code string
	}{
		Ctx:  ctx,
		Code: code,
	}
	mock.lockFunctionLoadReplace.Lock()
	mock.calls.FunctionLoadReplace = append(mock.calls.FunctionLoadReplace, callInfo)
	mock.lockFunctionLoadReplace.Unlock()
	return mock.FunctionLoadReplaceFunc(ctx, code)
}

// FunctionLoadReplaceCalls gets all the calls that were made to FunctionLoadReplace.
// Check the length with:
//
//	len(mockedCmdable.FunctionLoadReplaceCalls())
func (mock *MoqCmdable) FunctionLoadReplaceCalls() []struct {
	Ctx  context.Context
	Code string
} {
	var calls []struct {
		Ctx  context.Context
		Code string
	}
	mock.lockFunctionLoadReplace.RLock()
	calls = mock.calls.FunctionLoadReplace
	mock.lockFunctionLoadReplace.RUnlock()
	return calls
}

// ResetFunctionLoadReplaceCalls reset all the calls that were made to FunctionLoadReplace.
func (mock *MoqCmdable) ResetFunctionLoadReplaceCalls() {
	mock.lockFunctionLoadReplace.Lock()
	mock.calls.FunctionLoadReplace = nil
	mock.lockFunctionLoadReplace.Unlock()
}

// FunctionRestore calls FunctionRestoreFunc.
func (mock *MoqCmdable) FunctionRestore(ctx context.Context, libDump string) *redis.StringCmd {
	if mock.FunctionRestoreFunc == nil {
		panic("MoqCmdable.FunctionRestoreFunc: method is nil but Cmdable.FunctionRestore was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		LibDump string
	}{
		Ctx:     ctx,
		LibDump: libDump,
	}
	mock.lockFunctionRestore.Lock()
	mock.calls.FunctionRestore = append(mock.calls.FunctionRestore, callInfo)
	mock.lockFunctionRestore.Unlock()
	return mock.FunctionRestoreFunc(ctx, libDump)
}

// FunctionRestoreCalls gets all the calls that were made to FunctionRestore.
// Check the length with:
//
//	len(mockedCmdable.FunctionRestoreCalls())
func (mock *MoqCmdable) FunctionRestoreCalls() []struct {
	Ctx     context.Context
	LibDump string
} {
	var calls []struct {
		Ctx     context.Context
		LibDump string
	}
	mock.lockFunctionRestore.RLock()
	calls = mock.calls.FunctionRestore
	mock.lockFunctionRestore.RUnlock()
	return calls
}

// ResetFunctionRestoreCalls reset all the calls that were made to FunctionRestore.
func (mock *MoqCmdable) ResetFunctionRestoreCalls() {
	mock.lockFunctionRestore.Lock()
	mock.calls.FunctionRestore = nil
	mock.lockFunctionRestore.Unlock()
}

// FunctionStats calls FunctionStatsFunc.
func (mock *MoqCmdable) FunctionStats(ctx context.Context) *redis.FunctionStatsCmd {
	if mock.FunctionStatsFunc == nil {
		panic("MoqCmdable.FunctionStatsFunc: method is nil but Cmdable.FunctionStats was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockFunctionStats.Lock()
	mock.calls.FunctionStats = append(mock.calls.FunctionStats, callInfo)
	mock.lockFunctionStats.Unlock()
	return mock.FunctionStatsFunc(ctx)
}

// FunctionStatsCalls gets all the calls that were made to FunctionStats.
// Check the length with:
//
//	len(mockedCmdable.FunctionStatsCalls())
func (mock *MoqCmdable) FunctionStatsCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockFunctionStats.RLock()
	calls = mock.calls.FunctionStats
	mock.lockFunctionStats.RUnlock()
	return calls
}

// ResetFunctionStatsCalls reset all the calls that were made to FunctionStats.
func (mock *MoqCmdable) ResetFunctionStatsCalls() {
	mock.lockFunctionStats.Lock()
	mock.calls.FunctionStats = nil
	mock.lockFunctionStats.Unlock()
}

// GeoAdd calls GeoAddFunc.
func (mock *MoqCmdable) GeoAdd(ctx context.Context, key string, geoLocation ...*redis.GeoLocation) *redis.IntCmd {
	if mock.GeoAddFunc == nil {
		panic("MoqCmdable.GeoAddFunc: method is nil but Cmdable.GeoAdd was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		Key         string
		GeoLocation []*redis.GeoLocation
	}{
		Ctx:         ctx,
		Key:         key,
		GeoLocation: geoLocation,
	}
	mock.lockGeoAdd.Lock()
	mock.calls.GeoAdd = append(mock.calls.GeoAdd, callInfo)
	mock.lockGeoAdd.Unlock()
	return mock.GeoAddFunc(ctx, key, geoLocation...)
}

// GeoAddCalls gets all the calls that were made to GeoAdd.
// Check the length with:
//
//	len(mockedCmdable.GeoAddCalls())
func (mock *MoqCmdable) GeoAddCalls() []struct {
	Ctx         context.Context
	Key         string
	GeoLocation []*redis.GeoLocation
} {
	var calls []struct {
		Ctx         context.Context
		Key         string
		GeoLocation []*redis.GeoLocation
	}
	mock.lockGeoAdd.RLock()
	calls = mock.calls.GeoAdd
	mock.lockGeoAdd.RUnlock()
	return calls
}

// ResetGeoAddCalls reset all the calls that were made to GeoAdd.
func (mock *MoqCmdable) ResetGeoAddCalls() {
	mock.lockGeoAdd.Lock()
	mock.calls.GeoAdd = nil
	mock.lockGeoAdd.Unlock()
}

// GeoDist calls GeoDistFunc.
func (mock *MoqCmdable) GeoDist(ctx context.Context, key string, member1 string, member2 string, unit string) *redis.FloatCmd {
	if mock.GeoDistFunc == nil {
		panic("MoqCmdable.GeoDistFunc: method is nil but Cmdable.GeoDist was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Key     string
		Member1 string
		Member2 string
		Unit    string
	}{
		Ctx:     ctx,
		Key:     key,
		Member1: member1,
		Member2: member2,
		Unit:    unit,
	}
	mock.lockGeoDist.Lock()
	mock.calls.GeoDist = append(mock.calls.GeoDist, callInfo)
	mock.lockGeoDist.Unlock()
	return mock.GeoDistFunc(ctx, key, member1, member2, unit)
}

// GeoDistCalls gets all the calls that were made to GeoDist.
// Check the length with:
//
//	len(mockedCmdable.GeoDistCalls())
func (mock *MoqCmdable) GeoDistCalls() []struct {
	Ctx     context.Context
	Key     string
	Member1 string
	Member2 string
	Unit    string
} {
	var calls []struct {
		Ctx     context.Context
		Key     string
		Member1 string
		Member2 string
		Unit    string
	}
	mock.lockGeoDist.RLock()
	calls = mock.calls.GeoDist
	mock.lockGeoDist.RUnlock()
	return calls
}

// ResetGeoDistCalls reset all the calls that were made to GeoDist.
func (mock *MoqCmdable) ResetGeoDistCalls() {
	mock.lockGeoDist.Lock()
	mock.calls.GeoDist = nil
	mock.lockGeoDist.Unlock()
}

// GeoHash calls GeoHashFunc.
func (mock *MoqCmdable) GeoHash(ctx context.Context, key string, members ...string) *redis.StringSliceCmd {
	if mock.GeoHashFunc == nil {
		panic("MoqCmdable.GeoHashFunc: method is nil but Cmdable.GeoHash was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Key     string
		Members []string
	}{
		Ctx:     ctx,
		Key:     key,
		Members: members,
	}
	mock.lockGeoHash.Lock()
	mock.calls.GeoHash = append(mock.calls.GeoHash, callInfo)
	mock.lockGeoHash.Unlock()
	return mock.GeoHashFunc(ctx, key, members...)
}

// GeoHashCalls gets all the calls that were made to GeoHash.
// Check the length with:
//
//	len(mockedCmdable.GeoHashCalls())
func (mock *MoqCmdable) GeoHashCalls() []struct {
	Ctx     context.Context
	Key     string
	Members []string
} {
	var calls []struct {
		Ctx     context.Context
		Key     string
		Members []string
	}
	mock.lockGeoHash.RLock()
	calls = mock.calls.GeoHash
	mock.lockGeoHash.RUnlock()
	return calls
}

// ResetGeoHashCalls reset all the calls that were made to GeoHash.
func (mock *MoqCmdable) ResetGeoHashCalls() {
	mock.lockGeoHash.Lock()
	mock.calls.GeoHash = nil
	mock.lockGeoHash.Unlock()
}

// GeoPos calls GeoPosFunc.
func (mock *MoqCmdable) GeoPos(ctx context.Context, key string, members ...string) *redis.GeoPosCmd {
	if mock.GeoPosFunc == nil {
		panic("MoqCmdable.GeoPosFunc: method is nil but Cmdable.GeoPos was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Key     string
		Members []string
	}{
		Ctx:     ctx,
		Key:     key,
		Members: members,
	}
	mock.lockGeoPos.Lock()
	mock.calls.GeoPos = append(mock.calls.GeoPos, callInfo)
	mock.lockGeoPos.Unlock()
	return mock.GeoPosFunc(ctx, key, members...)
}

// GeoPosCalls gets all the calls that were made to GeoPos.
// Check the length with:
//
//	len(mockedCmdable.GeoPosCalls())
func (mock *MoqCmdable) GeoPosCalls() []struct {
	Ctx     context.Context
	Key     string
	Members []string
} {
	var calls []struct {
		Ctx     context.Context
		Key     string
		Members []string
	}
	mock.lockGeoPos.RLock()
	calls = mock.calls.GeoPos
	mock.lockGeoPos.RUnlock()
	return calls
}

// ResetGeoPosCalls reset all the calls that were made to GeoPos.
func (mock *MoqCmdable) ResetGeoPosCalls() {
	mock.lockGeoPos.Lock()
	mock.calls.GeoPos = nil
	mock.lockGeoPos.Unlock()
}

// GeoRadius calls GeoRadiusFunc.
func (mock *MoqCmdable) GeoRadius(ctx context.Context, key string, longitude float64, latitude float64, query *redis.GeoRadiusQuery) *redis.GeoLocationCmd {
	if mock.GeoRadiusFunc == nil {
		panic("MoqCmdable.GeoRadiusFunc: method is nil but Cmdable.GeoRadius was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Key       string
		Longitude float64
		Latitude  float64
		Query     *redis.GeoRadiusQuery
	}{
		Ctx:       ctx,
		Key:       key,
		Longitude: longitude,
		Latitude:  latitude,
		Query:     query,
	}
	mock.lockGeoRadius.Lock()
	mock.calls.GeoRadius = append(mock.calls.GeoRadius, callInfo)
	mock.lockGeoRadius.Unlock()
	return mock.GeoRadiusFunc(ctx, key, longitude, latitude, query)
}

// GeoRadiusCalls gets all the calls that were made to GeoRadius.
// Check the length with:
//
//	len(mockedCmdable.GeoRadiusCalls())
func (mock *MoqCmdable) GeoRadiusCalls() []struct {
	Ctx       context.Context
	Key       string
	Longitude float64
	Latitude  float64
	Query     *redis.GeoRadiusQuery
} {
	var calls []struct {
		Ctx       context.Context
		Key       string
		Longitude float64
		Latitude  float64
		Query     *redis.GeoRadiusQuery
	}
	mock.lockGeoRadius.RLock()
	calls = mock.calls.GeoRadius
	mock.lockGeoRadius.RUnlock()
	return calls
}

// ResetGeoRadiusCalls reset all the calls that were made to GeoRadius.
func (mock *MoqCmdable) ResetGeoRadiusCalls() {
	mock.lockGeoRadius.Lock()
	mock.calls.GeoRadius = nil
	mock.lockGeoRadius.Unlock()
}

// GeoRadiusByMember calls GeoRadiusByMemberFunc.
func (mock *MoqCmdable) GeoRadiusByMember(ctx context.Context, key string, member string, query *redis.GeoRadiusQuery) *redis.GeoLocationCmd {
	if mock.GeoRadiusByMemberFunc == nil {
		panic("MoqCmdable.GeoRadiusByMemberFunc: method is nil but Cmdable.GeoRadiusByMember was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		Member string
		Query  *redis.GeoRadiusQuery
	}{
		Ctx:    ctx,
		Key:    key,
		Member: member,
		Query:  query,
	}
	mock.lockGeoRadiusByMember.Lock()
	mock.calls.GeoRadiusByMember = append(mock.calls.GeoRadiusByMember, callInfo)
	mock.lockGeoRadiusByMember.Unlock()
	return mock.GeoRadiusByMemberFunc(ctx, key, member, query)
}

// GeoRadiusByMemberCalls gets all the calls that were made to GeoRadiusByMember.
// Check the length with:
//
//	len(mockedCmdable.GeoRadiusByMemberCalls())
func (mock *MoqCmdable) GeoRadiusByMemberCalls() []struct {
	Ctx    context.Context
	Key    string
	Member string
	Query  *redis.GeoRadiusQuery
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		Member string
		Query  *redis.GeoRadiusQuery
	}
	mock.lockGeoRadiusByMember.RLock()
	calls = mock.calls.GeoRadiusByMember
	mock.lockGeoRadiusByMember.RUnlock()
	return calls
}

// ResetGeoRadiusByMemberCalls reset all the calls that were made to GeoRadiusByMember.
func (mock *MoqCmdable) ResetGeoRadiusByMemberCalls() {
	mock.lockGeoRadiusByMember.Lock()
	mock.calls.GeoRadiusByMember = nil
	mock.lockGeoRadiusByMember.Unlock()
}

// GeoRadiusByMemberStore calls GeoRadiusByMemberStoreFunc.
func (mock *MoqCmdable) GeoRadiusByMemberStore(ctx context.Context, key string, member string, query *redis.GeoRadiusQuery) *redis.IntCmd {
	if mock.GeoRadiusByMemberStoreFunc == nil {
		panic("MoqCmdable.GeoRadiusByMemberStoreFunc: method is nil but Cmdable.GeoRadiusByMemberStore was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		Member string
		Query  *redis.GeoRadiusQuery
	}{
		Ctx:    ctx,
		Key:    key,
		Member: member,
		Query:  query,
	}
	mock.lockGeoRadiusByMemberStore.Lock()
	mock.calls.GeoRadiusByMemberStore = append(mock.calls.GeoRadiusByMemberStore, callInfo)
	mock.lockGeoRadiusByMemberStore.Unlock()
	return mock.GeoRadiusByMemberStoreFunc(ctx, key, member, query)
}

// GeoRadiusByMemberStoreCalls gets all the calls that were made to GeoRadiusByMemberStore.
// Check the length with:
//
//	len(mockedCmdable.GeoRadiusByMemberStoreCalls())
func (mock *MoqCmdable) GeoRadiusByMemberStoreCalls() []struct {
	Ctx    context.Context
	Key    string
	Member string
	Query  *redis.GeoRadiusQuery
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		Member string
		Query  *redis.GeoRadiusQuery
	}
	mock.lockGeoRadiusByMemberStore.RLock()
	calls = mock.calls.GeoRadiusByMemberStore
	mock.lockGeoRadiusByMemberStore.RUnlock()
	return calls
}

// ResetGeoRadiusByMemberStoreCalls reset all the calls that were made to GeoRadiusByMemberStore.
func (mock *MoqCmdable) ResetGeoRadiusByMemberStoreCalls() {
	mock.lockGeoRadiusByMemberStore.Lock()
	mock.calls.GeoRadiusByMemberStore = nil
	mock.lockGeoRadiusByMemberStore.Unlock()
}

// GeoRadiusStore calls GeoRadiusStoreFunc.
func (mock *MoqCmdable) GeoRadiusStore(ctx context.Context, key string, longitude float64, latitude float64, query *redis.GeoRadiusQuery) *redis.IntCmd {
	if mock.GeoRadiusStoreFunc == nil {
		panic("MoqCmdable.GeoRadiusStoreFunc: method is nil but Cmdable.GeoRadiusStore was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Key       string
		Longitude float64
		Latitude  float64
		Query     *redis.GeoRadiusQuery
	}{
		Ctx:       ctx,
		Key:       key,
		Longitude: longitude,
		Latitude:  latitude,
		Query:     query,
	}
	mock.lockGeoRadiusStore.Lock()
	mock.calls.GeoRadiusStore = append(mock.calls.GeoRadiusStore, callInfo)
	mock.lockGeoRadiusStore.Unlock()
	return mock.GeoRadiusStoreFunc(ctx, key, longitude, latitude, query)
}

// GeoRadiusStoreCalls gets all the calls that were made to GeoRadiusStore.
// Check the length with:
//
//	len(mockedCmdable.GeoRadiusStoreCalls())
func (mock *MoqCmdable) GeoRadiusStoreCalls() []struct {
	Ctx       context.Context
	Key       string
	Longitude float64
	Latitude  float64
	Query     *redis.GeoRadiusQuery
} {
	var calls []struct {
		Ctx       context.Context
		Key       string
		Longitude float64
		Latitude  float64
		Query     *redis.GeoRadiusQuery
	}
	mock.lockGeoRadiusStore.RLock()
	calls = mock.calls.GeoRadiusStore
	mock.lockGeoRadiusStore.RUnlock()
	return calls
}

// ResetGeoRadiusStoreCalls reset all the calls that were made to GeoRadiusStore.
func (mock *MoqCmdable) ResetGeoRadiusStoreCalls() {
	mock.lockGeoRadiusStore.Lock()
	mock.calls.GeoRadiusStore = nil
	mock.lockGeoRadiusStore.Unlock()
}

// GeoSearch calls GeoSearchFunc.
func (mock *MoqCmdable) GeoSearch(ctx context.Context, key string, q *redis.GeoSearchQuery) *redis.StringSliceCmd {
	if mock.GeoSearchFunc == nil {
		panic("MoqCmdable.GeoSearchFunc: method is nil but Cmdable.GeoSearch was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
		Q   *redis.GeoSearchQuery
	}{
		Ctx: ctx,
		Key: key,
		Q:   q,
	}
	mock.lockGeoSearch.Lock()
	mock.calls.GeoSearch = append(mock.calls.GeoSearch, callInfo)
	mock.lockGeoSearch.Unlock()
	return mock.GeoSearchFunc(ctx, key, q)
}

// GeoSearchCalls gets all the calls that were made to GeoSearch.
// Check the length with:
//
//	len(mockedCmdable.GeoSearchCalls())
func (mock *MoqCmdable) GeoSearchCalls() []struct {
	Ctx context.Context
	Key string
	Q   *redis.GeoSearchQuery
} {
	var calls []struct {
		Ctx context.Context
		Key string
		Q   *redis.GeoSearchQuery
	}
	mock.lockGeoSearch.RLock()
	calls = mock.calls.GeoSearch
	mock.lockGeoSearch.RUnlock()
	return calls
}

// ResetGeoSearchCalls reset all the calls that were made to GeoSearch.
func (mock *MoqCmdable) ResetGeoSearchCalls() {
	mock.lockGeoSearch.Lock()
	mock.calls.GeoSearch = nil
	mock.lockGeoSearch.Unlock()
}

// GeoSearchLocation calls GeoSearchLocationFunc.
func (mock *MoqCmdable) GeoSearchLocation(ctx context.Context, key string, q *redis.GeoSearchLocationQuery) *redis.GeoSearchLocationCmd {
	if mock.GeoSearchLocationFunc == nil {
		panic("MoqCmdable.GeoSearchLocationFunc: method is nil but Cmdable.GeoSearchLocation was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
		Q   *redis.GeoSearchLocationQuery
	}{
		Ctx: ctx,
		Key: key,
		Q:   q,
	}
	mock.lockGeoSearchLocation.Lock()
	mock.calls.GeoSearchLocation = append(mock.calls.GeoSearchLocation, callInfo)
	mock.lockGeoSearchLocation.Unlock()
	return mock.GeoSearchLocationFunc(ctx, key, q)
}

// GeoSearchLocationCalls gets all the calls that were made to GeoSearchLocation.
// Check the length with:
//
//	len(mockedCmdable.GeoSearchLocationCalls())
func (mock *MoqCmdable) GeoSearchLocationCalls() []struct {
	Ctx context.Context
	Key string
	Q   *redis.GeoSearchLocationQuery
} {
	var calls []struct {
		Ctx context.Context
		Key string
		Q   *redis.GeoSearchLocationQuery
	}
	mock.lockGeoSearchLocation.RLock()
	calls = mock.calls.GeoSearchLocation
	mock.lockGeoSearchLocation.RUnlock()
	return calls
}

// ResetGeoSearchLocationCalls reset all the calls that were made to GeoSearchLocation.
func (mock *MoqCmdable) ResetGeoSearchLocationCalls() {
	mock.lockGeoSearchLocation.Lock()
	mock.calls.GeoSearchLocation = nil
	mock.lockGeoSearchLocation.Unlock()
}

// GeoSearchStore calls GeoSearchStoreFunc.
func (mock *MoqCmdable) GeoSearchStore(ctx context.Context, key string, store string, q *redis.GeoSearchStoreQuery) *redis.IntCmd {
	if mock.GeoSearchStoreFunc == nil {
		panic("MoqCmdable.GeoSearchStoreFunc: method is nil but Cmdable.GeoSearchStore was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Store string
		Q     *redis.GeoSearchStoreQuery
	}{
		Ctx:   ctx,
		Key:   key,
		Store: store,
		Q:     q,
	}
	mock.lockGeoSearchStore.Lock()
	mock.calls.GeoSearchStore = append(mock.calls.GeoSearchStore, callInfo)
	mock.lockGeoSearchStore.Unlock()
	return mock.GeoSearchStoreFunc(ctx, key, store, q)
}

// GeoSearchStoreCalls gets all the calls that were made to GeoSearchStore.
// Check the length with:
//
//	len(mockedCmdable.GeoSearchStoreCalls())
func (mock *MoqCmdable) GeoSearchStoreCalls() []struct {
	Ctx   context.Context
	Key   string
	Store string
	Q     *redis.GeoSearchStoreQuery
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Store string
		Q     *redis.GeoSearchStoreQuery
	}
	mock.lockGeoSearchStore.RLock()
	calls = mock.calls.GeoSearchStore
	mock.lockGeoSearchStore.RUnlock()
	return calls
}

// ResetGeoSearchStoreCalls reset all the calls that were made to GeoSearchStore.
func (mock *MoqCmdable) ResetGeoSearchStoreCalls() {
	mock.lockGeoSearchStore.Lock()
	mock.calls.GeoSearchStore = nil
	mock.lockGeoSearchStore.Unlock()
}

// Get calls GetFunc.
func (mock *MoqCmdable) Get(ctx context.Context, key string) *redis.StringCmd {
	if mock.GetFunc == nil {
		panic("MoqCmdable.GetFunc: method is nil but Cmdable.Get was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc(ctx, key)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedCmdable.GetCalls())
func (mock *MoqCmdable) GetCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// ResetGetCalls reset all the calls that were made to Get.
func (mock *MoqCmdable) ResetGetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// GetBit calls GetBitFunc.
func (mock *MoqCmdable) GetBit(ctx context.Context, key string, offset int64) *redis.IntCmd {
	if mock.GetBitFunc == nil {
		panic("MoqCmdable.GetBitFunc: method is nil but Cmdable.GetBit was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		Offset int64
	}{
		Ctx:    ctx,
		Key:    key,
		Offset: offset,
	}
	mock.lockGetBit.Lock()
	mock.calls.GetBit = append(mock.calls.GetBit, callInfo)
	mock.lockGetBit.Unlock()
	return mock.GetBitFunc(ctx, key, offset)
}

// GetBitCalls gets all the calls that were made to GetBit.
// Check the length with:
//
//	len(mockedCmdable.GetBitCalls())
func (mock *MoqCmdable) GetBitCalls() []struct {
	Ctx    context.Context
	Key    string
	Offset int64
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		Offset int64
	}
	mock.lockGetBit.RLock()
	calls = mock.calls.GetBit
	mock.lockGetBit.RUnlock()
	return calls
}

// ResetGetBitCalls reset all the calls that were made to GetBit.
func (mock *MoqCmdable) ResetGetBitCalls() {
	mock.lockGetBit.Lock()
	mock.calls.GetBit = nil
	mock.lockGetBit.Unlock()
}

// GetDel calls GetDelFunc.
func (mock *MoqCmdable) GetDel(ctx context.Context, key string) *redis.StringCmd {
	if mock.GetDelFunc == nil {
		panic("MoqCmdable.GetDelFunc: method is nil but Cmdable.GetDel was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockGetDel.Lock()
	mock.calls.GetDel = append(mock.calls.GetDel, callInfo)
	mock.lockGetDel.Unlock()
	return mock.GetDelFunc(ctx, key)
}

// GetDelCalls gets all the calls that were made to GetDel.
// Check the length with:
//
//	len(mockedCmdable.GetDelCalls())
func (mock *MoqCmdable) GetDelCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockGetDel.RLock()
	calls = mock.calls.GetDel
	mock.lockGetDel.RUnlock()
	return calls
}

// ResetGetDelCalls reset all the calls that were made to GetDel.
func (mock *MoqCmdable) ResetGetDelCalls() {
	mock.lockGetDel.Lock()
	mock.calls.GetDel = nil
	mock.lockGetDel.Unlock()
}

// GetEx calls GetExFunc.
func (mock *MoqCmdable) GetEx(ctx context.Context, key string, expiration time.Duration) *redis.StringCmd {
	if mock.GetExFunc == nil {
		panic("MoqCmdable.GetExFunc: method is nil but Cmdable.GetEx was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Key        string
		Expiration time.Duration
	}{
		Ctx:        ctx,
		Key:        key,
		Expiration: expiration,
	}
	mock.lockGetEx.Lock()
	mock.calls.GetEx = append(mock.calls.GetEx, callInfo)
	mock.lockGetEx.Unlock()
	return mock.GetExFunc(ctx, key, expiration)
}

// GetExCalls gets all the calls that were made to GetEx.
// Check the length with:
//
//	len(mockedCmdable.GetExCalls())
func (mock *MoqCmdable) GetExCalls() []struct {
	Ctx        context.Context
	Key        string
	Expiration time.Duration
} {
	var calls []struct {
		Ctx        context.Context
		Key        string
		Expiration time.Duration
	}
	mock.lockGetEx.RLock()
	calls = mock.calls.GetEx
	mock.lockGetEx.RUnlock()
	return calls
}

// ResetGetExCalls reset all the calls that were made to GetEx.
func (mock *MoqCmdable) ResetGetExCalls() {
	mock.lockGetEx.Lock()
	mock.calls.GetEx = nil
	mock.lockGetEx.Unlock()
}

// GetRange calls GetRangeFunc.
func (mock *MoqCmdable) GetRange(ctx context.Context, key string, start int64, end int64) *redis.StringCmd {
	if mock.GetRangeFunc == nil {
		panic("MoqCmdable.GetRangeFunc: method is nil but Cmdable.GetRange was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Start int64
		End   int64
	}{
		Ctx:   ctx,
		Key:   key,
		Start: start,
		End:   end,
	}
	mock.lockGetRange.Lock()
	mock.calls.GetRange = append(mock.calls.GetRange, callInfo)
	mock.lockGetRange.Unlock()
	return mock.GetRangeFunc(ctx, key, start, end)
}

// GetRangeCalls gets all the calls that were made to GetRange.
// Check the length with:
//
//	len(mockedCmdable.GetRangeCalls())
func (mock *MoqCmdable) GetRangeCalls() []struct {
	Ctx   context.Context
	Key   string
	Start int64
	End   int64
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Start int64
		End   int64
	}
	mock.lockGetRange.RLock()
	calls = mock.calls.GetRange
	mock.lockGetRange.RUnlock()
	return calls
}

// ResetGetRangeCalls reset all the calls that were made to GetRange.
func (mock *MoqCmdable) ResetGetRangeCalls() {
	mock.lockGetRange.Lock()
	mock.calls.GetRange = nil
	mock.lockGetRange.Unlock()
}

// GetSet calls GetSetFunc.
func (mock *MoqCmdable) GetSet(ctx context.Context, key string, value interface{}) *redis.StringCmd {
	if mock.GetSetFunc == nil {
		panic("MoqCmdable.GetSetFunc: method is nil but Cmdable.GetSet was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Value interface{}
	}{
		Ctx:   ctx,
		Key:   key,
		Value: value,
	}
	mock.lockGetSet.Lock()
	mock.calls.GetSet = append(mock.calls.GetSet, callInfo)
	mock.lockGetSet.Unlock()
	return mock.GetSetFunc(ctx, key, value)
}

// GetSetCalls gets all the calls that were made to GetSet.
// Check the length with:
//
//	len(mockedCmdable.GetSetCalls())
func (mock *MoqCmdable) GetSetCalls() []struct {
	Ctx   context.Context
	Key   string
	Value interface{}
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Value interface{}
	}
	mock.lockGetSet.RLock()
	calls = mock.calls.GetSet
	mock.lockGetSet.RUnlock()
	return calls
}

// ResetGetSetCalls reset all the calls that were made to GetSet.
func (mock *MoqCmdable) ResetGetSetCalls() {
	mock.lockGetSet.Lock()
	mock.calls.GetSet = nil
	mock.lockGetSet.Unlock()
}

// HDel calls HDelFunc.
func (mock *MoqCmdable) HDel(ctx context.Context, key string, fields ...string) *redis.IntCmd {
	if mock.HDelFunc == nil {
		panic("MoqCmdable.HDelFunc: method is nil but Cmdable.HDel was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		Fields []string
	}{
		Ctx:    ctx,
		Key:    key,
		Fields: fields,
	}
	mock.lockHDel.Lock()
	mock.calls.HDel = append(mock.calls.HDel, callInfo)
	mock.lockHDel.Unlock()
	return mock.HDelFunc(ctx, key, fields...)
}

// HDelCalls gets all the calls that were made to HDel.
// Check the length with:
//
//	len(mockedCmdable.HDelCalls())
func (mock *MoqCmdable) HDelCalls() []struct {
	Ctx    context.Context
	Key    string
	Fields []string
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		Fields []string
	}
	mock.lockHDel.RLock()
	calls = mock.calls.HDel
	mock.lockHDel.RUnlock()
	return calls
}

// ResetHDelCalls reset all the calls that were made to HDel.
func (mock *MoqCmdable) ResetHDelCalls() {
	mock.lockHDel.Lock()
	mock.calls.HDel = nil
	mock.lockHDel.Unlock()
}

// HExists calls HExistsFunc.
func (mock *MoqCmdable) HExists(ctx context.Context, key string, field string) *redis.BoolCmd {
	if mock.HExistsFunc == nil {
		panic("MoqCmdable.HExistsFunc: method is nil but Cmdable.HExists was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Field string
	}{
		Ctx:   ctx,
		Key:   key,
		Field: field,
	}
	mock.lockHExists.Lock()
	mock.calls.HExists = append(mock.calls.HExists, callInfo)
	mock.lockHExists.Unlock()
	return mock.HExistsFunc(ctx, key, field)
}

// HExistsCalls gets all the calls that were made to HExists.
// Check the length with:
//
//	len(mockedCmdable.HExistsCalls())
func (mock *MoqCmdable) HExistsCalls() []struct {
	Ctx   context.Context
	Key   string
	Field string
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Field string
	}
	mock.lockHExists.RLock()
	calls = mock.calls.HExists
	mock.lockHExists.RUnlock()
	return calls
}

// ResetHExistsCalls reset all the calls that were made to HExists.
func (mock *MoqCmdable) ResetHExistsCalls() {
	mock.lockHExists.Lock()
	mock.calls.HExists = nil
	mock.lockHExists.Unlock()
}

// HExpire calls HExpireFunc.
func (mock *MoqCmdable) HExpire(ctx context.Context, key string, expiration time.Duration, fields ...string) *redis.IntSliceCmd {
	if mock.HExpireFunc == nil {
		panic("MoqCmdable.HExpireFunc: method is nil but Cmdable.HExpire was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Key        string
		Expiration time.Duration
		Fields     []string
	}{
		Ctx:        ctx,
		Key:        key,
		Expiration: expiration,
		Fields:     fields,
	}
	mock.lockHExpire.Lock()
	mock.calls.HExpire = append(mock.calls.HExpire, callInfo)
	mock.lockHExpire.Unlock()
	return mock.HExpireFunc(ctx, key, expiration, fields...)
}

// HExpireCalls gets all the calls that were made to HExpire.
// Check the length with:
//
//	len(mockedCmdable.HExpireCalls())
func (mock *MoqCmdable) HExpireCalls() []struct {
	Ctx        context.Context
	Key        string
	Expiration time.Duration
	Fields     []string
} {
	var calls []struct {
		Ctx        context.Context
		Key        string
		Expiration time.Duration
		Fields     []string
	}
	mock.lockHExpire.RLock()
	calls = mock.calls.HExpire
	mock.lockHExpire.RUnlock()
	return calls
}

// ResetHExpireCalls reset all the calls that were made to HExpire.
func (mock *MoqCmdable) ResetHExpireCalls() {
	mock.lockHExpire.Lock()
	mock.calls.HExpire = nil
	mock.lockHExpire.Unlock()
}

// HExpireAt calls HExpireAtFunc.
func (mock *MoqCmdable) HExpireAt(ctx context.Context, key string, tm time.Time, fields ...string) *redis.IntSliceCmd {
	if mock.HExpireAtFunc == nil {
		panic("MoqCmdable.HExpireAtFunc: method is nil but Cmdable.HExpireAt was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		Tm     time.Time
		Fields []string
	}{
		Ctx:    ctx,
		Key:    key,
		Tm:     tm,
		Fields: fields,
	}
	mock.lockHExpireAt.Lock()
	mock.calls.HExpireAt = append(mock.calls.HExpireAt, callInfo)
	mock.lockHExpireAt.Unlock()
	return mock.HExpireAtFunc(ctx, key, tm, fields...)
}

// HExpireAtCalls gets all the calls that were made to HExpireAt.
// Check the length with:
//
//	len(mockedCmdable.HExpireAtCalls())
func (mock *MoqCmdable) HExpireAtCalls() []struct {
	Ctx    context.Context
	Key    string
	Tm     time.Time
	Fields []string
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		Tm     time.Time
		Fields []string
	}
	mock.lockHExpireAt.RLock()
	calls = mock.calls.HExpireAt
	mock.lockHExpireAt.RUnlock()
	return calls
}

// ResetHExpireAtCalls reset all the calls that were made to HExpireAt.
func (mock *MoqCmdable) ResetHExpireAtCalls() {
	mock.lockHExpireAt.Lock()
	mock.calls.HExpireAt = nil
	mock.lockHExpireAt.Unlock()
}

// HExpireAtWithArgs calls HExpireAtWithArgsFunc.
func (mock *MoqCmdable) HExpireAtWithArgs(ctx context.Context, key string, tm time.Time, expirationArgs redis.HExpireArgs, fields ...string) *redis.IntSliceCmd {
	if mock.HExpireAtWithArgsFunc == nil {
		panic("MoqCmdable.HExpireAtWithArgsFunc: method is nil but Cmdable.HExpireAtWithArgs was just called")
	}
	callInfo := struct {
		Ctx            context.Context
		Key            string
		Tm             time.Time
		ExpirationArgs redis.HExpireArgs
		Fields         []string
	}{
		Ctx:            ctx,
		Key:            key,
		Tm:             tm,
		ExpirationArgs: expirationArgs,
		Fields:         fields,
	}
	mock.lockHExpireAtWithArgs.Lock()
	mock.calls.HExpireAtWithArgs = append(mock.calls.HExpireAtWithArgs, callInfo)
	mock.lockHExpireAtWithArgs.Unlock()
	return mock.HExpireAtWithArgsFunc(ctx, key, tm, expirationArgs, fields...)
}

// HExpireAtWithArgsCalls gets all the calls that were made to HExpireAtWithArgs.
// Check the length with:
//
//	len(mockedCmdable.HExpireAtWithArgsCalls())
func (mock *MoqCmdable) HExpireAtWithArgsCalls() []struct {
	Ctx            context.Context
	Key            string
	Tm             time.Time
	ExpirationArgs redis.HExpireArgs
	Fields         []string
} {
	var calls []struct {
		Ctx            context.Context
		Key            string
		Tm             time.Time
		ExpirationArgs redis.HExpireArgs
		Fields         []string
	}
	mock.lockHExpireAtWithArgs.RLock()
	calls = mock.calls.HExpireAtWithArgs
	mock.lockHExpireAtWithArgs.RUnlock()
	return calls
}

// ResetHExpireAtWithArgsCalls reset all the calls that were made to HExpireAtWithArgs.
func (mock *MoqCmdable) ResetHExpireAtWithArgsCalls() {
	mock.lockHExpireAtWithArgs.Lock()
	mock.calls.HExpireAtWithArgs = nil
	mock.lockHExpireAtWithArgs.Unlock()
}

// HExpireTime calls HExpireTimeFunc.
func (mock *MoqCmdable) HExpireTime(ctx context.Context, key string, fields ...string) *redis.IntSliceCmd {
	if mock.HExpireTimeFunc == nil {
		panic("MoqCmdable.HExpireTimeFunc: method is nil but Cmdable.HExpireTime was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		Fields []string
	}{
		Ctx:    ctx,
		Key:    key,
		Fields: fields,
	}
	mock.lockHExpireTime.Lock()
	mock.calls.HExpireTime = append(mock.calls.HExpireTime, callInfo)
	mock.lockHExpireTime.Unlock()
	return mock.HExpireTimeFunc(ctx, key, fields...)
}

// HExpireTimeCalls gets all the calls that were made to HExpireTime.
// Check the length with:
//
//	len(mockedCmdable.HExpireTimeCalls())
func (mock *MoqCmdable) HExpireTimeCalls() []struct {
	Ctx    context.Context
	Key    string
	Fields []string
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		Fields []string
	}
	mock.lockHExpireTime.RLock()
	calls = mock.calls.HExpireTime
	mock.lockHExpireTime.RUnlock()
	return calls
}

// ResetHExpireTimeCalls reset all the calls that were made to HExpireTime.
func (mock *MoqCmdable) ResetHExpireTimeCalls() {
	mock.lockHExpireTime.Lock()
	mock.calls.HExpireTime = nil
	mock.lockHExpireTime.Unlock()
}

// HExpireWithArgs calls HExpireWithArgsFunc.
func (mock *MoqCmdable) HExpireWithArgs(ctx context.Context, key string, expiration time.Duration, expirationArgs redis.HExpireArgs, fields ...string) *redis.IntSliceCmd {
	if mock.HExpireWithArgsFunc == nil {
		panic("MoqCmdable.HExpireWithArgsFunc: method is nil but Cmdable.HExpireWithArgs was just called")
	}
	callInfo := struct {
		Ctx            context.Context
		Key            string
		Expiration     time.Duration
		ExpirationArgs redis.HExpireArgs
		Fields         []string
	}{
		Ctx:            ctx,
		Key:            key,
		Expiration:     expiration,
		ExpirationArgs: expirationArgs,
		Fields:         fields,
	}
	mock.lockHExpireWithArgs.Lock()
	mock.calls.HExpireWithArgs = append(mock.calls.HExpireWithArgs, callInfo)
	mock.lockHExpireWithArgs.Unlock()
	return mock.HExpireWithArgsFunc(ctx, key, expiration, expirationArgs, fields...)
}

// HExpireWithArgsCalls gets all the calls that were made to HExpireWithArgs.
// Check the length with:
//
//	len(mockedCmdable.HExpireWithArgsCalls())
func (mock *MoqCmdable) HExpireWithArgsCalls() []struct {
	Ctx            context.Context
	Key            string
	Expiration     time.Duration
	ExpirationArgs redis.HExpireArgs
	Fields         []string
} {
	var calls []struct {
		Ctx            context.Context
		Key            string
		Expiration     time.Duration
		ExpirationArgs redis.HExpireArgs
		Fields         []string
	}
	mock.lockHExpireWithArgs.RLock()
	calls = mock.calls.HExpireWithArgs
	mock.lockHExpireWithArgs.RUnlock()
	return calls
}

// ResetHExpireWithArgsCalls reset all the calls that were made to HExpireWithArgs.
func (mock *MoqCmdable) ResetHExpireWithArgsCalls() {
	mock.lockHExpireWithArgs.Lock()
	mock.calls.HExpireWithArgs = nil
	mock.lockHExpireWithArgs.Unlock()
}

// HGet calls HGetFunc.
func (mock *MoqCmdable) HGet(ctx context.Context, key string, field string) *redis.StringCmd {
	if mock.HGetFunc == nil {
		panic("MoqCmdable.HGetFunc: method is nil but Cmdable.HGet was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Field string
	}{
		Ctx:   ctx,
		Key:   key,
		Field: field,
	}
	mock.lockHGet.Lock()
	mock.calls.HGet = append(mock.calls.HGet, callInfo)
	mock.lockHGet.Unlock()
	return mock.HGetFunc(ctx, key, field)
}

// HGetCalls gets all the calls that were made to HGet.
// Check the length with:
//
//	len(mockedCmdable.HGetCalls())
func (mock *MoqCmdable) HGetCalls() []struct {
	Ctx   context.Context
	Key   string
	Field string
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Field string
	}
	mock.lockHGet.RLock()
	calls = mock.calls.HGet
	mock.lockHGet.RUnlock()
	return calls
}

// ResetHGetCalls reset all the calls that were made to HGet.
func (mock *MoqCmdable) ResetHGetCalls() {
	mock.lockHGet.Lock()
	mock.calls.HGet = nil
	mock.lockHGet.Unlock()
}

// HGetAll calls HGetAllFunc.
func (mock *MoqCmdable) HGetAll(ctx context.Context, key string) *redis.MapStringStringCmd {
	if mock.HGetAllFunc == nil {
		panic("MoqCmdable.HGetAllFunc: method is nil but Cmdable.HGetAll was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockHGetAll.Lock()
	mock.calls.HGetAll = append(mock.calls.HGetAll, callInfo)
	mock.lockHGetAll.Unlock()
	return mock.HGetAllFunc(ctx, key)
}

// HGetAllCalls gets all the calls that were made to HGetAll.
// Check the length with:
//
//	len(mockedCmdable.HGetAllCalls())
func (mock *MoqCmdable) HGetAllCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockHGetAll.RLock()
	calls = mock.calls.HGetAll
	mock.lockHGetAll.RUnlock()
	return calls
}

// ResetHGetAllCalls reset all the calls that were made to HGetAll.
func (mock *MoqCmdable) ResetHGetAllCalls() {
	mock.lockHGetAll.Lock()
	mock.calls.HGetAll = nil
	mock.lockHGetAll.Unlock()
}

// HGetDel calls HGetDelFunc.
func (mock *MoqCmdable) HGetDel(ctx context.Context, key string, fields ...string) *redis.StringSliceCmd {
	if mock.HGetDelFunc == nil {
		panic("MoqCmdable.HGetDelFunc: method is nil but Cmdable.HGetDel was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		Fields []string
	}{
		Ctx:    ctx,
		Key:    key,
		Fields: fields,
	}
	mock.lockHGetDel.Lock()
	mock.calls.HGetDel = append(mock.calls.HGetDel, callInfo)
	mock.lockHGetDel.Unlock()
	return mock.HGetDelFunc(ctx, key, fields...)
}

// HGetDelCalls gets all the calls that were made to HGetDel.
// Check the length with:
//
//	len(mockedCmdable.HGetDelCalls())
func (mock *MoqCmdable) HGetDelCalls() []struct {
	Ctx    context.Context
	Key    string
	Fields []string
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		Fields []string
	}
	mock.lockHGetDel.RLock()
	calls = mock.calls.HGetDel
	mock.lockHGetDel.RUnlock()
	return calls
}

// ResetHGetDelCalls reset all the calls that were made to HGetDel.
func (mock *MoqCmdable) ResetHGetDelCalls() {
	mock.lockHGetDel.Lock()
	mock.calls.HGetDel = nil
	mock.lockHGetDel.Unlock()
}

// HGetEX calls HGetEXFunc.
func (mock *MoqCmdable) HGetEX(ctx context.Context, key string, fields ...string) *redis.StringSliceCmd {
	if mock.HGetEXFunc == nil {
		panic("MoqCmdable.HGetEXFunc: method is nil but Cmdable.HGetEX was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		Fields []string
	}{
		Ctx:    ctx,
		Key:    key,
		Fields: fields,
	}
	mock.lockHGetEX.Lock()
	mock.calls.HGetEX = append(mock.calls.HGetEX, callInfo)
	mock.lockHGetEX.Unlock()
	return mock.HGetEXFunc(ctx, key, fields...)
}

// HGetEXCalls gets all the calls that were made to HGetEX.
// Check the length with:
//
//	len(mockedCmdable.HGetEXCalls())
func (mock *MoqCmdable) HGetEXCalls() []struct {
	Ctx    context.Context
	Key    string
	Fields []string
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		Fields []string
	}
	mock.lockHGetEX.RLock()
	calls = mock.calls.HGetEX
	mock.lockHGetEX.RUnlock()
	return calls
}

// ResetHGetEXCalls reset all the calls that were made to HGetEX.
func (mock *MoqCmdable) ResetHGetEXCalls() {
	mock.lockHGetEX.Lock()
	mock.calls.HGetEX = nil
	mock.lockHGetEX.Unlock()
}

// HGetEXWithArgs calls HGetEXWithArgsFunc.
func (mock *MoqCmdable) HGetEXWithArgs(ctx context.Context, key string, options *redis.HGetEXOptions, fields ...string) *redis.StringSliceCmd {
	if mock.HGetEXWithArgsFunc == nil {
		panic("MoqCmdable.HGetEXWithArgsFunc: method is nil but Cmdable.HGetEXWithArgs was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Key     string
		Options *redis.HGetEXOptions
		Fields  []string
	}{
		Ctx:     ctx,
		Key:     key,
		Options: options,
		Fields:  fields,
	}
	mock.lockHGetEXWithArgs.Lock()
	mock.calls.HGetEXWithArgs = append(mock.calls.HGetEXWithArgs, callInfo)
	mock.lockHGetEXWithArgs.Unlock()
	return mock.HGetEXWithArgsFunc(ctx, key, options, fields...)
}

// HGetEXWithArgsCalls gets all the calls that were made to HGetEXWithArgs.
// Check the length with:
//
//	len(mockedCmdable.HGetEXWithArgsCalls())
func (mock *MoqCmdable) HGetEXWithArgsCalls() []struct {
	Ctx     context.Context
	Key     string
	Options *redis.HGetEXOptions
	Fields  []string
} {
	var calls []struct {
		Ctx     context.Context
		Key     string
		Options *redis.HGetEXOptions
		Fields  []string
	}
	mock.lockHGetEXWithArgs.RLock()
	calls = mock.calls.HGetEXWithArgs
	mock.lockHGetEXWithArgs.RUnlock()
	return calls
}

// ResetHGetEXWithArgsCalls reset all the calls that were made to HGetEXWithArgs.
func (mock *MoqCmdable) ResetHGetEXWithArgsCalls() {
	mock.lockHGetEXWithArgs.Lock()
	mock.calls.HGetEXWithArgs = nil
	mock.lockHGetEXWithArgs.Unlock()
}

// HIncrBy calls HIncrByFunc.
func (mock *MoqCmdable) HIncrBy(ctx context.Context, key string, field string, incr int64) *redis.IntCmd {
	if mock.HIncrByFunc == nil {
		panic("MoqCmdable.HIncrByFunc: method is nil but Cmdable.HIncrBy was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Field string
		Incr  int64
	}{
		Ctx:   ctx,
		Key:   key,
		Field: field,
		Incr:  incr,
	}
	mock.lockHIncrBy.Lock()
	mock.calls.HIncrBy = append(mock.calls.HIncrBy, callInfo)
	mock.lockHIncrBy.Unlock()
	return mock.HIncrByFunc(ctx, key, field, incr)
}

// HIncrByCalls gets all the calls that were made to HIncrBy.
// Check the length with:
//
//	len(mockedCmdable.HIncrByCalls())
func (mock *MoqCmdable) HIncrByCalls() []struct {
	Ctx   context.Context
	Key   string
	Field string
	Incr  int64
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Field string
		Incr  int64
	}
	mock.lockHIncrBy.RLock()
	calls = mock.calls.HIncrBy
	mock.lockHIncrBy.RUnlock()
	return calls
}

// ResetHIncrByCalls reset all the calls that were made to HIncrBy.
func (mock *MoqCmdable) ResetHIncrByCalls() {
	mock.lockHIncrBy.Lock()
	mock.calls.HIncrBy = nil
	mock.lockHIncrBy.Unlock()
}

// HIncrByFloat calls HIncrByFloatFunc.
func (mock *MoqCmdable) HIncrByFloat(ctx context.Context, key string, field string, incr float64) *redis.FloatCmd {
	if mock.HIncrByFloatFunc == nil {
		panic("MoqCmdable.HIncrByFloatFunc: method is nil but Cmdable.HIncrByFloat was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Field string
		Incr  float64
	}{
		Ctx:   ctx,
		Key:   key,
		Field: field,
		Incr:  incr,
	}
	mock.lockHIncrByFloat.Lock()
	mock.calls.HIncrByFloat = append(mock.calls.HIncrByFloat, callInfo)
	mock.lockHIncrByFloat.Unlock()
	return mock.HIncrByFloatFunc(ctx, key, field, incr)
}

// HIncrByFloatCalls gets all the calls that were made to HIncrByFloat.
// Check the length with:
//
//	len(mockedCmdable.HIncrByFloatCalls())
func (mock *MoqCmdable) HIncrByFloatCalls() []struct {
	Ctx   context.Context
	Key   string
	Field string
	Incr  float64
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Field string
		Incr  float64
	}
	mock.lockHIncrByFloat.RLock()
	calls = mock.calls.HIncrByFloat
	mock.lockHIncrByFloat.RUnlock()
	return calls
}

// ResetHIncrByFloatCalls reset all the calls that were made to HIncrByFloat.
func (mock *MoqCmdable) ResetHIncrByFloatCalls() {
	mock.lockHIncrByFloat.Lock()
	mock.calls.HIncrByFloat = nil
	mock.lockHIncrByFloat.Unlock()
}

// HKeys calls HKeysFunc.
func (mock *MoqCmdable) HKeys(ctx context.Context, key string) *redis.StringSliceCmd {
	if mock.HKeysFunc == nil {
		panic("MoqCmdable.HKeysFunc: method is nil but Cmdable.HKeys was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockHKeys.Lock()
	mock.calls.HKeys = append(mock.calls.HKeys, callInfo)
	mock.lockHKeys.Unlock()
	return mock.HKeysFunc(ctx, key)
}

// HKeysCalls gets all the calls that were made to HKeys.
// Check the length with:
//
//	len(mockedCmdable.HKeysCalls())
func (mock *MoqCmdable) HKeysCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockHKeys.RLock()
	calls = mock.calls.HKeys
	mock.lockHKeys.RUnlock()
	return calls
}

// ResetHKeysCalls reset all the calls that were made to HKeys.
func (mock *MoqCmdable) ResetHKeysCalls() {
	mock.lockHKeys.Lock()
	mock.calls.HKeys = nil
	mock.lockHKeys.Unlock()
}

// HLen calls HLenFunc.
func (mock *MoqCmdable) HLen(ctx context.Context, key string) *redis.IntCmd {
	if mock.HLenFunc == nil {
		panic("MoqCmdable.HLenFunc: method is nil but Cmdable.HLen was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockHLen.Lock()
	mock.calls.HLen = append(mock.calls.HLen, callInfo)
	mock.lockHLen.Unlock()
	return mock.HLenFunc(ctx, key)
}

// HLenCalls gets all the calls that were made to HLen.
// Check the length with:
//
//	len(mockedCmdable.HLenCalls())
func (mock *MoqCmdable) HLenCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockHLen.RLock()
	calls = mock.calls.HLen
	mock.lockHLen.RUnlock()
	return calls
}

// ResetHLenCalls reset all the calls that were made to HLen.
func (mock *MoqCmdable) ResetHLenCalls() {
	mock.lockHLen.Lock()
	mock.calls.HLen = nil
	mock.lockHLen.Unlock()
}

// HMGet calls HMGetFunc.
func (mock *MoqCmdable) HMGet(ctx context.Context, key string, fields ...string) *redis.SliceCmd {
	if mock.HMGetFunc == nil {
		panic("MoqCmdable.HMGetFunc: method is nil but Cmdable.HMGet was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		Fields []string
	}{
		Ctx:    ctx,
		Key:    key,
		Fields: fields,
	}
	mock.lockHMGet.Lock()
	mock.calls.HMGet = append(mock.calls.HMGet, callInfo)
	mock.lockHMGet.Unlock()
	return mock.HMGetFunc(ctx, key, fields...)
}

// HMGetCalls gets all the calls that were made to HMGet.
// Check the length with:
//
//	len(mockedCmdable.HMGetCalls())
func (mock *MoqCmdable) HMGetCalls() []struct {
	Ctx    context.Context
	Key    string
	Fields []string
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		Fields []string
	}
	mock.lockHMGet.RLock()
	calls = mock.calls.HMGet
	mock.lockHMGet.RUnlock()
	return calls
}

// ResetHMGetCalls reset all the calls that were made to HMGet.
func (mock *MoqCmdable) ResetHMGetCalls() {
	mock.lockHMGet.Lock()
	mock.calls.HMGet = nil
	mock.lockHMGet.Unlock()
}

// HMSet calls HMSetFunc.
func (mock *MoqCmdable) HMSet(ctx context.Context, key string, values ...interface{}) *redis.BoolCmd {
	if mock.HMSetFunc == nil {
		panic("MoqCmdable.HMSetFunc: method is nil but Cmdable.HMSet was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		Values []interface{}
	}{
		Ctx:    ctx,
		Key:    key,
		Values: values,
	}
	mock.lockHMSet.Lock()
	mock.calls.HMSet = append(mock.calls.HMSet, callInfo)
	mock.lockHMSet.Unlock()
	return mock.HMSetFunc(ctx, key, values...)
}

// HMSetCalls gets all the calls that were made to HMSet.
// Check the length with:
//
//	len(mockedCmdable.HMSetCalls())
func (mock *MoqCmdable) HMSetCalls() []struct {
	Ctx    context.Context
	Key    string
	Values []interface{}
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		Values []interface{}
	}
	mock.lockHMSet.RLock()
	calls = mock.calls.HMSet
	mock.lockHMSet.RUnlock()
	return calls
}

// ResetHMSetCalls reset all the calls that were made to HMSet.
func (mock *MoqCmdable) ResetHMSetCalls() {
	mock.lockHMSet.Lock()
	mock.calls.HMSet = nil
	mock.lockHMSet.Unlock()
}

// HPExpire calls HPExpireFunc.
func (mock *MoqCmdable) HPExpire(ctx context.Context, key string, expiration time.Duration, fields ...string) *redis.IntSliceCmd {
	if mock.HPExpireFunc == nil {
		panic("MoqCmdable.HPExpireFunc: method is nil but Cmdable.HPExpire was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Key        string
		Expiration time.Duration
		Fields     []string
	}{
		Ctx:        ctx,
		Key:        key,
		Expiration: expiration,
		Fields:     fields,
	}
	mock.lockHPExpire.Lock()
	mock.calls.HPExpire = append(mock.calls.HPExpire, callInfo)
	mock.lockHPExpire.Unlock()
	return mock.HPExpireFunc(ctx, key, expiration, fields...)
}

// HPExpireCalls gets all the calls that were made to HPExpire.
// Check the length with:
//
//	len(mockedCmdable.HPExpireCalls())
func (mock *MoqCmdable) HPExpireCalls() []struct {
	Ctx        context.Context
	Key        string
	Expiration time.Duration
	Fields     []string
} {
	var calls []struct {
		Ctx        context.Context
		Key        string
		Expiration time.Duration
		Fields     []string
	}
	mock.lockHPExpire.RLock()
	calls = mock.calls.HPExpire
	mock.lockHPExpire.RUnlock()
	return calls
}

// ResetHPExpireCalls reset all the calls that were made to HPExpire.
func (mock *MoqCmdable) ResetHPExpireCalls() {
	mock.lockHPExpire.Lock()
	mock.calls.HPExpire = nil
	mock.lockHPExpire.Unlock()
}

// HPExpireAt calls HPExpireAtFunc.
func (mock *MoqCmdable) HPExpireAt(ctx context.Context, key string, tm time.Time, fields ...string) *redis.IntSliceCmd {
	if mock.HPExpireAtFunc == nil {
		panic("MoqCmdable.HPExpireAtFunc: method is nil but Cmdable.HPExpireAt was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		Tm     time.Time
		Fields []string
	}{
		Ctx:    ctx,
		Key:    key,
		Tm:     tm,
		Fields: fields,
	}
	mock.lockHPExpireAt.Lock()
	mock.calls.HPExpireAt = append(mock.calls.HPExpireAt, callInfo)
	mock.lockHPExpireAt.Unlock()
	return mock.HPExpireAtFunc(ctx, key, tm, fields...)
}

// HPExpireAtCalls gets all the calls that were made to HPExpireAt.
// Check the length with:
//
//	len(mockedCmdable.HPExpireAtCalls())
func (mock *MoqCmdable) HPExpireAtCalls() []struct {
	Ctx    context.Context
	Key    string
	Tm     time.Time
	Fields []string
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		Tm     time.Time
		Fields []string
	}
	mock.lockHPExpireAt.RLock()
	calls = mock.calls.HPExpireAt
	mock.lockHPExpireAt.RUnlock()
	return calls
}

// ResetHPExpireAtCalls reset all the calls that were made to HPExpireAt.
func (mock *MoqCmdable) ResetHPExpireAtCalls() {
	mock.lockHPExpireAt.Lock()
	mock.calls.HPExpireAt = nil
	mock.lockHPExpireAt.Unlock()
}

// HPExpireAtWithArgs calls HPExpireAtWithArgsFunc.
func (mock *MoqCmdable) HPExpireAtWithArgs(ctx context.Context, key string, tm time.Time, expirationArgs redis.HExpireArgs, fields ...string) *redis.IntSliceCmd {
	if mock.HPExpireAtWithArgsFunc == nil {
		panic("MoqCmdable.HPExpireAtWithArgsFunc: method is nil but Cmdable.HPExpireAtWithArgs was just called")
	}
	callInfo := struct {
		Ctx            context.Context
		Key            string
		Tm             time.Time
		ExpirationArgs redis.HExpireArgs
		Fields         []string
	}{
		Ctx:            ctx,
		Key:            key,
		Tm:             tm,
		ExpirationArgs: expirationArgs,
		Fields:         fields,
	}
	mock.lockHPExpireAtWithArgs.Lock()
	mock.calls.HPExpireAtWithArgs = append(mock.calls.HPExpireAtWithArgs, callInfo)
	mock.lockHPExpireAtWithArgs.Unlock()
	return mock.HPExpireAtWithArgsFunc(ctx, key, tm, expirationArgs, fields...)
}

// HPExpireAtWithArgsCalls gets all the calls that were made to HPExpireAtWithArgs.
// Check the length with:
//
//	len(mockedCmdable.HPExpireAtWithArgsCalls())
func (mock *MoqCmdable) HPExpireAtWithArgsCalls() []struct {
	Ctx            context.Context
	Key            string
	Tm             time.Time
	ExpirationArgs redis.HExpireArgs
	Fields         []string
} {
	var calls []struct {
		Ctx            context.Context
		Key            string
		Tm             time.Time
		ExpirationArgs redis.HExpireArgs
		Fields         []string
	}
	mock.lockHPExpireAtWithArgs.RLock()
	calls = mock.calls.HPExpireAtWithArgs
	mock.lockHPExpireAtWithArgs.RUnlock()
	return calls
}

// ResetHPExpireAtWithArgsCalls reset all the calls that were made to HPExpireAtWithArgs.
func (mock *MoqCmdable) ResetHPExpireAtWithArgsCalls() {
	mock.lockHPExpireAtWithArgs.Lock()
	mock.calls.HPExpireAtWithArgs = nil
	mock.lockHPExpireAtWithArgs.Unlock()
}

// HPExpireTime calls HPExpireTimeFunc.
func (mock *MoqCmdable) HPExpireTime(ctx context.Context, key string, fields ...string) *redis.IntSliceCmd {
	if mock.HPExpireTimeFunc == nil {
		panic("MoqCmdable.HPExpireTimeFunc: method is nil but Cmdable.HPExpireTime was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		Fields []string
	}{
		Ctx:    ctx,
		Key:    key,
		Fields: fields,
	}
	mock.lockHPExpireTime.Lock()
	mock.calls.HPExpireTime = append(mock.calls.HPExpireTime, callInfo)
	mock.lockHPExpireTime.Unlock()
	return mock.HPExpireTimeFunc(ctx, key, fields...)
}

// HPExpireTimeCalls gets all the calls that were made to HPExpireTime.
// Check the length with:
//
//	len(mockedCmdable.HPExpireTimeCalls())
func (mock *MoqCmdable) HPExpireTimeCalls() []struct {
	Ctx    context.Context
	Key    string
	Fields []string
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		Fields []string
	}
	mock.lockHPExpireTime.RLock()
	calls = mock.calls.HPExpireTime
	mock.lockHPExpireTime.RUnlock()
	return calls
}

// ResetHPExpireTimeCalls reset all the calls that were made to HPExpireTime.
func (mock *MoqCmdable) ResetHPExpireTimeCalls() {
	mock.lockHPExpireTime.Lock()
	mock.calls.HPExpireTime = nil
	mock.lockHPExpireTime.Unlock()
}

// HPExpireWithArgs calls HPExpireWithArgsFunc.
func (mock *MoqCmdable) HPExpireWithArgs(ctx context.Context, key string, expiration time.Duration, expirationArgs redis.HExpireArgs, fields ...string) *redis.IntSliceCmd {
	if mock.HPExpireWithArgsFunc == nil {
		panic("MoqCmdable.HPExpireWithArgsFunc: method is nil but Cmdable.HPExpireWithArgs was just called")
	}
	callInfo := struct {
		Ctx            context.Context
		Key            string
		Expiration     time.Duration
		ExpirationArgs redis.HExpireArgs
		Fields         []string
	}{
		Ctx:            ctx,
		Key:            key,
		Expiration:     expiration,
		ExpirationArgs: expirationArgs,
		Fields:         fields,
	}
	mock.lockHPExpireWithArgs.Lock()
	mock.calls.HPExpireWithArgs = append(mock.calls.HPExpireWithArgs, callInfo)
	mock.lockHPExpireWithArgs.Unlock()
	return mock.HPExpireWithArgsFunc(ctx, key, expiration, expirationArgs, fields...)
}

// HPExpireWithArgsCalls gets all the calls that were made to HPExpireWithArgs.
// Check the length with:
//
//	len(mockedCmdable.HPExpireWithArgsCalls())
func (mock *MoqCmdable) HPExpireWithArgsCalls() []struct {
	Ctx            context.Context
	Key            string
	Expiration     time.Duration
	ExpirationArgs redis.HExpireArgs
	Fields         []string
} {
	var calls []struct {
		Ctx            context.Context
		Key            string
		Expiration     time.Duration
		ExpirationArgs redis.HExpireArgs
		Fields         []string
	}
	mock.lockHPExpireWithArgs.RLock()
	calls = mock.calls.HPExpireWithArgs
	mock.lockHPExpireWithArgs.RUnlock()
	return calls
}

// ResetHPExpireWithArgsCalls reset all the calls that were made to HPExpireWithArgs.
func (mock *MoqCmdable) ResetHPExpireWithArgsCalls() {
	mock.lockHPExpireWithArgs.Lock()
	mock.calls.HPExpireWithArgs = nil
	mock.lockHPExpireWithArgs.Unlock()
}

// HPTTL calls HPTTLFunc.
func (mock *MoqCmdable) HPTTL(ctx context.Context, key string, fields ...string) *redis.IntSliceCmd {
	if mock.HPTTLFunc == nil {
		panic("MoqCmdable.HPTTLFunc: method is nil but Cmdable.HPTTL was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		Fields []string
	}{
		Ctx:    ctx,
		Key:    key,
		Fields: fields,
	}
	mock.lockHPTTL.Lock()
	mock.calls.HPTTL = append(mock.calls.HPTTL, callInfo)
	mock.lockHPTTL.Unlock()
	return mock.HPTTLFunc(ctx, key, fields...)
}

// HPTTLCalls gets all the calls that were made to HPTTL.
// Check the length with:
//
//	len(mockedCmdable.HPTTLCalls())
func (mock *MoqCmdable) HPTTLCalls() []struct {
	Ctx    context.Context
	Key    string
	Fields []string
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		Fields []string
	}
	mock.lockHPTTL.RLock()
	calls = mock.calls.HPTTL
	mock.lockHPTTL.RUnlock()
	return calls
}

// ResetHPTTLCalls reset all the calls that were made to HPTTL.
func (mock *MoqCmdable) ResetHPTTLCalls() {
	mock.lockHPTTL.Lock()
	mock.calls.HPTTL = nil
	mock.lockHPTTL.Unlock()
}

// HPersist calls HPersistFunc.
func (mock *MoqCmdable) HPersist(ctx context.Context, key string, fields ...string) *redis.IntSliceCmd {
	if mock.HPersistFunc == nil {
		panic("MoqCmdable.HPersistFunc: method is nil but Cmdable.HPersist was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		Fields []string
	}{
		Ctx:    ctx,
		Key:    key,
		Fields: fields,
	}
	mock.lockHPersist.Lock()
	mock.calls.HPersist = append(mock.calls.HPersist, callInfo)
	mock.lockHPersist.Unlock()
	return mock.HPersistFunc(ctx, key, fields...)
}

// HPersistCalls gets all the calls that were made to HPersist.
// Check the length with:
//
//	len(mockedCmdable.HPersistCalls())
func (mock *MoqCmdable) HPersistCalls() []struct {
	Ctx    context.Context
	Key    string
	Fields []string
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		Fields []string
	}
	mock.lockHPersist.RLock()
	calls = mock.calls.HPersist
	mock.lockHPersist.RUnlock()
	return calls
}

// ResetHPersistCalls reset all the calls that were made to HPersist.
func (mock *MoqCmdable) ResetHPersistCalls() {
	mock.lockHPersist.Lock()
	mock.calls.HPersist = nil
	mock.lockHPersist.Unlock()
}

// HRandField calls HRandFieldFunc.
func (mock *MoqCmdable) HRandField(ctx context.Context, key string, count int) *redis.StringSliceCmd {
	if mock.HRandFieldFunc == nil {
		panic("MoqCmdable.HRandFieldFunc: method is nil but Cmdable.HRandField was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Count int
	}{
		Ctx:   ctx,
		Key:   key,
		Count: count,
	}
	mock.lockHRandField.Lock()
	mock.calls.HRandField = append(mock.calls.HRandField, callInfo)
	mock.lockHRandField.Unlock()
	return mock.HRandFieldFunc(ctx, key, count)
}

// HRandFieldCalls gets all the calls that were made to HRandField.
// Check the length with:
//
//	len(mockedCmdable.HRandFieldCalls())
func (mock *MoqCmdable) HRandFieldCalls() []struct {
	Ctx   context.Context
	Key   string
	Count int
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Count int
	}
	mock.lockHRandField.RLock()
	calls = mock.calls.HRandField
	mock.lockHRandField.RUnlock()
	return calls
}

// ResetHRandFieldCalls reset all the calls that were made to HRandField.
func (mock *MoqCmdable) ResetHRandFieldCalls() {
	mock.lockHRandField.Lock()
	mock.calls.HRandField = nil
	mock.lockHRandField.Unlock()
}

// HRandFieldWithValues calls HRandFieldWithValuesFunc.
func (mock *MoqCmdable) HRandFieldWithValues(ctx context.Context, key string, count int) *redis.KeyValueSliceCmd {
	if mock.HRandFieldWithValuesFunc == nil {
		panic("MoqCmdable.HRandFieldWithValuesFunc: method is nil but Cmdable.HRandFieldWithValues was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Count int
	}{
		Ctx:   ctx,
		Key:   key,
		Count: count,
	}
	mock.lockHRandFieldWithValues.Lock()
	mock.calls.HRandFieldWithValues = append(mock.calls.HRandFieldWithValues, callInfo)
	mock.lockHRandFieldWithValues.Unlock()
	return mock.HRandFieldWithValuesFunc(ctx, key, count)
}

// HRandFieldWithValuesCalls gets all the calls that were made to HRandFieldWithValues.
// Check the length with:
//
//	len(mockedCmdable.HRandFieldWithValuesCalls())
func (mock *MoqCmdable) HRandFieldWithValuesCalls() []struct {
	Ctx   context.Context
	Key   string
	Count int
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Count int
	}
	mock.lockHRandFieldWithValues.RLock()
	calls = mock.calls.HRandFieldWithValues
	mock.lockHRandFieldWithValues.RUnlock()
	return calls
}

// ResetHRandFieldWithValuesCalls reset all the calls that were made to HRandFieldWithValues.
func (mock *MoqCmdable) ResetHRandFieldWithValuesCalls() {
	mock.lockHRandFieldWithValues.Lock()
	mock.calls.HRandFieldWithValues = nil
	mock.lockHRandFieldWithValues.Unlock()
}

// HScan calls HScanFunc.
func (mock *MoqCmdable) HScan(ctx context.Context, key string, cursor uint64, match string, count int64) *redis.ScanCmd {
	if mock.HScanFunc == nil {
		panic("MoqCmdable.HScanFunc: method is nil but Cmdable.HScan was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		Cursor uint64
		Match  string
		Count  int64
	}{
		Ctx:    ctx,
		Key:    key,
		Cursor: cursor,
		Match:  match,
		Count:  count,
	}
	mock.lockHScan.Lock()
	mock.calls.HScan = append(mock.calls.HScan, callInfo)
	mock.lockHScan.Unlock()
	return mock.HScanFunc(ctx, key, cursor, match, count)
}

// HScanCalls gets all the calls that were made to HScan.
// Check the length with:
//
//	len(mockedCmdable.HScanCalls())
func (mock *MoqCmdable) HScanCalls() []struct {
	Ctx    context.Context
	Key    string
	Cursor uint64
	Match  string
	Count  int64
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		Cursor uint64
		Match  string
		Count  int64
	}
	mock.lockHScan.RLock()
	calls = mock.calls.HScan
	mock.lockHScan.RUnlock()
	return calls
}

// ResetHScanCalls reset all the calls that were made to HScan.
func (mock *MoqCmdable) ResetHScanCalls() {
	mock.lockHScan.Lock()
	mock.calls.HScan = nil
	mock.lockHScan.Unlock()
}

// HScanNoValues calls HScanNoValuesFunc.
func (mock *MoqCmdable) HScanNoValues(ctx context.Context, key string, cursor uint64, match string, count int64) *redis.ScanCmd {
	if mock.HScanNoValuesFunc == nil {
		panic("MoqCmdable.HScanNoValuesFunc: method is nil but Cmdable.HScanNoValues was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		Cursor uint64
		Match  string
		Count  int64
	}{
		Ctx:    ctx,
		Key:    key,
		Cursor: cursor,
		Match:  match,
		Count:  count,
	}
	mock.lockHScanNoValues.Lock()
	mock.calls.HScanNoValues = append(mock.calls.HScanNoValues, callInfo)
	mock.lockHScanNoValues.Unlock()
	return mock.HScanNoValuesFunc(ctx, key, cursor, match, count)
}

// HScanNoValuesCalls gets all the calls that were made to HScanNoValues.
// Check the length with:
//
//	len(mockedCmdable.HScanNoValuesCalls())
func (mock *MoqCmdable) HScanNoValuesCalls() []struct {
	Ctx    context.Context
	Key    string
	Cursor uint64
	Match  string
	Count  int64
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		Cursor uint64
		Match  string
		Count  int64
	}
	mock.lockHScanNoValues.RLock()
	calls = mock.calls.HScanNoValues
	mock.lockHScanNoValues.RUnlock()
	return calls
}

// ResetHScanNoValuesCalls reset all the calls that were made to HScanNoValues.
func (mock *MoqCmdable) ResetHScanNoValuesCalls() {
	mock.lockHScanNoValues.Lock()
	mock.calls.HScanNoValues = nil
	mock.lockHScanNoValues.Unlock()
}

// HSet calls HSetFunc.
func (mock *MoqCmdable) HSet(ctx context.Context, key string, values ...interface{}) *redis.IntCmd {
	if mock.HSetFunc == nil {
		panic("MoqCmdable.HSetFunc: method is nil but Cmdable.HSet was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		Values []interface{}
	}{
		Ctx:    ctx,
		Key:    key,
		Values: values,
	}
	mock.lockHSet.Lock()
	mock.calls.HSet = append(mock.calls.HSet, callInfo)
	mock.lockHSet.Unlock()
	return mock.HSetFunc(ctx, key, values...)
}

// HSetCalls gets all the calls that were made to HSet.
// Check the length with:
//
//	len(mockedCmdable.HSetCalls())
func (mock *MoqCmdable) HSetCalls() []struct {
	Ctx    context.Context
	Key    string
	Values []interface{}
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		Values []interface{}
	}
	mock.lockHSet.RLock()
	calls = mock.calls.HSet
	mock.lockHSet.RUnlock()
	return calls
}

// ResetHSetCalls reset all the calls that were made to HSet.
func (mock *MoqCmdable) ResetHSetCalls() {
	mock.lockHSet.Lock()
	mock.calls.HSet = nil
	mock.lockHSet.Unlock()
}

// HSetEX calls HSetEXFunc.
func (mock *MoqCmdable) HSetEX(ctx context.Context, key string, fieldsAndValues ...string) *redis.IntCmd {
	if mock.HSetEXFunc == nil {
		panic("MoqCmdable.HSetEXFunc: method is nil but Cmdable.HSetEX was just called")
	}
	callInfo := struct {
		Ctx             context.Context
		Key             string
		FieldsAndValues []string
	}{
		Ctx:             ctx,
		Key:             key,
		FieldsAndValues: fieldsAndValues,
	}
	mock.lockHSetEX.Lock()
	mock.calls.HSetEX = append(mock.calls.HSetEX, callInfo)
	mock.lockHSetEX.Unlock()
	return mock.HSetEXFunc(ctx, key, fieldsAndValues...)
}

// HSetEXCalls gets all the calls that were made to HSetEX.
// Check the length with:
//
//	len(mockedCmdable.HSetEXCalls())
func (mock *MoqCmdable) HSetEXCalls() []struct {
	Ctx             context.Context
	Key             string
	FieldsAndValues []string
} {
	var calls []struct {
		Ctx             context.Context
		Key             string
		FieldsAndValues []string
	}
	mock.lockHSetEX.RLock()
	calls = mock.calls.HSetEX
	mock.lockHSetEX.RUnlock()
	return calls
}

// ResetHSetEXCalls reset all the calls that were made to HSetEX.
func (mock *MoqCmdable) ResetHSetEXCalls() {
	mock.lockHSetEX.Lock()
	mock.calls.HSetEX = nil
	mock.lockHSetEX.Unlock()
}

// HSetEXWithArgs calls HSetEXWithArgsFunc.
func (mock *MoqCmdable) HSetEXWithArgs(ctx context.Context, key string, options *redis.HSetEXOptions, fieldsAndValues ...string) *redis.IntCmd {
	if mock.HSetEXWithArgsFunc == nil {
		panic("MoqCmdable.HSetEXWithArgsFunc: method is nil but Cmdable.HSetEXWithArgs was just called")
	}
	callInfo := struct {
		Ctx             context.Context
		Key             string
		Options         *redis.HSetEXOptions
		FieldsAndValues []string
	}{
		Ctx:             ctx,
		Key:             key,
		Options:         options,
		FieldsAndValues: fieldsAndValues,
	}
	mock.lockHSetEXWithArgs.Lock()
	mock.calls.HSetEXWithArgs = append(mock.calls.HSetEXWithArgs, callInfo)
	mock.lockHSetEXWithArgs.Unlock()
	return mock.HSetEXWithArgsFunc(ctx, key, options, fieldsAndValues...)
}

// HSetEXWithArgsCalls gets all the calls that were made to HSetEXWithArgs.
// Check the length with:
//
//	len(mockedCmdable.HSetEXWithArgsCalls())
func (mock *MoqCmdable) HSetEXWithArgsCalls() []struct {
	Ctx             context.Context
	Key             string
	Options         *redis.HSetEXOptions
	FieldsAndValues []string
} {
	var calls []struct {
		Ctx             context.Context
		Key             string
		Options         *redis.HSetEXOptions
		FieldsAndValues []string
	}
	mock.lockHSetEXWithArgs.RLock()
	calls = mock.calls.HSetEXWithArgs
	mock.lockHSetEXWithArgs.RUnlock()
	return calls
}

// ResetHSetEXWithArgsCalls reset all the calls that were made to HSetEXWithArgs.
func (mock *MoqCmdable) ResetHSetEXWithArgsCalls() {
	mock.lockHSetEXWithArgs.Lock()
	mock.calls.HSetEXWithArgs = nil
	mock.lockHSetEXWithArgs.Unlock()
}

// HSetNX calls HSetNXFunc.
func (mock *MoqCmdable) HSetNX(ctx context.Context, key string, field string, value interface{}) *redis.BoolCmd {
	if mock.HSetNXFunc == nil {
		panic("MoqCmdable.HSetNXFunc: method is nil but Cmdable.HSetNX was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Field string
		Value interface{}
	}{
		Ctx:   ctx,
		Key:   key,
		Field: field,
		Value: value,
	}
	mock.lockHSetNX.Lock()
	mock.calls.HSetNX = append(mock.calls.HSetNX, callInfo)
	mock.lockHSetNX.Unlock()
	return mock.HSetNXFunc(ctx, key, field, value)
}

// HSetNXCalls gets all the calls that were made to HSetNX.
// Check the length with:
//
//	len(mockedCmdable.HSetNXCalls())
func (mock *MoqCmdable) HSetNXCalls() []struct {
	Ctx   context.Context
	Key   string
	Field string
	Value interface{}
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Field string
		Value interface{}
	}
	mock.lockHSetNX.RLock()
	calls = mock.calls.HSetNX
	mock.lockHSetNX.RUnlock()
	return calls
}

// ResetHSetNXCalls reset all the calls that were made to HSetNX.
func (mock *MoqCmdable) ResetHSetNXCalls() {
	mock.lockHSetNX.Lock()
	mock.calls.HSetNX = nil
	mock.lockHSetNX.Unlock()
}

// HStrLen calls HStrLenFunc.
func (mock *MoqCmdable) HStrLen(ctx context.Context, key string, field string) *redis.IntCmd {
	if mock.HStrLenFunc == nil {
		panic("MoqCmdable.HStrLenFunc: method is nil but Cmdable.HStrLen was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Field string
	}{
		Ctx:   ctx,
		Key:   key,
		Field: field,
	}
	mock.lockHStrLen.Lock()
	mock.calls.HStrLen = append(mock.calls.HStrLen, callInfo)
	mock.lockHStrLen.Unlock()
	return mock.HStrLenFunc(ctx, key, field)
}

// HStrLenCalls gets all the calls that were made to HStrLen.
// Check the length with:
//
//	len(mockedCmdable.HStrLenCalls())
func (mock *MoqCmdable) HStrLenCalls() []struct {
	Ctx   context.Context
	Key   string
	Field string
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Field string
	}
	mock.lockHStrLen.RLock()
	calls = mock.calls.HStrLen
	mock.lockHStrLen.RUnlock()
	return calls
}

// ResetHStrLenCalls reset all the calls that were made to HStrLen.
func (mock *MoqCmdable) ResetHStrLenCalls() {
	mock.lockHStrLen.Lock()
	mock.calls.HStrLen = nil
	mock.lockHStrLen.Unlock()
}

// HTTL calls HTTLFunc.
func (mock *MoqCmdable) HTTL(ctx context.Context, key string, fields ...string) *redis.IntSliceCmd {
	if mock.HTTLFunc == nil {
		panic("MoqCmdable.HTTLFunc: method is nil but Cmdable.HTTL was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		Fields []string
	}{
		Ctx:    ctx,
		Key:    key,
		Fields: fields,
	}
	mock.lockHTTL.Lock()
	mock.calls.HTTL = append(mock.calls.HTTL, callInfo)
	mock.lockHTTL.Unlock()
	return mock.HTTLFunc(ctx, key, fields...)
}

// HTTLCalls gets all the calls that were made to HTTL.
// Check the length with:
//
//	len(mockedCmdable.HTTLCalls())
func (mock *MoqCmdable) HTTLCalls() []struct {
	Ctx    context.Context
	Key    string
	Fields []string
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		Fields []string
	}
	mock.lockHTTL.RLock()
	calls = mock.calls.HTTL
	mock.lockHTTL.RUnlock()
	return calls
}

// ResetHTTLCalls reset all the calls that were made to HTTL.
func (mock *MoqCmdable) ResetHTTLCalls() {
	mock.lockHTTL.Lock()
	mock.calls.HTTL = nil
	mock.lockHTTL.Unlock()
}

// HVals calls HValsFunc.
func (mock *MoqCmdable) HVals(ctx context.Context, key string) *redis.StringSliceCmd {
	if mock.HValsFunc == nil {
		panic("MoqCmdable.HValsFunc: method is nil but Cmdable.HVals was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockHVals.Lock()
	mock.calls.HVals = append(mock.calls.HVals, callInfo)
	mock.lockHVals.Unlock()
	return mock.HValsFunc(ctx, key)
}

// HValsCalls gets all the calls that were made to HVals.
// Check the length with:
//
//	len(mockedCmdable.HValsCalls())
func (mock *MoqCmdable) HValsCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockHVals.RLock()
	calls = mock.calls.HVals
	mock.lockHVals.RUnlock()
	return calls
}

// ResetHValsCalls reset all the calls that were made to HVals.
func (mock *MoqCmdable) ResetHValsCalls() {
	mock.lockHVals.Lock()
	mock.calls.HVals = nil
	mock.lockHVals.Unlock()
}

// Incr calls IncrFunc.
func (mock *MoqCmdable) Incr(ctx context.Context, key string) *redis.IntCmd {
	if mock.IncrFunc == nil {
		panic("MoqCmdable.IncrFunc: method is nil but Cmdable.Incr was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockIncr.Lock()
	mock.calls.Incr = append(mock.calls.Incr, callInfo)
	mock.lockIncr.Unlock()
	return mock.IncrFunc(ctx, key)
}

// IncrCalls gets all the calls that were made to Incr.
// Check the length with:
//
//	len(mockedCmdable.IncrCalls())
func (mock *MoqCmdable) IncrCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockIncr.RLock()
	calls = mock.calls.Incr
	mock.lockIncr.RUnlock()
	return calls
}

// ResetIncrCalls reset all the calls that were made to Incr.
func (mock *MoqCmdable) ResetIncrCalls() {
	mock.lockIncr.Lock()
	mock.calls.Incr = nil
	mock.lockIncr.Unlock()
}

// IncrBy calls IncrByFunc.
func (mock *MoqCmdable) IncrBy(ctx context.Context, key string, value int64) *redis.IntCmd {
	if mock.IncrByFunc == nil {
		panic("MoqCmdable.IncrByFunc: method is nil but Cmdable.IncrBy was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Value int64
	}{
		Ctx:   ctx,
		Key:   key,
		Value: value,
	}
	mock.lockIncrBy.Lock()
	mock.calls.IncrBy = append(mock.calls.IncrBy, callInfo)
	mock.lockIncrBy.Unlock()
	return mock.IncrByFunc(ctx, key, value)
}

// IncrByCalls gets all the calls that were made to IncrBy.
// Check the length with:
//
//	len(mockedCmdable.IncrByCalls())
func (mock *MoqCmdable) IncrByCalls() []struct {
	Ctx   context.Context
	Key   string
	Value int64
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Value int64
	}
	mock.lockIncrBy.RLock()
	calls = mock.calls.IncrBy
	mock.lockIncrBy.RUnlock()
	return calls
}

// ResetIncrByCalls reset all the calls that were made to IncrBy.
func (mock *MoqCmdable) ResetIncrByCalls() {
	mock.lockIncrBy.Lock()
	mock.calls.IncrBy = nil
	mock.lockIncrBy.Unlock()
}

// IncrByFloat calls IncrByFloatFunc.
func (mock *MoqCmdable) IncrByFloat(ctx context.Context, key string, value float64) *redis.FloatCmd {
	if mock.IncrByFloatFunc == nil {
		panic("MoqCmdable.IncrByFloatFunc: method is nil but Cmdable.IncrByFloat was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Value float64
	}{
		Ctx:   ctx,
		Key:   key,
		Value: value,
	}
	mock.lockIncrByFloat.Lock()
	mock.calls.IncrByFloat = append(mock.calls.IncrByFloat, callInfo)
	mock.lockIncrByFloat.Unlock()
	return mock.IncrByFloatFunc(ctx, key, value)
}

// IncrByFloatCalls gets all the calls that were made to IncrByFloat.
// Check the length with:
//
//	len(mockedCmdable.IncrByFloatCalls())
func (mock *MoqCmdable) IncrByFloatCalls() []struct {
	Ctx   context.Context
	Key   string
	Value float64
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Value float64
	}
	mock.lockIncrByFloat.RLock()
	calls = mock.calls.IncrByFloat
	mock.lockIncrByFloat.RUnlock()
	return calls
}

// ResetIncrByFloatCalls reset all the calls that were made to IncrByFloat.
func (mock *MoqCmdable) ResetIncrByFloatCalls() {
	mock.lockIncrByFloat.Lock()
	mock.calls.IncrByFloat = nil
	mock.lockIncrByFloat.Unlock()
}

// Info calls InfoFunc.
func (mock *MoqCmdable) Info(ctx context.Context, section ...string) *redis.StringCmd {
	if mock.InfoFunc == nil {
		panic("MoqCmdable.InfoFunc: method is nil but Cmdable.Info was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Section []string
	}{
		Ctx:     ctx,
		Section: section,
	}
	mock.lockInfo.Lock()
	mock.calls.Info = append(mock.calls.Info, callInfo)
	mock.lockInfo.Unlock()
	return mock.InfoFunc(ctx, section...)
}

// InfoCalls gets all the calls that were made to Info.
// Check the length with:
//
//	len(mockedCmdable.InfoCalls())
func (mock *MoqCmdable) InfoCalls() []struct {
	Ctx     context.Context
	Section []string
} {
	var calls []struct {
		Ctx     context.Context
		Section []string
	}
	mock.lockInfo.RLock()
	calls = mock.calls.Info
	mock.lockInfo.RUnlock()
	return calls
}

// ResetInfoCalls reset all the calls that were made to Info.
func (mock *MoqCmdable) ResetInfoCalls() {
	mock.lockInfo.Lock()
	mock.calls.Info = nil
	mock.lockInfo.Unlock()
}

// JSONArrAppend calls JSONArrAppendFunc.
func (mock *MoqCmdable) JSONArrAppend(ctx context.Context, key string, path string, values ...interface{}) *redis.IntSliceCmd {
	if mock.JSONArrAppendFunc == nil {
		panic("MoqCmdable.JSONArrAppendFunc: method is nil but Cmdable.JSONArrAppend was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		Path   string
		Values []interface{}
	}{
		Ctx:    ctx,
		Key:    key,
		Path:   path,
		Values: values,
	}
	mock.lockJSONArrAppend.Lock()
	mock.calls.JSONArrAppend = append(mock.calls.JSONArrAppend, callInfo)
	mock.lockJSONArrAppend.Unlock()
	return mock.JSONArrAppendFunc(ctx, key, path, values...)
}

// JSONArrAppendCalls gets all the calls that were made to JSONArrAppend.
// Check the length with:
//
//	len(mockedCmdable.JSONArrAppendCalls())
func (mock *MoqCmdable) JSONArrAppendCalls() []struct {
	Ctx    context.Context
	Key    string
	Path   string
	Values []interface{}
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		Path   string
		Values []interface{}
	}
	mock.lockJSONArrAppend.RLock()
	calls = mock.calls.JSONArrAppend
	mock.lockJSONArrAppend.RUnlock()
	return calls
}

// ResetJSONArrAppendCalls reset all the calls that were made to JSONArrAppend.
func (mock *MoqCmdable) ResetJSONArrAppendCalls() {
	mock.lockJSONArrAppend.Lock()
	mock.calls.JSONArrAppend = nil
	mock.lockJSONArrAppend.Unlock()
}

// JSONArrIndex calls JSONArrIndexFunc.
func (mock *MoqCmdable) JSONArrIndex(ctx context.Context, key string, path string, value ...interface{}) *redis.IntSliceCmd {
	if mock.JSONArrIndexFunc == nil {
		panic("MoqCmdable.JSONArrIndexFunc: method is nil but Cmdable.JSONArrIndex was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Path  string
		Value []interface{}
	}{
		Ctx:   ctx,
		Key:   key,
		Path:  path,
		Value: value,
	}
	mock.lockJSONArrIndex.Lock()
	mock.calls.JSONArrIndex = append(mock.calls.JSONArrIndex, callInfo)
	mock.lockJSONArrIndex.Unlock()
	return mock.JSONArrIndexFunc(ctx, key, path, value...)
}

// JSONArrIndexCalls gets all the calls that were made to JSONArrIndex.
// Check the length with:
//
//	len(mockedCmdable.JSONArrIndexCalls())
func (mock *MoqCmdable) JSONArrIndexCalls() []struct {
	Ctx   context.Context
	Key   string
	Path  string
	Value []interface{}
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Path  string
		Value []interface{}
	}
	mock.lockJSONArrIndex.RLock()
	calls = mock.calls.JSONArrIndex
	mock.lockJSONArrIndex.RUnlock()
	return calls
}

// ResetJSONArrIndexCalls reset all the calls that were made to JSONArrIndex.
func (mock *MoqCmdable) ResetJSONArrIndexCalls() {
	mock.lockJSONArrIndex.Lock()
	mock.calls.JSONArrIndex = nil
	mock.lockJSONArrIndex.Unlock()
}

// JSONArrIndexWithArgs calls JSONArrIndexWithArgsFunc.
func (mock *MoqCmdable) JSONArrIndexWithArgs(ctx context.Context, key string, path string, options *redis.JSONArrIndexArgs, value ...interface{}) *redis.IntSliceCmd {
	if mock.JSONArrIndexWithArgsFunc == nil {
		panic("MoqCmdable.JSONArrIndexWithArgsFunc: method is nil but Cmdable.JSONArrIndexWithArgs was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Key     string
		Path    string
		Options *redis.JSONArrIndexArgs
		Value   []interface{}
	}{
		Ctx:     ctx,
		Key:     key,
		Path:    path,
		Options: options,
		Value:   value,
	}
	mock.lockJSONArrIndexWithArgs.Lock()
	mock.calls.JSONArrIndexWithArgs = append(mock.calls.JSONArrIndexWithArgs, callInfo)
	mock.lockJSONArrIndexWithArgs.Unlock()
	return mock.JSONArrIndexWithArgsFunc(ctx, key, path, options, value...)
}

// JSONArrIndexWithArgsCalls gets all the calls that were made to JSONArrIndexWithArgs.
// Check the length with:
//
//	len(mockedCmdable.JSONArrIndexWithArgsCalls())
func (mock *MoqCmdable) JSONArrIndexWithArgsCalls() []struct {
	Ctx     context.Context
	Key     string
	Path    string
	Options *redis.JSONArrIndexArgs
	Value   []interface{}
} {
	var calls []struct {
		Ctx     context.Context
		Key     string
		Path    string
		Options *redis.JSONArrIndexArgs
		Value   []interface{}
	}
	mock.lockJSONArrIndexWithArgs.RLock()
	calls = mock.calls.JSONArrIndexWithArgs
	mock.lockJSONArrIndexWithArgs.RUnlock()
	return calls
}

// ResetJSONArrIndexWithArgsCalls reset all the calls that were made to JSONArrIndexWithArgs.
func (mock *MoqCmdable) ResetJSONArrIndexWithArgsCalls() {
	mock.lockJSONArrIndexWithArgs.Lock()
	mock.calls.JSONArrIndexWithArgs = nil
	mock.lockJSONArrIndexWithArgs.Unlock()
}

// JSONArrInsert calls JSONArrInsertFunc.
func (mock *MoqCmdable) JSONArrInsert(ctx context.Context, key string, path string, index int64, values ...interface{}) *redis.IntSliceCmd {
	if mock.JSONArrInsertFunc == nil {
		panic("MoqCmdable.JSONArrInsertFunc: method is nil but Cmdable.JSONArrInsert was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		Path   string
		Index  int64
		Values []interface{}
	}{
		Ctx:    ctx,
		Key:    key,
		Path:   path,
		Index:  index,
		Values: values,
	}
	mock.lockJSONArrInsert.Lock()
	mock.calls.JSONArrInsert = append(mock.calls.JSONArrInsert, callInfo)
	mock.lockJSONArrInsert.Unlock()
	return mock.JSONArrInsertFunc(ctx, key, path, index, values...)
}

// JSONArrInsertCalls gets all the calls that were made to JSONArrInsert.
// Check the length with:
//
//	len(mockedCmdable.JSONArrInsertCalls())
func (mock *MoqCmdable) JSONArrInsertCalls() []struct {
	Ctx    context.Context
	Key    string
	Path   string
	Index  int64
	Values []interface{}
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		Path   string
		Index  int64
		Values []interface{}
	}
	mock.lockJSONArrInsert.RLock()
	calls = mock.calls.JSONArrInsert
	mock.lockJSONArrInsert.RUnlock()
	return calls
}

// ResetJSONArrInsertCalls reset all the calls that were made to JSONArrInsert.
func (mock *MoqCmdable) ResetJSONArrInsertCalls() {
	mock.lockJSONArrInsert.Lock()
	mock.calls.JSONArrInsert = nil
	mock.lockJSONArrInsert.Unlock()
}

// JSONArrLen calls JSONArrLenFunc.
func (mock *MoqCmdable) JSONArrLen(ctx context.Context, key string, path string) *redis.IntSliceCmd {
	if mock.JSONArrLenFunc == nil {
		panic("MoqCmdable.JSONArrLenFunc: method is nil but Cmdable.JSONArrLen was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Key  string
		Path string
	}{
		Ctx:  ctx,
		Key:  key,
		Path: path,
	}
	mock.lockJSONArrLen.Lock()
	mock.calls.JSONArrLen = append(mock.calls.JSONArrLen, callInfo)
	mock.lockJSONArrLen.Unlock()
	return mock.JSONArrLenFunc(ctx, key, path)
}

// JSONArrLenCalls gets all the calls that were made to JSONArrLen.
// Check the length with:
//
//	len(mockedCmdable.JSONArrLenCalls())
func (mock *MoqCmdable) JSONArrLenCalls() []struct {
	Ctx  context.Context
	Key  string
	Path string
} {
	var calls []struct {
		Ctx  context.Context
		Key  string
		Path string
	}
	mock.lockJSONArrLen.RLock()
	calls = mock.calls.JSONArrLen
	mock.lockJSONArrLen.RUnlock()
	return calls
}

// ResetJSONArrLenCalls reset all the calls that were made to JSONArrLen.
func (mock *MoqCmdable) ResetJSONArrLenCalls() {
	mock.lockJSONArrLen.Lock()
	mock.calls.JSONArrLen = nil
	mock.lockJSONArrLen.Unlock()
}

// JSONArrPop calls JSONArrPopFunc.
func (mock *MoqCmdable) JSONArrPop(ctx context.Context, key string, path string, index int) *redis.StringSliceCmd {
	if mock.JSONArrPopFunc == nil {
		panic("MoqCmdable.JSONArrPopFunc: method is nil but Cmdable.JSONArrPop was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Path  string
		Index int
	}{
		Ctx:   ctx,
		Key:   key,
		Path:  path,
		Index: index,
	}
	mock.lockJSONArrPop.Lock()
	mock.calls.JSONArrPop = append(mock.calls.JSONArrPop, callInfo)
	mock.lockJSONArrPop.Unlock()
	return mock.JSONArrPopFunc(ctx, key, path, index)
}

// JSONArrPopCalls gets all the calls that were made to JSONArrPop.
// Check the length with:
//
//	len(mockedCmdable.JSONArrPopCalls())
func (mock *MoqCmdable) JSONArrPopCalls() []struct {
	Ctx   context.Context
	Key   string
	Path  string
	Index int
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Path  string
		Index int
	}
	mock.lockJSONArrPop.RLock()
	calls = mock.calls.JSONArrPop
	mock.lockJSONArrPop.RUnlock()
	return calls
}

// ResetJSONArrPopCalls reset all the calls that were made to JSONArrPop.
func (mock *MoqCmdable) ResetJSONArrPopCalls() {
	mock.lockJSONArrPop.Lock()
	mock.calls.JSONArrPop = nil
	mock.lockJSONArrPop.Unlock()
}

// JSONArrTrim calls JSONArrTrimFunc.
func (mock *MoqCmdable) JSONArrTrim(ctx context.Context, key string, path string) *redis.IntSliceCmd {
	if mock.JSONArrTrimFunc == nil {
		panic("MoqCmdable.JSONArrTrimFunc: method is nil but Cmdable.JSONArrTrim was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Key  string
		Path string
	}{
		Ctx:  ctx,
		Key:  key,
		Path: path,
	}
	mock.lockJSONArrTrim.Lock()
	mock.calls.JSONArrTrim = append(mock.calls.JSONArrTrim, callInfo)
	mock.lockJSONArrTrim.Unlock()
	return mock.JSONArrTrimFunc(ctx, key, path)
}

// JSONArrTrimCalls gets all the calls that were made to JSONArrTrim.
// Check the length with:
//
//	len(mockedCmdable.JSONArrTrimCalls())
func (mock *MoqCmdable) JSONArrTrimCalls() []struct {
	Ctx  context.Context
	Key  string
	Path string
} {
	var calls []struct {
		Ctx  context.Context
		Key  string
		Path string
	}
	mock.lockJSONArrTrim.RLock()
	calls = mock.calls.JSONArrTrim
	mock.lockJSONArrTrim.RUnlock()
	return calls
}

// ResetJSONArrTrimCalls reset all the calls that were made to JSONArrTrim.
func (mock *MoqCmdable) ResetJSONArrTrimCalls() {
	mock.lockJSONArrTrim.Lock()
	mock.calls.JSONArrTrim = nil
	mock.lockJSONArrTrim.Unlock()
}

// JSONArrTrimWithArgs calls JSONArrTrimWithArgsFunc.
func (mock *MoqCmdable) JSONArrTrimWithArgs(ctx context.Context, key string, path string, options *redis.JSONArrTrimArgs) *redis.IntSliceCmd {
	if mock.JSONArrTrimWithArgsFunc == nil {
		panic("MoqCmdable.JSONArrTrimWithArgsFunc: method is nil but Cmdable.JSONArrTrimWithArgs was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Key     string
		Path    string
		Options *redis.JSONArrTrimArgs
	}{
		Ctx:     ctx,
		Key:     key,
		Path:    path,
		Options: options,
	}
	mock.lockJSONArrTrimWithArgs.Lock()
	mock.calls.JSONArrTrimWithArgs = append(mock.calls.JSONArrTrimWithArgs, callInfo)
	mock.lockJSONArrTrimWithArgs.Unlock()
	return mock.JSONArrTrimWithArgsFunc(ctx, key, path, options)
}

// JSONArrTrimWithArgsCalls gets all the calls that were made to JSONArrTrimWithArgs.
// Check the length with:
//
//	len(mockedCmdable.JSONArrTrimWithArgsCalls())
func (mock *MoqCmdable) JSONArrTrimWithArgsCalls() []struct {
	Ctx     context.Context
	Key     string
	Path    string
	Options *redis.JSONArrTrimArgs
} {
	var calls []struct {
		Ctx     context.Context
		Key     string
		Path    string
		Options *redis.JSONArrTrimArgs
	}
	mock.lockJSONArrTrimWithArgs.RLock()
	calls = mock.calls.JSONArrTrimWithArgs
	mock.lockJSONArrTrimWithArgs.RUnlock()
	return calls
}

// ResetJSONArrTrimWithArgsCalls reset all the calls that were made to JSONArrTrimWithArgs.
func (mock *MoqCmdable) ResetJSONArrTrimWithArgsCalls() {
	mock.lockJSONArrTrimWithArgs.Lock()
	mock.calls.JSONArrTrimWithArgs = nil
	mock.lockJSONArrTrimWithArgs.Unlock()
}

// JSONClear calls JSONClearFunc.
func (mock *MoqCmdable) JSONClear(ctx context.Context, key string, path string) *redis.IntCmd {
	if mock.JSONClearFunc == nil {
		panic("MoqCmdable.JSONClearFunc: method is nil but Cmdable.JSONClear was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Key  string
		Path string
	}{
		Ctx:  ctx,
		Key:  key,
		Path: path,
	}
	mock.lockJSONClear.Lock()
	mock.calls.JSONClear = append(mock.calls.JSONClear, callInfo)
	mock.lockJSONClear.Unlock()
	return mock.JSONClearFunc(ctx, key, path)
}

// JSONClearCalls gets all the calls that were made to JSONClear.
// Check the length with:
//
//	len(mockedCmdable.JSONClearCalls())
func (mock *MoqCmdable) JSONClearCalls() []struct {
	Ctx  context.Context
	Key  string
	Path string
} {
	var calls []struct {
		Ctx  context.Context
		Key  string
		Path string
	}
	mock.lockJSONClear.RLock()
	calls = mock.calls.JSONClear
	mock.lockJSONClear.RUnlock()
	return calls
}

// ResetJSONClearCalls reset all the calls that were made to JSONClear.
func (mock *MoqCmdable) ResetJSONClearCalls() {
	mock.lockJSONClear.Lock()
	mock.calls.JSONClear = nil
	mock.lockJSONClear.Unlock()
}

// JSONDebugMemory calls JSONDebugMemoryFunc.
func (mock *MoqCmdable) JSONDebugMemory(ctx context.Context, key string, path string) *redis.IntCmd {
	if mock.JSONDebugMemoryFunc == nil {
		panic("MoqCmdable.JSONDebugMemoryFunc: method is nil but Cmdable.JSONDebugMemory was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Key  string
		Path string
	}{
		Ctx:  ctx,
		Key:  key,
		Path: path,
	}
	mock.lockJSONDebugMemory.Lock()
	mock.calls.JSONDebugMemory = append(mock.calls.JSONDebugMemory, callInfo)
	mock.lockJSONDebugMemory.Unlock()
	return mock.JSONDebugMemoryFunc(ctx, key, path)
}

// JSONDebugMemoryCalls gets all the calls that were made to JSONDebugMemory.
// Check the length with:
//
//	len(mockedCmdable.JSONDebugMemoryCalls())
func (mock *MoqCmdable) JSONDebugMemoryCalls() []struct {
	Ctx  context.Context
	Key  string
	Path string
} {
	var calls []struct {
		Ctx  context.Context
		Key  string
		Path string
	}
	mock.lockJSONDebugMemory.RLock()
	calls = mock.calls.JSONDebugMemory
	mock.lockJSONDebugMemory.RUnlock()
	return calls
}

// ResetJSONDebugMemoryCalls reset all the calls that were made to JSONDebugMemory.
func (mock *MoqCmdable) ResetJSONDebugMemoryCalls() {
	mock.lockJSONDebugMemory.Lock()
	mock.calls.JSONDebugMemory = nil
	mock.lockJSONDebugMemory.Unlock()
}

// JSONDel calls JSONDelFunc.
func (mock *MoqCmdable) JSONDel(ctx context.Context, key string, path string) *redis.IntCmd {
	if mock.JSONDelFunc == nil {
		panic("MoqCmdable.JSONDelFunc: method is nil but Cmdable.JSONDel was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Key  string
		Path string
	}{
		Ctx:  ctx,
		Key:  key,
		Path: path,
	}
	mock.lockJSONDel.Lock()
	mock.calls.JSONDel = append(mock.calls.JSONDel, callInfo)
	mock.lockJSONDel.Unlock()
	return mock.JSONDelFunc(ctx, key, path)
}

// JSONDelCalls gets all the calls that were made to JSONDel.
// Check the length with:
//
//	len(mockedCmdable.JSONDelCalls())
func (mock *MoqCmdable) JSONDelCalls() []struct {
	Ctx  context.Context
	Key  string
	Path string
} {
	var calls []struct {
		Ctx  context.Context
		Key  string
		Path string
	}
	mock.lockJSONDel.RLock()
	calls = mock.calls.JSONDel
	mock.lockJSONDel.RUnlock()
	return calls
}

// ResetJSONDelCalls reset all the calls that were made to JSONDel.
func (mock *MoqCmdable) ResetJSONDelCalls() {
	mock.lockJSONDel.Lock()
	mock.calls.JSONDel = nil
	mock.lockJSONDel.Unlock()
}

// JSONForget calls JSONForgetFunc.
func (mock *MoqCmdable) JSONForget(ctx context.Context, key string, path string) *redis.IntCmd {
	if mock.JSONForgetFunc == nil {
		panic("MoqCmdable.JSONForgetFunc: method is nil but Cmdable.JSONForget was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Key  string
		Path string
	}{
		Ctx:  ctx,
		Key:  key,
		Path: path,
	}
	mock.lockJSONForget.Lock()
	mock.calls.JSONForget = append(mock.calls.JSONForget, callInfo)
	mock.lockJSONForget.Unlock()
	return mock.JSONForgetFunc(ctx, key, path)
}

// JSONForgetCalls gets all the calls that were made to JSONForget.
// Check the length with:
//
//	len(mockedCmdable.JSONForgetCalls())
func (mock *MoqCmdable) JSONForgetCalls() []struct {
	Ctx  context.Context
	Key  string
	Path string
} {
	var calls []struct {
		Ctx  context.Context
		Key  string
		Path string
	}
	mock.lockJSONForget.RLock()
	calls = mock.calls.JSONForget
	mock.lockJSONForget.RUnlock()
	return calls
}

// ResetJSONForgetCalls reset all the calls that were made to JSONForget.
func (mock *MoqCmdable) ResetJSONForgetCalls() {
	mock.lockJSONForget.Lock()
	mock.calls.JSONForget = nil
	mock.lockJSONForget.Unlock()
}

// JSONGet calls JSONGetFunc.
func (mock *MoqCmdable) JSONGet(ctx context.Context, key string, paths ...string) *redis.JSONCmd {
	if mock.JSONGetFunc == nil {
		panic("MoqCmdable.JSONGetFunc: method is nil but Cmdable.JSONGet was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Paths []string
	}{
		Ctx:   ctx,
		Key:   key,
		Paths: paths,
	}
	mock.lockJSONGet.Lock()
	mock.calls.JSONGet = append(mock.calls.JSONGet, callInfo)
	mock.lockJSONGet.Unlock()
	return mock.JSONGetFunc(ctx, key, paths...)
}

// JSONGetCalls gets all the calls that were made to JSONGet.
// Check the length with:
//
//	len(mockedCmdable.JSONGetCalls())
func (mock *MoqCmdable) JSONGetCalls() []struct {
	Ctx   context.Context
	Key   string
	Paths []string
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Paths []string
	}
	mock.lockJSONGet.RLock()
	calls = mock.calls.JSONGet
	mock.lockJSONGet.RUnlock()
	return calls
}

// ResetJSONGetCalls reset all the calls that were made to JSONGet.
func (mock *MoqCmdable) ResetJSONGetCalls() {
	mock.lockJSONGet.Lock()
	mock.calls.JSONGet = nil
	mock.lockJSONGet.Unlock()
}

// JSONGetWithArgs calls JSONGetWithArgsFunc.
func (mock *MoqCmdable) JSONGetWithArgs(ctx context.Context, key string, options *redis.JSONGetArgs, paths ...string) *redis.JSONCmd {
	if mock.JSONGetWithArgsFunc == nil {
		panic("MoqCmdable.JSONGetWithArgsFunc: method is nil but Cmdable.JSONGetWithArgs was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Key     string
		Options *redis.JSONGetArgs
		Paths   []string
	}{
		Ctx:     ctx,
		Key:     key,
		Options: options,
		Paths:   paths,
	}
	mock.lockJSONGetWithArgs.Lock()
	mock.calls.JSONGetWithArgs = append(mock.calls.JSONGetWithArgs, callInfo)
	mock.lockJSONGetWithArgs.Unlock()
	return mock.JSONGetWithArgsFunc(ctx, key, options, paths...)
}

// JSONGetWithArgsCalls gets all the calls that were made to JSONGetWithArgs.
// Check the length with:
//
//	len(mockedCmdable.JSONGetWithArgsCalls())
func (mock *MoqCmdable) JSONGetWithArgsCalls() []struct {
	Ctx     context.Context
	Key     string
	Options *redis.JSONGetArgs
	Paths   []string
} {
	var calls []struct {
		Ctx     context.Context
		Key     string
		Options *redis.JSONGetArgs
		Paths   []string
	}
	mock.lockJSONGetWithArgs.RLock()
	calls = mock.calls.JSONGetWithArgs
	mock.lockJSONGetWithArgs.RUnlock()
	return calls
}

// ResetJSONGetWithArgsCalls reset all the calls that were made to JSONGetWithArgs.
func (mock *MoqCmdable) ResetJSONGetWithArgsCalls() {
	mock.lockJSONGetWithArgs.Lock()
	mock.calls.JSONGetWithArgs = nil
	mock.lockJSONGetWithArgs.Unlock()
}

// JSONMGet calls JSONMGetFunc.
func (mock *MoqCmdable) JSONMGet(ctx context.Context, path string, keys ...string) *redis.JSONSliceCmd {
	if mock.JSONMGetFunc == nil {
		panic("MoqCmdable.JSONMGetFunc: method is nil but Cmdable.JSONMGet was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Path string
		Keys []string
	}{
		Ctx:  ctx,
		Path: path,
		Keys: keys,
	}
	mock.lockJSONMGet.Lock()
	mock.calls.JSONMGet = append(mock.calls.JSONMGet, callInfo)
	mock.lockJSONMGet.Unlock()
	return mock.JSONMGetFunc(ctx, path, keys...)
}

// JSONMGetCalls gets all the calls that were made to JSONMGet.
// Check the length with:
//
//	len(mockedCmdable.JSONMGetCalls())
func (mock *MoqCmdable) JSONMGetCalls() []struct {
	Ctx  context.Context
	Path string
	Keys []string
} {
	var calls []struct {
		Ctx  context.Context
		Path string
		Keys []string
	}
	mock.lockJSONMGet.RLock()
	calls = mock.calls.JSONMGet
	mock.lockJSONMGet.RUnlock()
	return calls
}

// ResetJSONMGetCalls reset all the calls that were made to JSONMGet.
func (mock *MoqCmdable) ResetJSONMGetCalls() {
	mock.lockJSONMGet.Lock()
	mock.calls.JSONMGet = nil
	mock.lockJSONMGet.Unlock()
}

// JSONMSet calls JSONMSetFunc.
func (mock *MoqCmdable) JSONMSet(ctx context.Context, params ...interface{}) *redis.StatusCmd {
	if mock.JSONMSetFunc == nil {
		panic("MoqCmdable.JSONMSetFunc: method is nil but Cmdable.JSONMSet was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Params []interface{}
	}{
		Ctx:    ctx,
		Params: params,
	}
	mock.lockJSONMSet.Lock()
	mock.calls.JSONMSet = append(mock.calls.JSONMSet, callInfo)
	mock.lockJSONMSet.Unlock()
	return mock.JSONMSetFunc(ctx, params...)
}

// JSONMSetCalls gets all the calls that were made to JSONMSet.
// Check the length with:
//
//	len(mockedCmdable.JSONMSetCalls())
func (mock *MoqCmdable) JSONMSetCalls() []struct {
	Ctx    context.Context
	Params []interface{}
} {
	var calls []struct {
		Ctx    context.Context
		Params []interface{}
	}
	mock.lockJSONMSet.RLock()
	calls = mock.calls.JSONMSet
	mock.lockJSONMSet.RUnlock()
	return calls
}

// ResetJSONMSetCalls reset all the calls that were made to JSONMSet.
func (mock *MoqCmdable) ResetJSONMSetCalls() {
	mock.lockJSONMSet.Lock()
	mock.calls.JSONMSet = nil
	mock.lockJSONMSet.Unlock()
}

// JSONMSetArgs calls JSONMSetArgsFunc.
func (mock *MoqCmdable) JSONMSetArgs(ctx context.Context, docs []redis.JSONSetArgs) *redis.StatusCmd {
	if mock.JSONMSetArgsFunc == nil {
		panic("MoqCmdable.JSONMSetArgsFunc: method is nil but Cmdable.JSONMSetArgs was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Docs []redis.JSONSetArgs
	}{
		Ctx:  ctx,
		Docs: docs,
	}
	mock.lockJSONMSetArgs.Lock()
	mock.calls.JSONMSetArgs = append(mock.calls.JSONMSetArgs, callInfo)
	mock.lockJSONMSetArgs.Unlock()
	return mock.JSONMSetArgsFunc(ctx, docs)
}

// JSONMSetArgsCalls gets all the calls that were made to JSONMSetArgs.
// Check the length with:
//
//	len(mockedCmdable.JSONMSetArgsCalls())
func (mock *MoqCmdable) JSONMSetArgsCalls() []struct {
	Ctx  context.Context
	Docs []redis.JSONSetArgs
} {
	var calls []struct {
		Ctx  context.Context
		Docs []redis.JSONSetArgs
	}
	mock.lockJSONMSetArgs.RLock()
	calls = mock.calls.JSONMSetArgs
	mock.lockJSONMSetArgs.RUnlock()
	return calls
}

// ResetJSONMSetArgsCalls reset all the calls that were made to JSONMSetArgs.
func (mock *MoqCmdable) ResetJSONMSetArgsCalls() {
	mock.lockJSONMSetArgs.Lock()
	mock.calls.JSONMSetArgs = nil
	mock.lockJSONMSetArgs.Unlock()
}

// JSONMerge calls JSONMergeFunc.
func (mock *MoqCmdable) JSONMerge(ctx context.Context, key string, path string, value string) *redis.StatusCmd {
	if mock.JSONMergeFunc == nil {
		panic("MoqCmdable.JSONMergeFunc: method is nil but Cmdable.JSONMerge was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Path  string
		Value string
	}{
		Ctx:   ctx,
		Key:   key,
		Path:  path,
		Value: value,
	}
	mock.lockJSONMerge.Lock()
	mock.calls.JSONMerge = append(mock.calls.JSONMerge, callInfo)
	mock.lockJSONMerge.Unlock()
	return mock.JSONMergeFunc(ctx, key, path, value)
}

// JSONMergeCalls gets all the calls that were made to JSONMerge.
// Check the length with:
//
//	len(mockedCmdable.JSONMergeCalls())
func (mock *MoqCmdable) JSONMergeCalls() []struct {
	Ctx   context.Context
	Key   string
	Path  string
	Value string
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Path  string
		Value string
	}
	mock.lockJSONMerge.RLock()
	calls = mock.calls.JSONMerge
	mock.lockJSONMerge.RUnlock()
	return calls
}

// ResetJSONMergeCalls reset all the calls that were made to JSONMerge.
func (mock *MoqCmdable) ResetJSONMergeCalls() {
	mock.lockJSONMerge.Lock()
	mock.calls.JSONMerge = nil
	mock.lockJSONMerge.Unlock()
}

// JSONNumIncrBy calls JSONNumIncrByFunc.
func (mock *MoqCmdable) JSONNumIncrBy(ctx context.Context, key string, path string, value float64) *redis.JSONCmd {
	if mock.JSONNumIncrByFunc == nil {
		panic("MoqCmdable.JSONNumIncrByFunc: method is nil but Cmdable.JSONNumIncrBy was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Path  string
		Value float64
	}{
		Ctx:   ctx,
		Key:   key,
		Path:  path,
		Value: value,
	}
	mock.lockJSONNumIncrBy.Lock()
	mock.calls.JSONNumIncrBy = append(mock.calls.JSONNumIncrBy, callInfo)
	mock.lockJSONNumIncrBy.Unlock()
	return mock.JSONNumIncrByFunc(ctx, key, path, value)
}

// JSONNumIncrByCalls gets all the calls that were made to JSONNumIncrBy.
// Check the length with:
//
//	len(mockedCmdable.JSONNumIncrByCalls())
func (mock *MoqCmdable) JSONNumIncrByCalls() []struct {
	Ctx   context.Context
	Key   string
	Path  string
	Value float64
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Path  string
		Value float64
	}
	mock.lockJSONNumIncrBy.RLock()
	calls = mock.calls.JSONNumIncrBy
	mock.lockJSONNumIncrBy.RUnlock()
	return calls
}

// ResetJSONNumIncrByCalls reset all the calls that were made to JSONNumIncrBy.
func (mock *MoqCmdable) ResetJSONNumIncrByCalls() {
	mock.lockJSONNumIncrBy.Lock()
	mock.calls.JSONNumIncrBy = nil
	mock.lockJSONNumIncrBy.Unlock()
}

// JSONObjKeys calls JSONObjKeysFunc.
func (mock *MoqCmdable) JSONObjKeys(ctx context.Context, key string, path string) *redis.SliceCmd {
	if mock.JSONObjKeysFunc == nil {
		panic("MoqCmdable.JSONObjKeysFunc: method is nil but Cmdable.JSONObjKeys was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Key  string
		Path string
	}{
		Ctx:  ctx,
		Key:  key,
		Path: path,
	}
	mock.lockJSONObjKeys.Lock()
	mock.calls.JSONObjKeys = append(mock.calls.JSONObjKeys, callInfo)
	mock.lockJSONObjKeys.Unlock()
	return mock.JSONObjKeysFunc(ctx, key, path)
}

// JSONObjKeysCalls gets all the calls that were made to JSONObjKeys.
// Check the length with:
//
//	len(mockedCmdable.JSONObjKeysCalls())
func (mock *MoqCmdable) JSONObjKeysCalls() []struct {
	Ctx  context.Context
	Key  string
	Path string
} {
	var calls []struct {
		Ctx  context.Context
		Key  string
		Path string
	}
	mock.lockJSONObjKeys.RLock()
	calls = mock.calls.JSONObjKeys
	mock.lockJSONObjKeys.RUnlock()
	return calls
}

// ResetJSONObjKeysCalls reset all the calls that were made to JSONObjKeys.
func (mock *MoqCmdable) ResetJSONObjKeysCalls() {
	mock.lockJSONObjKeys.Lock()
	mock.calls.JSONObjKeys = nil
	mock.lockJSONObjKeys.Unlock()
}

// JSONObjLen calls JSONObjLenFunc.
func (mock *MoqCmdable) JSONObjLen(ctx context.Context, key string, path string) *redis.IntPointerSliceCmd {
	if mock.JSONObjLenFunc == nil {
		panic("MoqCmdable.JSONObjLenFunc: method is nil but Cmdable.JSONObjLen was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Key  string
		Path string
	}{
		Ctx:  ctx,
		Key:  key,
		Path: path,
	}
	mock.lockJSONObjLen.Lock()
	mock.calls.JSONObjLen = append(mock.calls.JSONObjLen, callInfo)
	mock.lockJSONObjLen.Unlock()
	return mock.JSONObjLenFunc(ctx, key, path)
}

// JSONObjLenCalls gets all the calls that were made to JSONObjLen.
// Check the length with:
//
//	len(mockedCmdable.JSONObjLenCalls())
func (mock *MoqCmdable) JSONObjLenCalls() []struct {
	Ctx  context.Context
	Key  string
	Path string
} {
	var calls []struct {
		Ctx  context.Context
		Key  string
		Path string
	}
	mock.lockJSONObjLen.RLock()
	calls = mock.calls.JSONObjLen
	mock.lockJSONObjLen.RUnlock()
	return calls
}

// ResetJSONObjLenCalls reset all the calls that were made to JSONObjLen.
func (mock *MoqCmdable) ResetJSONObjLenCalls() {
	mock.lockJSONObjLen.Lock()
	mock.calls.JSONObjLen = nil
	mock.lockJSONObjLen.Unlock()
}

// JSONSet calls JSONSetFunc.
func (mock *MoqCmdable) JSONSet(ctx context.Context, key string, path string, value interface{}) *redis.StatusCmd {
	if mock.JSONSetFunc == nil {
		panic("MoqCmdable.JSONSetFunc: method is nil but Cmdable.JSONSet was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Path  string
		Value interface{}
	}{
		Ctx:   ctx,
		Key:   key,
		Path:  path,
		Value: value,
	}
	mock.lockJSONSet.Lock()
	mock.calls.JSONSet = append(mock.calls.JSONSet, callInfo)
	mock.lockJSONSet.Unlock()
	return mock.JSONSetFunc(ctx, key, path, value)
}

// JSONSetCalls gets all the calls that were made to JSONSet.
// Check the length with:
//
//	len(mockedCmdable.JSONSetCalls())
func (mock *MoqCmdable) JSONSetCalls() []struct {
	Ctx   context.Context
	Key   string
	Path  string
	Value interface{}
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Path  string
		Value interface{}
	}
	mock.lockJSONSet.RLock()
	calls = mock.calls.JSONSet
	mock.lockJSONSet.RUnlock()
	return calls
}

// ResetJSONSetCalls reset all the calls that were made to JSONSet.
func (mock *MoqCmdable) ResetJSONSetCalls() {
	mock.lockJSONSet.Lock()
	mock.calls.JSONSet = nil
	mock.lockJSONSet.Unlock()
}

// JSONSetMode calls JSONSetModeFunc.
func (mock *MoqCmdable) JSONSetMode(ctx context.Context, key string, path string, value interface{}, mode string) *redis.StatusCmd {
	if mock.JSONSetModeFunc == nil {
		panic("MoqCmdable.JSONSetModeFunc: method is nil but Cmdable.JSONSetMode was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Path  string
		Value interface{}
		Mode  string
	}{
		Ctx:   ctx,
		Key:   key,
		Path:  path,
		Value: value,
		Mode:  mode,
	}
	mock.lockJSONSetMode.Lock()
	mock.calls.JSONSetMode = append(mock.calls.JSONSetMode, callInfo)
	mock.lockJSONSetMode.Unlock()
	return mock.JSONSetModeFunc(ctx, key, path, value, mode)
}

// JSONSetModeCalls gets all the calls that were made to JSONSetMode.
// Check the length with:
//
//	len(mockedCmdable.JSONSetModeCalls())
func (mock *MoqCmdable) JSONSetModeCalls() []struct {
	Ctx   context.Context
	Key   string
	Path  string
	Value interface{}
	Mode  string
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Path  string
		Value interface{}
		Mode  string
	}
	mock.lockJSONSetMode.RLock()
	calls = mock.calls.JSONSetMode
	mock.lockJSONSetMode.RUnlock()
	return calls
}

// ResetJSONSetModeCalls reset all the calls that were made to JSONSetMode.
func (mock *MoqCmdable) ResetJSONSetModeCalls() {
	mock.lockJSONSetMode.Lock()
	mock.calls.JSONSetMode = nil
	mock.lockJSONSetMode.Unlock()
}

// JSONStrAppend calls JSONStrAppendFunc.
func (mock *MoqCmdable) JSONStrAppend(ctx context.Context, key string, path string, value string) *redis.IntPointerSliceCmd {
	if mock.JSONStrAppendFunc == nil {
		panic("MoqCmdable.JSONStrAppendFunc: method is nil but Cmdable.JSONStrAppend was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Path  string
		Value string
	}{
		Ctx:   ctx,
		Key:   key,
		Path:  path,
		Value: value,
	}
	mock.lockJSONStrAppend.Lock()
	mock.calls.JSONStrAppend = append(mock.calls.JSONStrAppend, callInfo)
	mock.lockJSONStrAppend.Unlock()
	return mock.JSONStrAppendFunc(ctx, key, path, value)
}

// JSONStrAppendCalls gets all the calls that were made to JSONStrAppend.
// Check the length with:
//
//	len(mockedCmdable.JSONStrAppendCalls())
func (mock *MoqCmdable) JSONStrAppendCalls() []struct {
	Ctx   context.Context
	Key   string
	Path  string
	Value string
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Path  string
		Value string
	}
	mock.lockJSONStrAppend.RLock()
	calls = mock.calls.JSONStrAppend
	mock.lockJSONStrAppend.RUnlock()
	return calls
}

// ResetJSONStrAppendCalls reset all the calls that were made to JSONStrAppend.
func (mock *MoqCmdable) ResetJSONStrAppendCalls() {
	mock.lockJSONStrAppend.Lock()
	mock.calls.JSONStrAppend = nil
	mock.lockJSONStrAppend.Unlock()
}

// JSONStrLen calls JSONStrLenFunc.
func (mock *MoqCmdable) JSONStrLen(ctx context.Context, key string, path string) *redis.IntPointerSliceCmd {
	if mock.JSONStrLenFunc == nil {
		panic("MoqCmdable.JSONStrLenFunc: method is nil but Cmdable.JSONStrLen was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Key  string
		Path string
	}{
		Ctx:  ctx,
		Key:  key,
		Path: path,
	}
	mock.lockJSONStrLen.Lock()
	mock.calls.JSONStrLen = append(mock.calls.JSONStrLen, callInfo)
	mock.lockJSONStrLen.Unlock()
	return mock.JSONStrLenFunc(ctx, key, path)
}

// JSONStrLenCalls gets all the calls that were made to JSONStrLen.
// Check the length with:
//
//	len(mockedCmdable.JSONStrLenCalls())
func (mock *MoqCmdable) JSONStrLenCalls() []struct {
	Ctx  context.Context
	Key  string
	Path string
} {
	var calls []struct {
		Ctx  context.Context
		Key  string
		Path string
	}
	mock.lockJSONStrLen.RLock()
	calls = mock.calls.JSONStrLen
	mock.lockJSONStrLen.RUnlock()
	return calls
}

// ResetJSONStrLenCalls reset all the calls that were made to JSONStrLen.
func (mock *MoqCmdable) ResetJSONStrLenCalls() {
	mock.lockJSONStrLen.Lock()
	mock.calls.JSONStrLen = nil
	mock.lockJSONStrLen.Unlock()
}

// JSONToggle calls JSONToggleFunc.
func (mock *MoqCmdable) JSONToggle(ctx context.Context, key string, path string) *redis.IntPointerSliceCmd {
	if mock.JSONToggleFunc == nil {
		panic("MoqCmdable.JSONToggleFunc: method is nil but Cmdable.JSONToggle was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Key  string
		Path string
	}{
		Ctx:  ctx,
		Key:  key,
		Path: path,
	}
	mock.lockJSONToggle.Lock()
	mock.calls.JSONToggle = append(mock.calls.JSONToggle, callInfo)
	mock.lockJSONToggle.Unlock()
	return mock.JSONToggleFunc(ctx, key, path)
}

// JSONToggleCalls gets all the calls that were made to JSONToggle.
// Check the length with:
//
//	len(mockedCmdable.JSONToggleCalls())
func (mock *MoqCmdable) JSONToggleCalls() []struct {
	Ctx  context.Context
	Key  string
	Path string
} {
	var calls []struct {
		Ctx  context.Context
		Key  string
		Path string
	}
	mock.lockJSONToggle.RLock()
	calls = mock.calls.JSONToggle
	mock.lockJSONToggle.RUnlock()
	return calls
}

// ResetJSONToggleCalls reset all the calls that were made to JSONToggle.
func (mock *MoqCmdable) ResetJSONToggleCalls() {
	mock.lockJSONToggle.Lock()
	mock.calls.JSONToggle = nil
	mock.lockJSONToggle.Unlock()
}

// JSONType calls JSONTypeFunc.
func (mock *MoqCmdable) JSONType(ctx context.Context, key string, path string) *redis.JSONSliceCmd {
	if mock.JSONTypeFunc == nil {
		panic("MoqCmdable.JSONTypeFunc: method is nil but Cmdable.JSONType was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Key  string
		Path string
	}{
		Ctx:  ctx,
		Key:  key,
		Path: path,
	}
	mock.lockJSONType.Lock()
	mock.calls.JSONType = append(mock.calls.JSONType, callInfo)
	mock.lockJSONType.Unlock()
	return mock.JSONTypeFunc(ctx, key, path)
}

// JSONTypeCalls gets all the calls that were made to JSONType.
// Check the length with:
//
//	len(mockedCmdable.JSONTypeCalls())
func (mock *MoqCmdable) JSONTypeCalls() []struct {
	Ctx  context.Context
	Key  string
	Path string
} {
	var calls []struct {
		Ctx  context.Context
		Key  string
		Path string
	}
	mock.lockJSONType.RLock()
	calls = mock.calls.JSONType
	mock.lockJSONType.RUnlock()
	return calls
}

// ResetJSONTypeCalls reset all the calls that were made to JSONType.
func (mock *MoqCmdable) ResetJSONTypeCalls() {
	mock.lockJSONType.Lock()
	mock.calls.JSONType = nil
	mock.lockJSONType.Unlock()
}

// Keys calls KeysFunc.
func (mock *MoqCmdable) Keys(ctx context.Context, pattern string) *redis.StringSliceCmd {
	if mock.KeysFunc == nil {
		panic("MoqCmdable.KeysFunc: method is nil but Cmdable.Keys was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Pattern string
	}{
		Ctx:     ctx,
		Pattern: pattern,
	}
	mock.lockKeys.Lock()
	mock.calls.Keys = append(mock.calls.Keys, callInfo)
	mock.lockKeys.Unlock()
	return mock.KeysFunc(ctx, pattern)
}

// KeysCalls gets all the calls that were made to Keys.
// Check the length with:
//
//	len(mockedCmdable.KeysCalls())
func (mock *MoqCmdable) KeysCalls() []struct {
	Ctx     context.Context
	Pattern string
} {
	var calls []struct {
		Ctx     context.Context
		Pattern string
	}
	mock.lockKeys.RLock()
	calls = mock.calls.Keys
	mock.lockKeys.RUnlock()
	return calls
}

// ResetKeysCalls reset all the calls that were made to Keys.
func (mock *MoqCmdable) ResetKeysCalls() {
	mock.lockKeys.Lock()
	mock.calls.Keys = nil
	mock.lockKeys.Unlock()
}

// LCS calls LCSFunc.
func (mock *MoqCmdable) LCS(ctx context.Context, q *redis.LCSQuery) *redis.LCSCmd {
	if mock.LCSFunc == nil {
		panic("MoqCmdable.LCSFunc: method is nil but Cmdable.LCS was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Q   *redis.LCSQuery
	}{
		Ctx: ctx,
		Q:   q,
	}
	mock.lockLCS.Lock()
	mock.calls.LCS = append(mock.calls.LCS, callInfo)
	mock.lockLCS.Unlock()
	return mock.LCSFunc(ctx, q)
}

// LCSCalls gets all the calls that were made to LCS.
// Check the length with:
//
//	len(mockedCmdable.LCSCalls())
func (mock *MoqCmdable) LCSCalls() []struct {
	Ctx context.Context
	Q   *redis.LCSQuery
} {
	var calls []struct {
		Ctx context.Context
		Q   *redis.LCSQuery
	}
	mock.lockLCS.RLock()
	calls = mock.calls.LCS
	mock.lockLCS.RUnlock()
	return calls
}

// ResetLCSCalls reset all the calls that were made to LCS.
func (mock *MoqCmdable) ResetLCSCalls() {
	mock.lockLCS.Lock()
	mock.calls.LCS = nil
	mock.lockLCS.Unlock()
}

// LIndex calls LIndexFunc.
func (mock *MoqCmdable) LIndex(ctx context.Context, key string, index int64) *redis.StringCmd {
	if mock.LIndexFunc == nil {
		panic("MoqCmdable.LIndexFunc: method is nil but Cmdable.LIndex was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Index int64
	}{
		Ctx:   ctx,
		Key:   key,
		Index: index,
	}
	mock.lockLIndex.Lock()
	mock.calls.LIndex = append(mock.calls.LIndex, callInfo)
	mock.lockLIndex.Unlock()
	return mock.LIndexFunc(ctx, key, index)
}

// LIndexCalls gets all the calls that were made to LIndex.
// Check the length with:
//
//	len(mockedCmdable.LIndexCalls())
func (mock *MoqCmdable) LIndexCalls() []struct {
	Ctx   context.Context
	Key   string
	Index int64
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Index int64
	}
	mock.lockLIndex.RLock()
	calls = mock.calls.LIndex
	mock.lockLIndex.RUnlock()
	return calls
}

// ResetLIndexCalls reset all the calls that were made to LIndex.
func (mock *MoqCmdable) ResetLIndexCalls() {
	mock.lockLIndex.Lock()
	mock.calls.LIndex = nil
	mock.lockLIndex.Unlock()
}

// LInsert calls LInsertFunc.
func (mock *MoqCmdable) LInsert(ctx context.Context, key string, op string, pivot interface{}, value interface{}) *redis.IntCmd {
	if mock.LInsertFunc == nil {
		panic("MoqCmdable.LInsertFunc: method is nil but Cmdable.LInsert was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Op    string
		Pivot interface{}
		Value interface{}
	}{
		Ctx:   ctx,
		Key:   key,
		Op:    op,
		Pivot: pivot,
		Value: value,
	}
	mock.lockLInsert.Lock()
	mock.calls.LInsert = append(mock.calls.LInsert, callInfo)
	mock.lockLInsert.Unlock()
	return mock.LInsertFunc(ctx, key, op, pivot, value)
}

// LInsertCalls gets all the calls that were made to LInsert.
// Check the length with:
//
//	len(mockedCmdable.LInsertCalls())
func (mock *MoqCmdable) LInsertCalls() []struct {
	Ctx   context.Context
	Key   string
	Op    string
	Pivot interface{}
	Value interface{}
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Op    string
		Pivot interface{}
		Value interface{}
	}
	mock.lockLInsert.RLock()
	calls = mock.calls.LInsert
	mock.lockLInsert.RUnlock()
	return calls
}

// ResetLInsertCalls reset all the calls that were made to LInsert.
func (mock *MoqCmdable) ResetLInsertCalls() {
	mock.lockLInsert.Lock()
	mock.calls.LInsert = nil
	mock.lockLInsert.Unlock()
}

// LInsertAfter calls LInsertAfterFunc.
func (mock *MoqCmdable) LInsertAfter(ctx context.Context, key string, pivot interface{}, value interface{}) *redis.IntCmd {
	if mock.LInsertAfterFunc == nil {
		panic("MoqCmdable.LInsertAfterFunc: method is nil but Cmdable.LInsertAfter was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Pivot interface{}
		Value interface{}
	}{
		Ctx:   ctx,
		Key:   key,
		Pivot: pivot,
		Value: value,
	}
	mock.lockLInsertAfter.Lock()
	mock.calls.LInsertAfter = append(mock.calls.LInsertAfter, callInfo)
	mock.lockLInsertAfter.Unlock()
	return mock.LInsertAfterFunc(ctx, key, pivot, value)
}

// LInsertAfterCalls gets all the calls that were made to LInsertAfter.
// Check the length with:
//
//	len(mockedCmdable.LInsertAfterCalls())
func (mock *MoqCmdable) LInsertAfterCalls() []struct {
	Ctx   context.Context
	Key   string
	Pivot interface{}
	Value interface{}
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Pivot interface{}
		Value interface{}
	}
	mock.lockLInsertAfter.RLock()
	calls = mock.calls.LInsertAfter
	mock.lockLInsertAfter.RUnlock()
	return calls
}

// ResetLInsertAfterCalls reset all the calls that were made to LInsertAfter.
func (mock *MoqCmdable) ResetLInsertAfterCalls() {
	mock.lockLInsertAfter.Lock()
	mock.calls.LInsertAfter = nil
	mock.lockLInsertAfter.Unlock()
}

// LInsertBefore calls LInsertBeforeFunc.
func (mock *MoqCmdable) LInsertBefore(ctx context.Context, key string, pivot interface{}, value interface{}) *redis.IntCmd {
	if mock.LInsertBeforeFunc == nil {
		panic("MoqCmdable.LInsertBeforeFunc: method is nil but Cmdable.LInsertBefore was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Pivot interface{}
		Value interface{}
	}{
		Ctx:   ctx,
		Key:   key,
		Pivot: pivot,
		Value: value,
	}
	mock.lockLInsertBefore.Lock()
	mock.calls.LInsertBefore = append(mock.calls.LInsertBefore, callInfo)
	mock.lockLInsertBefore.Unlock()
	return mock.LInsertBeforeFunc(ctx, key, pivot, value)
}

// LInsertBeforeCalls gets all the calls that were made to LInsertBefore.
// Check the length with:
//
//	len(mockedCmdable.LInsertBeforeCalls())
func (mock *MoqCmdable) LInsertBeforeCalls() []struct {
	Ctx   context.Context
	Key   string
	Pivot interface{}
	Value interface{}
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Pivot interface{}
		Value interface{}
	}
	mock.lockLInsertBefore.RLock()
	calls = mock.calls.LInsertBefore
	mock.lockLInsertBefore.RUnlock()
	return calls
}

// ResetLInsertBeforeCalls reset all the calls that were made to LInsertBefore.
func (mock *MoqCmdable) ResetLInsertBeforeCalls() {
	mock.lockLInsertBefore.Lock()
	mock.calls.LInsertBefore = nil
	mock.lockLInsertBefore.Unlock()
}

// LLen calls LLenFunc.
func (mock *MoqCmdable) LLen(ctx context.Context, key string) *redis.IntCmd {
	if mock.LLenFunc == nil {
		panic("MoqCmdable.LLenFunc: method is nil but Cmdable.LLen was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockLLen.Lock()
	mock.calls.LLen = append(mock.calls.LLen, callInfo)
	mock.lockLLen.Unlock()
	return mock.LLenFunc(ctx, key)
}

// LLenCalls gets all the calls that were made to LLen.
// Check the length with:
//
//	len(mockedCmdable.LLenCalls())
func (mock *MoqCmdable) LLenCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockLLen.RLock()
	calls = mock.calls.LLen
	mock.lockLLen.RUnlock()
	return calls
}

// ResetLLenCalls reset all the calls that were made to LLen.
func (mock *MoqCmdable) ResetLLenCalls() {
	mock.lockLLen.Lock()
	mock.calls.LLen = nil
	mock.lockLLen.Unlock()
}

// LMPop calls LMPopFunc.
func (mock *MoqCmdable) LMPop(ctx context.Context, direction string, count int64, keys ...string) *redis.KeyValuesCmd {
	if mock.LMPopFunc == nil {
		panic("MoqCmdable.LMPopFunc: method is nil but Cmdable.LMPop was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Direction string
		Count     int64
		Keys      []string
	}{
		Ctx:       ctx,
		Direction: direction,
		Count:     count,
		Keys:      keys,
	}
	mock.lockLMPop.Lock()
	mock.calls.LMPop = append(mock.calls.LMPop, callInfo)
	mock.lockLMPop.Unlock()
	return mock.LMPopFunc(ctx, direction, count, keys...)
}

// LMPopCalls gets all the calls that were made to LMPop.
// Check the length with:
//
//	len(mockedCmdable.LMPopCalls())
func (mock *MoqCmdable) LMPopCalls() []struct {
	Ctx       context.Context
	Direction string
	Count     int64
	Keys      []string
} {
	var calls []struct {
		Ctx       context.Context
		Direction string
		Count     int64
		Keys      []string
	}
	mock.lockLMPop.RLock()
	calls = mock.calls.LMPop
	mock.lockLMPop.RUnlock()
	return calls
}

// ResetLMPopCalls reset all the calls that were made to LMPop.
func (mock *MoqCmdable) ResetLMPopCalls() {
	mock.lockLMPop.Lock()
	mock.calls.LMPop = nil
	mock.lockLMPop.Unlock()
}

// LMove calls LMoveFunc.
func (mock *MoqCmdable) LMove(ctx context.Context, source string, destination string, srcpos string, destpos string) *redis.StringCmd {
	if mock.LMoveFunc == nil {
		panic("MoqCmdable.LMoveFunc: method is nil but Cmdable.LMove was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		Source      string
		Destination string
		Srcpos      string
		Destpos     string
	}{
		Ctx:         ctx,
		Source:      source,
		Destination: destination,
		Srcpos:      srcpos,
		Destpos:     destpos,
	}
	mock.lockLMove.Lock()
	mock.calls.LMove = append(mock.calls.LMove, callInfo)
	mock.lockLMove.Unlock()
	return mock.LMoveFunc(ctx, source, destination, srcpos, destpos)
}

// LMoveCalls gets all the calls that were made to LMove.
// Check the length with:
//
//	len(mockedCmdable.LMoveCalls())
func (mock *MoqCmdable) LMoveCalls() []struct {
	Ctx         context.Context
	Source      string
	Destination string
	Srcpos      string
	Destpos     string
} {
	var calls []struct {
		Ctx         context.Context
		Source      string
		Destination string
		Srcpos      string
		Destpos     string
	}
	mock.lockLMove.RLock()
	calls = mock.calls.LMove
	mock.lockLMove.RUnlock()
	return calls
}

// ResetLMoveCalls reset all the calls that were made to LMove.
func (mock *MoqCmdable) ResetLMoveCalls() {
	mock.lockLMove.Lock()
	mock.calls.LMove = nil
	mock.lockLMove.Unlock()
}

// LPop calls LPopFunc.
func (mock *MoqCmdable) LPop(ctx context.Context, key string) *redis.StringCmd {
	if mock.LPopFunc == nil {
		panic("MoqCmdable.LPopFunc: method is nil but Cmdable.LPop was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockLPop.Lock()
	mock.calls.LPop = append(mock.calls.LPop, callInfo)
	mock.lockLPop.Unlock()
	return mock.LPopFunc(ctx, key)
}

// LPopCalls gets all the calls that were made to LPop.
// Check the length with:
//
//	len(mockedCmdable.LPopCalls())
func (mock *MoqCmdable) LPopCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockLPop.RLock()
	calls = mock.calls.LPop
	mock.lockLPop.RUnlock()
	return calls
}

// ResetLPopCalls reset all the calls that were made to LPop.
func (mock *MoqCmdable) ResetLPopCalls() {
	mock.lockLPop.Lock()
	mock.calls.LPop = nil
	mock.lockLPop.Unlock()
}

// LPopCount calls LPopCountFunc.
func (mock *MoqCmdable) LPopCount(ctx context.Context, key string, count int) *redis.StringSliceCmd {
	if mock.LPopCountFunc == nil {
		panic("MoqCmdable.LPopCountFunc: method is nil but Cmdable.LPopCount was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Count int
	}{
		Ctx:   ctx,
		Key:   key,
		Count: count,
	}
	mock.lockLPopCount.Lock()
	mock.calls.LPopCount = append(mock.calls.LPopCount, callInfo)
	mock.lockLPopCount.Unlock()
	return mock.LPopCountFunc(ctx, key, count)
}

// LPopCountCalls gets all the calls that were made to LPopCount.
// Check the length with:
//
//	len(mockedCmdable.LPopCountCalls())
func (mock *MoqCmdable) LPopCountCalls() []struct {
	Ctx   context.Context
	Key   string
	Count int
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Count int
	}
	mock.lockLPopCount.RLock()
	calls = mock.calls.LPopCount
	mock.lockLPopCount.RUnlock()
	return calls
}

// ResetLPopCountCalls reset all the calls that were made to LPopCount.
func (mock *MoqCmdable) ResetLPopCountCalls() {
	mock.lockLPopCount.Lock()
	mock.calls.LPopCount = nil
	mock.lockLPopCount.Unlock()
}

// LPos calls LPosFunc.
func (mock *MoqCmdable) LPos(ctx context.Context, key string, value string, args redis.LPosArgs) *redis.IntCmd {
	if mock.LPosFunc == nil {
		panic("MoqCmdable.LPosFunc: method is nil but Cmdable.LPos was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Value string
		Args  redis.LPosArgs
	}{
		Ctx:   ctx,
		Key:   key,
		Value: value,
		Args:  args,
	}
	mock.lockLPos.Lock()
	mock.calls.LPos = append(mock.calls.LPos, callInfo)
	mock.lockLPos.Unlock()
	return mock.LPosFunc(ctx, key, value, args)
}

// LPosCalls gets all the calls that were made to LPos.
// Check the length with:
//
//	len(mockedCmdable.LPosCalls())
func (mock *MoqCmdable) LPosCalls() []struct {
	Ctx   context.Context
	Key   string
	Value string
	Args  redis.LPosArgs
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Value string
		Args  redis.LPosArgs
	}
	mock.lockLPos.RLock()
	calls = mock.calls.LPos
	mock.lockLPos.RUnlock()
	return calls
}

// ResetLPosCalls reset all the calls that were made to LPos.
func (mock *MoqCmdable) ResetLPosCalls() {
	mock.lockLPos.Lock()
	mock.calls.LPos = nil
	mock.lockLPos.Unlock()
}

// LPosCount calls LPosCountFunc.
func (mock *MoqCmdable) LPosCount(ctx context.Context, key string, value string, count int64, args redis.LPosArgs) *redis.IntSliceCmd {
	if mock.LPosCountFunc == nil {
		panic("MoqCmdable.LPosCountFunc: method is nil but Cmdable.LPosCount was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Value string
		Count int64
		Args  redis.LPosArgs
	}{
		Ctx:   ctx,
		Key:   key,
		Value: value,
		Count: count,
		Args:  args,
	}
	mock.lockLPosCount.Lock()
	mock.calls.LPosCount = append(mock.calls.LPosCount, callInfo)
	mock.lockLPosCount.Unlock()
	return mock.LPosCountFunc(ctx, key, value, count, args)
}

// LPosCountCalls gets all the calls that were made to LPosCount.
// Check the length with:
//
//	len(mockedCmdable.LPosCountCalls())
func (mock *MoqCmdable) LPosCountCalls() []struct {
	Ctx   context.Context
	Key   string
	Value string
	Count int64
	Args  redis.LPosArgs
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Value string
		Count int64
		Args  redis.LPosArgs
	}
	mock.lockLPosCount.RLock()
	calls = mock.calls.LPosCount
	mock.lockLPosCount.RUnlock()
	return calls
}

// ResetLPosCountCalls reset all the calls that were made to LPosCount.
func (mock *MoqCmdable) ResetLPosCountCalls() {
	mock.lockLPosCount.Lock()
	mock.calls.LPosCount = nil
	mock.lockLPosCount.Unlock()
}

// LPush calls LPushFunc.
func (mock *MoqCmdable) LPush(ctx context.Context, key string, values ...interface{}) *redis.IntCmd {
	if mock.LPushFunc == nil {
		panic("MoqCmdable.LPushFunc: method is nil but Cmdable.LPush was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		Values []interface{}
	}{
		Ctx:    ctx,
		Key:    key,
		Values: values,
	}
	mock.lockLPush.Lock()
	mock.calls.LPush = append(mock.calls.LPush, callInfo)
	mock.lockLPush.Unlock()
	return mock.LPushFunc(ctx, key, values...)
}

// LPushCalls gets all the calls that were made to LPush.
// Check the length with:
//
//	len(mockedCmdable.LPushCalls())
func (mock *MoqCmdable) LPushCalls() []struct {
	Ctx    context.Context
	Key    string
	Values []interface{}
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		Values []interface{}
	}
	mock.lockLPush.RLock()
	calls = mock.calls.LPush
	mock.lockLPush.RUnlock()
	return calls
}

// ResetLPushCalls reset all the calls that were made to LPush.
func (mock *MoqCmdable) ResetLPushCalls() {
	mock.lockLPush.Lock()
	mock.calls.LPush = nil
	mock.lockLPush.Unlock()
}

// LPushX calls LPushXFunc.
func (mock *MoqCmdable) LPushX(ctx context.Context, key string, values ...interface{}) *redis.IntCmd {
	if mock.LPushXFunc == nil {
		panic("MoqCmdable.LPushXFunc: method is nil but Cmdable.LPushX was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		Values []interface{}
	}{
		Ctx:    ctx,
		Key:    key,
		Values: values,
	}
	mock.lockLPushX.Lock()
	mock.calls.LPushX = append(mock.calls.LPushX, callInfo)
	mock.lockLPushX.Unlock()
	return mock.LPushXFunc(ctx, key, values...)
}

// LPushXCalls gets all the calls that were made to LPushX.
// Check the length with:
//
//	len(mockedCmdable.LPushXCalls())
func (mock *MoqCmdable) LPushXCalls() []struct {
	Ctx    context.Context
	Key    string
	Values []interface{}
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		Values []interface{}
	}
	mock.lockLPushX.RLock()
	calls = mock.calls.LPushX
	mock.lockLPushX.RUnlock()
	return calls
}

// ResetLPushXCalls reset all the calls that were made to LPushX.
func (mock *MoqCmdable) ResetLPushXCalls() {
	mock.lockLPushX.Lock()
	mock.calls.LPushX = nil
	mock.lockLPushX.Unlock()
}

// LRange calls LRangeFunc.
func (mock *MoqCmdable) LRange(ctx context.Context, key string, start int64, stop int64) *redis.StringSliceCmd {
	if mock.LRangeFunc == nil {
		panic("MoqCmdable.LRangeFunc: method is nil but Cmdable.LRange was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Start int64
		Stop  int64
	}{
		Ctx:   ctx,
		Key:   key,
		Start: start,
		Stop:  stop,
	}
	mock.lockLRange.Lock()
	mock.calls.LRange = append(mock.calls.LRange, callInfo)
	mock.lockLRange.Unlock()
	return mock.LRangeFunc(ctx, key, start, stop)
}

// LRangeCalls gets all the calls that were made to LRange.
// Check the length with:
//
//	len(mockedCmdable.LRangeCalls())
func (mock *MoqCmdable) LRangeCalls() []struct {
	Ctx   context.Context
	Key   string
	Start int64
	Stop  int64
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Start int64
		Stop  int64
	}
	mock.lockLRange.RLock()
	calls = mock.calls.LRange
	mock.lockLRange.RUnlock()
	return calls
}

// ResetLRangeCalls reset all the calls that were made to LRange.
func (mock *MoqCmdable) ResetLRangeCalls() {
	mock.lockLRange.Lock()
	mock.calls.LRange = nil
	mock.lockLRange.Unlock()
}

// LRem calls LRemFunc.
func (mock *MoqCmdable) LRem(ctx context.Context, key string, count int64, value interface{}) *redis.IntCmd {
	if mock.LRemFunc == nil {
		panic("MoqCmdable.LRemFunc: method is nil but Cmdable.LRem was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Count int64
		Value interface{}
	}{
		Ctx:   ctx,
		Key:   key,
		Count: count,
		Value: value,
	}
	mock.lockLRem.Lock()
	mock.calls.LRem = append(mock.calls.LRem, callInfo)
	mock.lockLRem.Unlock()
	return mock.LRemFunc(ctx, key, count, value)
}

// LRemCalls gets all the calls that were made to LRem.
// Check the length with:
//
//	len(mockedCmdable.LRemCalls())
func (mock *MoqCmdable) LRemCalls() []struct {
	Ctx   context.Context
	Key   string
	Count int64
	Value interface{}
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Count int64
		Value interface{}
	}
	mock.lockLRem.RLock()
	calls = mock.calls.LRem
	mock.lockLRem.RUnlock()
	return calls
}

// ResetLRemCalls reset all the calls that were made to LRem.
func (mock *MoqCmdable) ResetLRemCalls() {
	mock.lockLRem.Lock()
	mock.calls.LRem = nil
	mock.lockLRem.Unlock()
}

// LSet calls LSetFunc.
func (mock *MoqCmdable) LSet(ctx context.Context, key string, index int64, value interface{}) *redis.StatusCmd {
	if mock.LSetFunc == nil {
		panic("MoqCmdable.LSetFunc: method is nil but Cmdable.LSet was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Index int64
		Value interface{}
	}{
		Ctx:   ctx,
		Key:   key,
		Index: index,
		Value: value,
	}
	mock.lockLSet.Lock()
	mock.calls.LSet = append(mock.calls.LSet, callInfo)
	mock.lockLSet.Unlock()
	return mock.LSetFunc(ctx, key, index, value)
}

// LSetCalls gets all the calls that were made to LSet.
// Check the length with:
//
//	len(mockedCmdable.LSetCalls())
func (mock *MoqCmdable) LSetCalls() []struct {
	Ctx   context.Context
	Key   string
	Index int64
	Value interface{}
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Index int64
		Value interface{}
	}
	mock.lockLSet.RLock()
	calls = mock.calls.LSet
	mock.lockLSet.RUnlock()
	return calls
}

// ResetLSetCalls reset all the calls that were made to LSet.
func (mock *MoqCmdable) ResetLSetCalls() {
	mock.lockLSet.Lock()
	mock.calls.LSet = nil
	mock.lockLSet.Unlock()
}

// LTrim calls LTrimFunc.
func (mock *MoqCmdable) LTrim(ctx context.Context, key string, start int64, stop int64) *redis.StatusCmd {
	if mock.LTrimFunc == nil {
		panic("MoqCmdable.LTrimFunc: method is nil but Cmdable.LTrim was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Start int64
		Stop  int64
	}{
		Ctx:   ctx,
		Key:   key,
		Start: start,
		Stop:  stop,
	}
	mock.lockLTrim.Lock()
	mock.calls.LTrim = append(mock.calls.LTrim, callInfo)
	mock.lockLTrim.Unlock()
	return mock.LTrimFunc(ctx, key, start, stop)
}

// LTrimCalls gets all the calls that were made to LTrim.
// Check the length with:
//
//	len(mockedCmdable.LTrimCalls())
func (mock *MoqCmdable) LTrimCalls() []struct {
	Ctx   context.Context
	Key   string
	Start int64
	Stop  int64
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Start int64
		Stop  int64
	}
	mock.lockLTrim.RLock()
	calls = mock.calls.LTrim
	mock.lockLTrim.RUnlock()
	return calls
}

// ResetLTrimCalls reset all the calls that were made to LTrim.
func (mock *MoqCmdable) ResetLTrimCalls() {
	mock.lockLTrim.Lock()
	mock.calls.LTrim = nil
	mock.lockLTrim.Unlock()
}

// LastSave calls LastSaveFunc.
func (mock *MoqCmdable) LastSave(ctx context.Context) *redis.IntCmd {
	if mock.LastSaveFunc == nil {
		panic("MoqCmdable.LastSaveFunc: method is nil but Cmdable.LastSave was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockLastSave.Lock()
	mock.calls.LastSave = append(mock.calls.LastSave, callInfo)
	mock.lockLastSave.Unlock()
	return mock.LastSaveFunc(ctx)
}

// LastSaveCalls gets all the calls that were made to LastSave.
// Check the length with:
//
//	len(mockedCmdable.LastSaveCalls())
func (mock *MoqCmdable) LastSaveCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockLastSave.RLock()
	calls = mock.calls.LastSave
	mock.lockLastSave.RUnlock()
	return calls
}

// ResetLastSaveCalls reset all the calls that were made to LastSave.
func (mock *MoqCmdable) ResetLastSaveCalls() {
	mock.lockLastSave.Lock()
	mock.calls.LastSave = nil
	mock.lockLastSave.Unlock()
}

// Latency calls LatencyFunc.
func (mock *MoqCmdable) Latency(ctx context.Context) *redis.LatencyCmd {
	if mock.LatencyFunc == nil {
		panic("MoqCmdable.LatencyFunc: method is nil but Cmdable.Latency was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockLatency.Lock()
	mock.calls.Latency = append(mock.calls.Latency, callInfo)
	mock.lockLatency.Unlock()
	return mock.LatencyFunc(ctx)
}

// LatencyCalls gets all the calls that were made to Latency.
// Check the length with:
//
//	len(mockedCmdable.LatencyCalls())
func (mock *MoqCmdable) LatencyCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockLatency.RLock()
	calls = mock.calls.Latency
	mock.lockLatency.RUnlock()
	return calls
}

// ResetLatencyCalls reset all the calls that were made to Latency.
func (mock *MoqCmdable) ResetLatencyCalls() {
	mock.lockLatency.Lock()
	mock.calls.Latency = nil
	mock.lockLatency.Unlock()
}

// LatencyReset calls LatencyResetFunc.
func (mock *MoqCmdable) LatencyReset(ctx context.Context, events ...interface{}) *redis.StatusCmd {
	if mock.LatencyResetFunc == nil {
		panic("MoqCmdable.LatencyResetFunc: method is nil but Cmdable.LatencyReset was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Events []interface{}
	}{
		Ctx:    ctx,
		Events: events,
	}
	mock.lockLatencyReset.Lock()
	mock.calls.LatencyReset = append(mock.calls.LatencyReset, callInfo)
	mock.lockLatencyReset.Unlock()
	return mock.LatencyResetFunc(ctx, events...)
}

// LatencyResetCalls gets all the calls that were made to LatencyReset.
// Check the length with:
//
//	len(mockedCmdable.LatencyResetCalls())
func (mock *MoqCmdable) LatencyResetCalls() []struct {
	Ctx    context.Context
	Events []interface{}
} {
	var calls []struct {
		Ctx    context.Context
		Events []interface{}
	}
	mock.lockLatencyReset.RLock()
	calls = mock.calls.LatencyReset
	mock.lockLatencyReset.RUnlock()
	return calls
}

// ResetLatencyResetCalls reset all the calls that were made to LatencyReset.
func (mock *MoqCmdable) ResetLatencyResetCalls() {
	mock.lockLatencyReset.Lock()
	mock.calls.LatencyReset = nil
	mock.lockLatencyReset.Unlock()
}

// MGet calls MGetFunc.
func (mock *MoqCmdable) MGet(ctx context.Context, keys ...string) *redis.SliceCmd {
	if mock.MGetFunc == nil {
		panic("MoqCmdable.MGetFunc: method is nil but Cmdable.MGet was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Keys []string
	}{
		Ctx:  ctx,
		Keys: keys,
	}
	mock.lockMGet.Lock()
	mock.calls.MGet = append(mock.calls.MGet, callInfo)
	mock.lockMGet.Unlock()
	return mock.MGetFunc(ctx, keys...)
}

// MGetCalls gets all the calls that were made to MGet.
// Check the length with:
//
//	len(mockedCmdable.MGetCalls())
func (mock *MoqCmdable) MGetCalls() []struct {
	Ctx  context.Context
	Keys []string
} {
	var calls []struct {
		Ctx  context.Context
		Keys []string
	}
	mock.lockMGet.RLock()
	calls = mock.calls.MGet
	mock.lockMGet.RUnlock()
	return calls
}

// ResetMGetCalls reset all the calls that were made to MGet.
func (mock *MoqCmdable) ResetMGetCalls() {
	mock.lockMGet.Lock()
	mock.calls.MGet = nil
	mock.lockMGet.Unlock()
}

// MSet calls MSetFunc.
func (mock *MoqCmdable) MSet(ctx context.Context, values ...interface{}) *redis.StatusCmd {
	if mock.MSetFunc == nil {
		panic("MoqCmdable.MSetFunc: method is nil but Cmdable.MSet was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Values []interface{}
	}{
		Ctx:    ctx,
		Values: values,
	}
	mock.lockMSet.Lock()
	mock.calls.MSet = append(mock.calls.MSet, callInfo)
	mock.lockMSet.Unlock()
	return mock.MSetFunc(ctx, values...)
}

// MSetCalls gets all the calls that were made to MSet.
// Check the length with:
//
//	len(mockedCmdable.MSetCalls())
func (mock *MoqCmdable) MSetCalls() []struct {
	Ctx    context.Context
	Values []interface{}
} {
	var calls []struct {
		Ctx    context.Context
		Values []interface{}
	}
	mock.lockMSet.RLock()
	calls = mock.calls.MSet
	mock.lockMSet.RUnlock()
	return calls
}

// ResetMSetCalls reset all the calls that were made to MSet.
func (mock *MoqCmdable) ResetMSetCalls() {
	mock.lockMSet.Lock()
	mock.calls.MSet = nil
	mock.lockMSet.Unlock()
}

// MSetEX calls MSetEXFunc.
func (mock *MoqCmdable) MSetEX(ctx context.Context, args redis.MSetEXArgs, values ...interface{}) *redis.IntCmd {
	if mock.MSetEXFunc == nil {
		panic("MoqCmdable.MSetEXFunc: method is nil but Cmdable.MSetEX was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Args   redis.MSetEXArgs
		Values []interface{}
	}{
		Ctx:    ctx,
		Args:   args,
		Values: values,
	}
	mock.lockMSetEX.Lock()
	mock.calls.MSetEX = append(mock.calls.MSetEX, callInfo)
	mock.lockMSetEX.Unlock()
	return mock.MSetEXFunc(ctx, args, values...)
}

// MSetEXCalls gets all the calls that were made to MSetEX.
// Check the length with:
//
//	len(mockedCmdable.MSetEXCalls())
func (mock *MoqCmdable) MSetEXCalls() []struct {
	Ctx    context.Context
	Args   redis.MSetEXArgs
	Values []interface{}
} {
	var calls []struct {
		Ctx    context.Context
		Args   redis.MSetEXArgs
		Values []interface{}
	}
	mock.lockMSetEX.RLock()
	calls = mock.calls.MSetEX
	mock.lockMSetEX.RUnlock()
	return calls
}

// ResetMSetEXCalls reset all the calls that were made to MSetEX.
func (mock *MoqCmdable) ResetMSetEXCalls() {
	mock.lockMSetEX.Lock()
	mock.calls.MSetEX = nil
	mock.lockMSetEX.Unlock()
}

// MSetNX calls MSetNXFunc.
func (mock *MoqCmdable) MSetNX(ctx context.Context, values ...interface{}) *redis.BoolCmd {
	if mock.MSetNXFunc == nil {
		panic("MoqCmdable.MSetNXFunc: method is nil but Cmdable.MSetNX was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Values []interface{}
	}{
		Ctx:    ctx,
		Values: values,
	}
	mock.lockMSetNX.Lock()
	mock.calls.MSetNX = append(mock.calls.MSetNX, callInfo)
	mock.lockMSetNX.Unlock()
	return mock.MSetNXFunc(ctx, values...)
}

// MSetNXCalls gets all the calls that were made to MSetNX.
// Check the length with:
//
//	len(mockedCmdable.MSetNXCalls())
func (mock *MoqCmdable) MSetNXCalls() []struct {
	Ctx    context.Context
	Values []interface{}
} {
	var calls []struct {
		Ctx    context.Context
		Values []interface{}
	}
	mock.lockMSetNX.RLock()
	calls = mock.calls.MSetNX
	mock.lockMSetNX.RUnlock()
	return calls
}

// ResetMSetNXCalls reset all the calls that were made to MSetNX.
func (mock *MoqCmdable) ResetMSetNXCalls() {
	mock.lockMSetNX.Lock()
	mock.calls.MSetNX = nil
	mock.lockMSetNX.Unlock()
}

// MemoryUsage calls MemoryUsageFunc.
func (mock *MoqCmdable) MemoryUsage(ctx context.Context, key string, samples ...int) *redis.IntCmd {
	if mock.MemoryUsageFunc == nil {
		panic("MoqCmdable.MemoryUsageFunc: method is nil but Cmdable.MemoryUsage was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Key     string
		Samples []int
	}{
		Ctx:     ctx,
		Key:     key,
		Samples: samples,
	}
	mock.lockMemoryUsage.Lock()
	mock.calls.MemoryUsage = append(mock.calls.MemoryUsage, callInfo)
	mock.lockMemoryUsage.Unlock()
	return mock.MemoryUsageFunc(ctx, key, samples...)
}

// MemoryUsageCalls gets all the calls that were made to MemoryUsage.
// Check the length with:
//
//	len(mockedCmdable.MemoryUsageCalls())
func (mock *MoqCmdable) MemoryUsageCalls() []struct {
	Ctx     context.Context
	Key     string
	Samples []int
} {
	var calls []struct {
		Ctx     context.Context
		Key     string
		Samples []int
	}
	mock.lockMemoryUsage.RLock()
	calls = mock.calls.MemoryUsage
	mock.lockMemoryUsage.RUnlock()
	return calls
}

// ResetMemoryUsageCalls reset all the calls that were made to MemoryUsage.
func (mock *MoqCmdable) ResetMemoryUsageCalls() {
	mock.lockMemoryUsage.Lock()
	mock.calls.MemoryUsage = nil
	mock.lockMemoryUsage.Unlock()
}

// Migrate calls MigrateFunc.
func (mock *MoqCmdable) Migrate(ctx context.Context, host string, port string, key string, db int, timeout time.Duration) *redis.StatusCmd {
	if mock.MigrateFunc == nil {
		panic("MoqCmdable.MigrateFunc: method is nil but Cmdable.Migrate was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Host    string
		Port    string
		Key     string
		Db      int
		Timeout time.Duration
	}{
		Ctx:     ctx,
		Host:    host,
		Port:    port,
		Key:     key,
		Db:      db,
		Timeout: timeout,
	}
	mock.lockMigrate.Lock()
	mock.calls.Migrate = append(mock.calls.Migrate, callInfo)
	mock.lockMigrate.Unlock()
	return mock.MigrateFunc(ctx, host, port, key, db, timeout)
}

// MigrateCalls gets all the calls that were made to Migrate.
// Check the length with:
//
//	len(mockedCmdable.MigrateCalls())
func (mock *MoqCmdable) MigrateCalls() []struct {
	Ctx     context.Context
	Host    string
	Port    string
	Key     string
	Db      int
	Timeout time.Duration
} {
	var calls []struct {
		Ctx     context.Context
		Host    string
		Port    string
		Key     string
		Db      int
		Timeout time.Duration
	}
	mock.lockMigrate.RLock()
	calls = mock.calls.Migrate
	mock.lockMigrate.RUnlock()
	return calls
}

// ResetMigrateCalls reset all the calls that were made to Migrate.
func (mock *MoqCmdable) ResetMigrateCalls() {
	mock.lockMigrate.Lock()
	mock.calls.Migrate = nil
	mock.lockMigrate.Unlock()
}

// ModuleLoadex calls ModuleLoadexFunc.
func (mock *MoqCmdable) ModuleLoadex(ctx context.Context, conf *redis.ModuleLoadexConfig) *redis.StringCmd {
	if mock.ModuleLoadexFunc == nil {
		panic("MoqCmdable.ModuleLoadexFunc: method is nil but Cmdable.ModuleLoadex was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Conf *redis.ModuleLoadexConfig
	}{
		Ctx:  ctx,
		Conf: conf,
	}
	mock.lockModuleLoadex.Lock()
	mock.calls.ModuleLoadex = append(mock.calls.ModuleLoadex, callInfo)
	mock.lockModuleLoadex.Unlock()
	return mock.ModuleLoadexFunc(ctx, conf)
}

// ModuleLoadexCalls gets all the calls that were made to ModuleLoadex.
// Check the length with:
//
//	len(mockedCmdable.ModuleLoadexCalls())
func (mock *MoqCmdable) ModuleLoadexCalls() []struct {
	Ctx  context.Context
	Conf *redis.ModuleLoadexConfig
} {
	var calls []struct {
		Ctx  context.Context
		Conf *redis.ModuleLoadexConfig
	}
	mock.lockModuleLoadex.RLock()
	calls = mock.calls.ModuleLoadex
	mock.lockModuleLoadex.RUnlock()
	return calls
}

// ResetModuleLoadexCalls reset all the calls that were made to ModuleLoadex.
func (mock *MoqCmdable) ResetModuleLoadexCalls() {
	mock.lockModuleLoadex.Lock()
	mock.calls.ModuleLoadex = nil
	mock.lockModuleLoadex.Unlock()
}

// Move calls MoveFunc.
func (mock *MoqCmdable) Move(ctx context.Context, key string, db int) *redis.BoolCmd {
	if mock.MoveFunc == nil {
		panic("MoqCmdable.MoveFunc: method is nil but Cmdable.Move was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
		Db  int
	}{
		Ctx: ctx,
		Key: key,
		Db:  db,
	}
	mock.lockMove.Lock()
	mock.calls.Move = append(mock.calls.Move, callInfo)
	mock.lockMove.Unlock()
	return mock.MoveFunc(ctx, key, db)
}

// MoveCalls gets all the calls that were made to Move.
// Check the length with:
//
//	len(mockedCmdable.MoveCalls())
func (mock *MoqCmdable) MoveCalls() []struct {
	Ctx context.Context
	Key string
	Db  int
} {
	var calls []struct {
		Ctx context.Context
		Key string
		Db  int
	}
	mock.lockMove.RLock()
	calls = mock.calls.Move
	mock.lockMove.RUnlock()
	return calls
}

// ResetMoveCalls reset all the calls that were made to Move.
func (mock *MoqCmdable) ResetMoveCalls() {
	mock.lockMove.Lock()
	mock.calls.Move = nil
	mock.lockMove.Unlock()
}

// ObjectEncoding calls ObjectEncodingFunc.
func (mock *MoqCmdable) ObjectEncoding(ctx context.Context, key string) *redis.StringCmd {
	if mock.ObjectEncodingFunc == nil {
		panic("MoqCmdable.ObjectEncodingFunc: method is nil but Cmdable.ObjectEncoding was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockObjectEncoding.Lock()
	mock.calls.ObjectEncoding = append(mock.calls.ObjectEncoding, callInfo)
	mock.lockObjectEncoding.Unlock()
	return mock.ObjectEncodingFunc(ctx, key)
}

// ObjectEncodingCalls gets all the calls that were made to ObjectEncoding.
// Check the length with:
//
//	len(mockedCmdable.ObjectEncodingCalls())
func (mock *MoqCmdable) ObjectEncodingCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockObjectEncoding.RLock()
	calls = mock.calls.ObjectEncoding
	mock.lockObjectEncoding.RUnlock()
	return calls
}

// ResetObjectEncodingCalls reset all the calls that were made to ObjectEncoding.
func (mock *MoqCmdable) ResetObjectEncodingCalls() {
	mock.lockObjectEncoding.Lock()
	mock.calls.ObjectEncoding = nil
	mock.lockObjectEncoding.Unlock()
}

// ObjectFreq calls ObjectFreqFunc.
func (mock *MoqCmdable) ObjectFreq(ctx context.Context, key string) *redis.IntCmd {
	if mock.ObjectFreqFunc == nil {
		panic("MoqCmdable.ObjectFreqFunc: method is nil but Cmdable.ObjectFreq was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockObjectFreq.Lock()
	mock.calls.ObjectFreq = append(mock.calls.ObjectFreq, callInfo)
	mock.lockObjectFreq.Unlock()
	return mock.ObjectFreqFunc(ctx, key)
}

// ObjectFreqCalls gets all the calls that were made to ObjectFreq.
// Check the length with:
//
//	len(mockedCmdable.ObjectFreqCalls())
func (mock *MoqCmdable) ObjectFreqCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockObjectFreq.RLock()
	calls = mock.calls.ObjectFreq
	mock.lockObjectFreq.RUnlock()
	return calls
}

// ResetObjectFreqCalls reset all the calls that were made to ObjectFreq.
func (mock *MoqCmdable) ResetObjectFreqCalls() {
	mock.lockObjectFreq.Lock()
	mock.calls.ObjectFreq = nil
	mock.lockObjectFreq.Unlock()
}

// ObjectIdleTime calls ObjectIdleTimeFunc.
func (mock *MoqCmdable) ObjectIdleTime(ctx context.Context, key string) *redis.DurationCmd {
	if mock.ObjectIdleTimeFunc == nil {
		panic("MoqCmdable.ObjectIdleTimeFunc: method is nil but Cmdable.ObjectIdleTime was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockObjectIdleTime.Lock()
	mock.calls.ObjectIdleTime = append(mock.calls.ObjectIdleTime, callInfo)
	mock.lockObjectIdleTime.Unlock()
	return mock.ObjectIdleTimeFunc(ctx, key)
}

// ObjectIdleTimeCalls gets all the calls that were made to ObjectIdleTime.
// Check the length with:
//
//	len(mockedCmdable.ObjectIdleTimeCalls())
func (mock *MoqCmdable) ObjectIdleTimeCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockObjectIdleTime.RLock()
	calls = mock.calls.ObjectIdleTime
	mock.lockObjectIdleTime.RUnlock()
	return calls
}

// ResetObjectIdleTimeCalls reset all the calls that were made to ObjectIdleTime.
func (mock *MoqCmdable) ResetObjectIdleTimeCalls() {
	mock.lockObjectIdleTime.Lock()
	mock.calls.ObjectIdleTime = nil
	mock.lockObjectIdleTime.Unlock()
}

// ObjectRefCount calls ObjectRefCountFunc.
func (mock *MoqCmdable) ObjectRefCount(ctx context.Context, key string) *redis.IntCmd {
	if mock.ObjectRefCountFunc == nil {
		panic("MoqCmdable.ObjectRefCountFunc: method is nil but Cmdable.ObjectRefCount was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockObjectRefCount.Lock()
	mock.calls.ObjectRefCount = append(mock.calls.ObjectRefCount, callInfo)
	mock.lockObjectRefCount.Unlock()
	return mock.ObjectRefCountFunc(ctx, key)
}

// ObjectRefCountCalls gets all the calls that were made to ObjectRefCount.
// Check the length with:
//
//	len(mockedCmdable.ObjectRefCountCalls())
func (mock *MoqCmdable) ObjectRefCountCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockObjectRefCount.RLock()
	calls = mock.calls.ObjectRefCount
	mock.lockObjectRefCount.RUnlock()
	return calls
}

// ResetObjectRefCountCalls reset all the calls that were made to ObjectRefCount.
func (mock *MoqCmdable) ResetObjectRefCountCalls() {
	mock.lockObjectRefCount.Lock()
	mock.calls.ObjectRefCount = nil
	mock.lockObjectRefCount.Unlock()
}

// PExpire calls PExpireFunc.
func (mock *MoqCmdable) PExpire(ctx context.Context, key string, expiration time.Duration) *redis.BoolCmd {
	if mock.PExpireFunc == nil {
		panic("MoqCmdable.PExpireFunc: method is nil but Cmdable.PExpire was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Key        string
		Expiration time.Duration
	}{
		Ctx:        ctx,
		Key:        key,
		Expiration: expiration,
	}
	mock.lockPExpire.Lock()
	mock.calls.PExpire = append(mock.calls.PExpire, callInfo)
	mock.lockPExpire.Unlock()
	return mock.PExpireFunc(ctx, key, expiration)
}

// PExpireCalls gets all the calls that were made to PExpire.
// Check the length with:
//
//	len(mockedCmdable.PExpireCalls())
func (mock *MoqCmdable) PExpireCalls() []struct {
	Ctx        context.Context
	Key        string
	Expiration time.Duration
} {
	var calls []struct {
		Ctx        context.Context
		Key        string
		Expiration time.Duration
	}
	mock.lockPExpire.RLock()
	calls = mock.calls.PExpire
	mock.lockPExpire.RUnlock()
	return calls
}

// ResetPExpireCalls reset all the calls that were made to PExpire.
func (mock *MoqCmdable) ResetPExpireCalls() {
	mock.lockPExpire.Lock()
	mock.calls.PExpire = nil
	mock.lockPExpire.Unlock()
}

// PExpireAt calls PExpireAtFunc.
func (mock *MoqCmdable) PExpireAt(ctx context.Context, key string, tm time.Time) *redis.BoolCmd {
	if mock.PExpireAtFunc == nil {
		panic("MoqCmdable.PExpireAtFunc: method is nil but Cmdable.PExpireAt was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
		Tm  time.Time
	}{
		Ctx: ctx,
		Key: key,
		Tm:  tm,
	}
	mock.lockPExpireAt.Lock()
	mock.calls.PExpireAt = append(mock.calls.PExpireAt, callInfo)
	mock.lockPExpireAt.Unlock()
	return mock.PExpireAtFunc(ctx, key, tm)
}

// PExpireAtCalls gets all the calls that were made to PExpireAt.
// Check the length with:
//
//	len(mockedCmdable.PExpireAtCalls())
func (mock *MoqCmdable) PExpireAtCalls() []struct {
	Ctx context.Context
	Key string
	Tm  time.Time
} {
	var calls []struct {
		Ctx context.Context
		Key string
		Tm  time.Time
	}
	mock.lockPExpireAt.RLock()
	calls = mock.calls.PExpireAt
	mock.lockPExpireAt.RUnlock()
	return calls
}

// ResetPExpireAtCalls reset all the calls that were made to PExpireAt.
func (mock *MoqCmdable) ResetPExpireAtCalls() {
	mock.lockPExpireAt.Lock()
	mock.calls.PExpireAt = nil
	mock.lockPExpireAt.Unlock()
}

// PExpireTime calls PExpireTimeFunc.
func (mock *MoqCmdable) PExpireTime(ctx context.Context, key string) *redis.DurationCmd {
	if mock.PExpireTimeFunc == nil {
		panic("MoqCmdable.PExpireTimeFunc: method is nil but Cmdable.PExpireTime was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockPExpireTime.Lock()
	mock.calls.PExpireTime = append(mock.calls.PExpireTime, callInfo)
	mock.lockPExpireTime.Unlock()
	return mock.PExpireTimeFunc(ctx, key)
}

// PExpireTimeCalls gets all the calls that were made to PExpireTime.
// Check the length with:
//
//	len(mockedCmdable.PExpireTimeCalls())
func (mock *MoqCmdable) PExpireTimeCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockPExpireTime.RLock()
	calls = mock.calls.PExpireTime
	mock.lockPExpireTime.RUnlock()
	return calls
}

// ResetPExpireTimeCalls reset all the calls that were made to PExpireTime.
func (mock *MoqCmdable) ResetPExpireTimeCalls() {
	mock.lockPExpireTime.Lock()
	mock.calls.PExpireTime = nil
	mock.lockPExpireTime.Unlock()
}

// PFAdd calls PFAddFunc.
func (mock *MoqCmdable) PFAdd(ctx context.Context, key string, els ...interface{}) *redis.IntCmd {
	if mock.PFAddFunc == nil {
		panic("MoqCmdable.PFAddFunc: method is nil but Cmdable.PFAdd was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
		Els []interface{}
	}{
		Ctx: ctx,
		Key: key,
		Els: els,
	}
	mock.lockPFAdd.Lock()
	mock.calls.PFAdd = append(mock.calls.PFAdd, callInfo)
	mock.lockPFAdd.Unlock()
	return mock.PFAddFunc(ctx, key, els...)
}

// PFAddCalls gets all the calls that were made to PFAdd.
// Check the length with:
//
//	len(mockedCmdable.PFAddCalls())
func (mock *MoqCmdable) PFAddCalls() []struct {
	Ctx context.Context
	Key string
	Els []interface{}
} {
	var calls []struct {
		Ctx context.Context
		Key string
		Els []interface{}
	}
	mock.lockPFAdd.RLock()
	calls = mock.calls.PFAdd
	mock.lockPFAdd.RUnlock()
	return calls
}

// ResetPFAddCalls reset all the calls that were made to PFAdd.
func (mock *MoqCmdable) ResetPFAddCalls() {
	mock.lockPFAdd.Lock()
	mock.calls.PFAdd = nil
	mock.lockPFAdd.Unlock()
}

// PFCount calls PFCountFunc.
func (mock *MoqCmdable) PFCount(ctx context.Context, keys ...string) *redis.IntCmd {
	if mock.PFCountFunc == nil {
		panic("MoqCmdable.PFCountFunc: method is nil but Cmdable.PFCount was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Keys []string
	}{
		Ctx:  ctx,
		Keys: keys,
	}
	mock.lockPFCount.Lock()
	mock.calls.PFCount = append(mock.calls.PFCount, callInfo)
	mock.lockPFCount.Unlock()
	return mock.PFCountFunc(ctx, keys...)
}

// PFCountCalls gets all the calls that were made to PFCount.
// Check the length with:
//
//	len(mockedCmdable.PFCountCalls())
func (mock *MoqCmdable) PFCountCalls() []struct {
	Ctx  context.Context
	Keys []string
} {
	var calls []struct {
		Ctx  context.Context
		Keys []string
	}
	mock.lockPFCount.RLock()
	calls = mock.calls.PFCount
	mock.lockPFCount.RUnlock()
	return calls
}

// ResetPFCountCalls reset all the calls that were made to PFCount.
func (mock *MoqCmdable) ResetPFCountCalls() {
	mock.lockPFCount.Lock()
	mock.calls.PFCount = nil
	mock.lockPFCount.Unlock()
}

// PFMerge calls PFMergeFunc.
func (mock *MoqCmdable) PFMerge(ctx context.Context, dest string, keys ...string) *redis.StatusCmd {
	if mock.PFMergeFunc == nil {
		panic("MoqCmdable.PFMergeFunc: method is nil but Cmdable.PFMerge was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Dest string
		Keys []string
	}{
		Ctx:  ctx,
		Dest: dest,
		Keys: keys,
	}
	mock.lockPFMerge.Lock()
	mock.calls.PFMerge = append(mock.calls.PFMerge, callInfo)
	mock.lockPFMerge.Unlock()
	return mock.PFMergeFunc(ctx, dest, keys...)
}

// PFMergeCalls gets all the calls that were made to PFMerge.
// Check the length with:
//
//	len(mockedCmdable.PFMergeCalls())
func (mock *MoqCmdable) PFMergeCalls() []struct {
	Ctx  context.Context
	Dest string
	Keys []string
} {
	var calls []struct {
		Ctx  context.Context
		Dest string
		Keys []string
	}
	mock.lockPFMerge.RLock()
	calls = mock.calls.PFMerge
	mock.lockPFMerge.RUnlock()
	return calls
}

// ResetPFMergeCalls reset all the calls that were made to PFMerge.
func (mock *MoqCmdable) ResetPFMergeCalls() {
	mock.lockPFMerge.Lock()
	mock.calls.PFMerge = nil
	mock.lockPFMerge.Unlock()
}

// PTTL calls PTTLFunc.
func (mock *MoqCmdable) PTTL(ctx context.Context, key string) *redis.DurationCmd {
	if mock.PTTLFunc == nil {
		panic("MoqCmdable.PTTLFunc: method is nil but Cmdable.PTTL was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockPTTL.Lock()
	mock.calls.PTTL = append(mock.calls.PTTL, callInfo)
	mock.lockPTTL.Unlock()
	return mock.PTTLFunc(ctx, key)
}

// PTTLCalls gets all the calls that were made to PTTL.
// Check the length with:
//
//	len(mockedCmdable.PTTLCalls())
func (mock *MoqCmdable) PTTLCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockPTTL.RLock()
	calls = mock.calls.PTTL
	mock.lockPTTL.RUnlock()
	return calls
}

// ResetPTTLCalls reset all the calls that were made to PTTL.
func (mock *MoqCmdable) ResetPTTLCalls() {
	mock.lockPTTL.Lock()
	mock.calls.PTTL = nil
	mock.lockPTTL.Unlock()
}

// Persist calls PersistFunc.
func (mock *MoqCmdable) Persist(ctx context.Context, key string) *redis.BoolCmd {
	if mock.PersistFunc == nil {
		panic("MoqCmdable.PersistFunc: method is nil but Cmdable.Persist was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockPersist.Lock()
	mock.calls.Persist = append(mock.calls.Persist, callInfo)
	mock.lockPersist.Unlock()
	return mock.PersistFunc(ctx, key)
}

// PersistCalls gets all the calls that were made to Persist.
// Check the length with:
//
//	len(mockedCmdable.PersistCalls())
func (mock *MoqCmdable) PersistCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockPersist.RLock()
	calls = mock.calls.Persist
	mock.lockPersist.RUnlock()
	return calls
}

// ResetPersistCalls reset all the calls that were made to Persist.
func (mock *MoqCmdable) ResetPersistCalls() {
	mock.lockPersist.Lock()
	mock.calls.Persist = nil
	mock.lockPersist.Unlock()
}

// Ping calls PingFunc.
func (mock *MoqCmdable) Ping(ctx context.Context) *redis.StatusCmd {
	if mock.PingFunc == nil {
		panic("MoqCmdable.PingFunc: method is nil but Cmdable.Ping was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockPing.Lock()
	mock.calls.Ping = append(mock.calls.Ping, callInfo)
	mock.lockPing.Unlock()
	return mock.PingFunc(ctx)
}

// PingCalls gets all the calls that were made to Ping.
// Check the length with:
//
//	len(mockedCmdable.PingCalls())
func (mock *MoqCmdable) PingCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockPing.RLock()
	calls = mock.calls.Ping
	mock.lockPing.RUnlock()
	return calls
}

// ResetPingCalls reset all the calls that were made to Ping.
func (mock *MoqCmdable) ResetPingCalls() {
	mock.lockPing.Lock()
	mock.calls.Ping = nil
	mock.lockPing.Unlock()
}

// Pipeline calls PipelineFunc.
func (mock *MoqCmdable) Pipeline() redis.Pipeliner {
	if mock.PipelineFunc == nil {
		panic("MoqCmdable.PipelineFunc: method is nil but Cmdable.Pipeline was just called")
	}
	callInfo := struct {
	}{}
	mock.lockPipeline.Lock()
	mock.calls.Pipeline = append(mock.calls.Pipeline, callInfo)
	mock.lockPipeline.Unlock()
	return mock.PipelineFunc()
}

// PipelineCalls gets all the calls that were made to Pipeline.
// Check the length with:
//
//	len(mockedCmdable.PipelineCalls())
func (mock *MoqCmdable) PipelineCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockPipeline.RLock()
	calls = mock.calls.Pipeline
	mock.lockPipeline.RUnlock()
	return calls
}

// ResetPipelineCalls reset all the calls that were made to Pipeline.
func (mock *MoqCmdable) ResetPipelineCalls() {
	mock.lockPipeline.Lock()
	mock.calls.Pipeline = nil
	mock.lockPipeline.Unlock()
}

// Pipelined calls PipelinedFunc.
func (mock *MoqCmdable) Pipelined(ctx context.Context, fn func(redis.Pipeliner) error) ([]redis.Cmder, error) {
	if mock.PipelinedFunc == nil {
		panic("MoqCmdable.PipelinedFunc: method is nil but Cmdable.Pipelined was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Fn  func(redis.Pipeliner) error
	}{
		Ctx: ctx,
		Fn:  fn,
	}
	mock.lockPipelined.Lock()
	mock.calls.Pipelined = append(mock.calls.Pipelined, callInfo)
	mock.lockPipelined.Unlock()
	return mock.PipelinedFunc(ctx, fn)
}

// PipelinedCalls gets all the calls that were made to Pipelined.
// Check the length with:
//
//	len(mockedCmdable.PipelinedCalls())
func (mock *MoqCmdable) PipelinedCalls() []struct {
	Ctx context.Context
	Fn  func(redis.Pipeliner) error
} {
	var calls []struct {
		Ctx context.Context
		Fn  func(redis.Pipeliner) error
	}
	mock.lockPipelined.RLock()
	calls = mock.calls.Pipelined
	mock.lockPipelined.RUnlock()
	return calls
}

// ResetPipelinedCalls reset all the calls that were made to Pipelined.
func (mock *MoqCmdable) ResetPipelinedCalls() {
	mock.lockPipelined.Lock()
	mock.calls.Pipelined = nil
	mock.lockPipelined.Unlock()
}

// PubSubChannels calls PubSubChannelsFunc.
func (mock *MoqCmdable) PubSubChannels(ctx context.Context, pattern string) *redis.StringSliceCmd {
	if mock.PubSubChannelsFunc == nil {
		panic("MoqCmdable.PubSubChannelsFunc: method is nil but Cmdable.PubSubChannels was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Pattern string
	}{
		Ctx:     ctx,
		Pattern: pattern,
	}
	mock.lockPubSubChannels.Lock()
	mock.calls.PubSubChannels = append(mock.calls.PubSubChannels, callInfo)
	mock.lockPubSubChannels.Unlock()
	return mock.PubSubChannelsFunc(ctx, pattern)
}

// PubSubChannelsCalls gets all the calls that were made to PubSubChannels.
// Check the length with:
//
//	len(mockedCmdable.PubSubChannelsCalls())
func (mock *MoqCmdable) PubSubChannelsCalls() []struct {
	Ctx     context.Context
	Pattern string
} {
	var calls []struct {
		Ctx     context.Context
		Pattern string
	}
	mock.lockPubSubChannels.RLock()
	calls = mock.calls.PubSubChannels
	mock.lockPubSubChannels.RUnlock()
	return calls
}

// ResetPubSubChannelsCalls reset all the calls that were made to PubSubChannels.
func (mock *MoqCmdable) ResetPubSubChannelsCalls() {
	mock.lockPubSubChannels.Lock()
	mock.calls.PubSubChannels = nil
	mock.lockPubSubChannels.Unlock()
}

// PubSubNumPat calls PubSubNumPatFunc.
func (mock *MoqCmdable) PubSubNumPat(ctx context.Context) *redis.IntCmd {
	if mock.PubSubNumPatFunc == nil {
		panic("MoqCmdable.PubSubNumPatFunc: method is nil but Cmdable.PubSubNumPat was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockPubSubNumPat.Lock()
	mock.calls.PubSubNumPat = append(mock.calls.PubSubNumPat, callInfo)
	mock.lockPubSubNumPat.Unlock()
	return mock.PubSubNumPatFunc(ctx)
}

// PubSubNumPatCalls gets all the calls that were made to PubSubNumPat.
// Check the length with:
//
//	len(mockedCmdable.PubSubNumPatCalls())
func (mock *MoqCmdable) PubSubNumPatCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockPubSubNumPat.RLock()
	calls = mock.calls.PubSubNumPat
	mock.lockPubSubNumPat.RUnlock()
	return calls
}

// ResetPubSubNumPatCalls reset all the calls that were made to PubSubNumPat.
func (mock *MoqCmdable) ResetPubSubNumPatCalls() {
	mock.lockPubSubNumPat.Lock()
	mock.calls.PubSubNumPat = nil
	mock.lockPubSubNumPat.Unlock()
}

// PubSubNumSub calls PubSubNumSubFunc.
func (mock *MoqCmdable) PubSubNumSub(ctx context.Context, channels ...string) *redis.MapStringIntCmd {
	if mock.PubSubNumSubFunc == nil {
		panic("MoqCmdable.PubSubNumSubFunc: method is nil but Cmdable.PubSubNumSub was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Channels []string
	}{
		Ctx:      ctx,
		Channels: channels,
	}
	mock.lockPubSubNumSub.Lock()
	mock.calls.PubSubNumSub = append(mock.calls.PubSubNumSub, callInfo)
	mock.lockPubSubNumSub.Unlock()
	return mock.PubSubNumSubFunc(ctx, channels...)
}

// PubSubNumSubCalls gets all the calls that were made to PubSubNumSub.
// Check the length with:
//
//	len(mockedCmdable.PubSubNumSubCalls())
func (mock *MoqCmdable) PubSubNumSubCalls() []struct {
	Ctx      context.Context
	Channels []string
} {
	var calls []struct {
		Ctx      context.Context
		Channels []string
	}
	mock.lockPubSubNumSub.RLock()
	calls = mock.calls.PubSubNumSub
	mock.lockPubSubNumSub.RUnlock()
	return calls
}

// ResetPubSubNumSubCalls reset all the calls that were made to PubSubNumSub.
func (mock *MoqCmdable) ResetPubSubNumSubCalls() {
	mock.lockPubSubNumSub.Lock()
	mock.calls.PubSubNumSub = nil
	mock.lockPubSubNumSub.Unlock()
}

// PubSubShardChannels calls PubSubShardChannelsFunc.
func (mock *MoqCmdable) PubSubShardChannels(ctx context.Context, pattern string) *redis.StringSliceCmd {
	if mock.PubSubShardChannelsFunc == nil {
		panic("MoqCmdable.PubSubShardChannelsFunc: method is nil but Cmdable.PubSubShardChannels was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Pattern string
	}{
		Ctx:     ctx,
		Pattern: pattern,
	}
	mock.lockPubSubShardChannels.Lock()
	mock.calls.PubSubShardChannels = append(mock.calls.PubSubShardChannels, callInfo)
	mock.lockPubSubShardChannels.Unlock()
	return mock.PubSubShardChannelsFunc(ctx, pattern)
}

// PubSubShardChannelsCalls gets all the calls that were made to PubSubShardChannels.
// Check the length with:
//
//	len(mockedCmdable.PubSubShardChannelsCalls())
func (mock *MoqCmdable) PubSubShardChannelsCalls() []struct {
	Ctx     context.Context
	Pattern string
} {
	var calls []struct {
		Ctx     context.Context
		Pattern string
	}
	mock.lockPubSubShardChannels.RLock()
	calls = mock.calls.PubSubShardChannels
	mock.lockPubSubShardChannels.RUnlock()
	return calls
}

// ResetPubSubShardChannelsCalls reset all the calls that were made to PubSubShardChannels.
func (mock *MoqCmdable) ResetPubSubShardChannelsCalls() {
	mock.lockPubSubShardChannels.Lock()
	mock.calls.PubSubShardChannels = nil
	mock.lockPubSubShardChannels.Unlock()
}

// PubSubShardNumSub calls PubSubShardNumSubFunc.
func (mock *MoqCmdable) PubSubShardNumSub(ctx context.Context, channels ...string) *redis.MapStringIntCmd {
	if mock.PubSubShardNumSubFunc == nil {
		panic("MoqCmdable.PubSubShardNumSubFunc: method is nil but Cmdable.PubSubShardNumSub was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Channels []string
	}{
		Ctx:      ctx,
		Channels: channels,
	}
	mock.lockPubSubShardNumSub.Lock()
	mock.calls.PubSubShardNumSub = append(mock.calls.PubSubShardNumSub, callInfo)
	mock.lockPubSubShardNumSub.Unlock()
	return mock.PubSubShardNumSubFunc(ctx, channels...)
}

// PubSubShardNumSubCalls gets all the calls that were made to PubSubShardNumSub.
// Check the length with:
//
//	len(mockedCmdable.PubSubShardNumSubCalls())
func (mock *MoqCmdable) PubSubShardNumSubCalls() []struct {
	Ctx      context.Context
	Channels []string
} {
	var calls []struct {
		Ctx      context.Context
		Channels []string
	}
	mock.lockPubSubShardNumSub.RLock()
	calls = mock.calls.PubSubShardNumSub
	mock.lockPubSubShardNumSub.RUnlock()
	return calls
}

// ResetPubSubShardNumSubCalls reset all the calls that were made to PubSubShardNumSub.
func (mock *MoqCmdable) ResetPubSubShardNumSubCalls() {
	mock.lockPubSubShardNumSub.Lock()
	mock.calls.PubSubShardNumSub = nil
	mock.lockPubSubShardNumSub.Unlock()
}

// Publish calls PublishFunc.
func (mock *MoqCmdable) Publish(ctx context.Context, channel string, message interface{}) *redis.IntCmd {
	if mock.PublishFunc == nil {
		panic("MoqCmdable.PublishFunc: method is nil but Cmdable.Publish was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Channel string
		Message interface{}
	}{
		Ctx:     ctx,
		Channel: channel,
		Message: message,
	}
	mock.lockPublish.Lock()
	mock.calls.Publish = append(mock.calls.Publish, callInfo)
	mock.lockPublish.Unlock()
	return mock.PublishFunc(ctx, channel, message)
}

// PublishCalls gets all the calls that were made to Publish.
// Check the length with:
//
//	len(mockedCmdable.PublishCalls())
func (mock *MoqCmdable) PublishCalls() []struct {
	Ctx     context.Context
	Channel string
	Message interface{}
} {
	var calls []struct {
		Ctx     context.Context
		Channel string
		Message interface{}
	}
	mock.lockPublish.RLock()
	calls = mock.calls.Publish
	mock.lockPublish.RUnlock()
	return calls
}

// ResetPublishCalls reset all the calls that were made to Publish.
func (mock *MoqCmdable) ResetPublishCalls() {
	mock.lockPublish.Lock()
	mock.calls.Publish = nil
	mock.lockPublish.Unlock()
}

// Quit calls QuitFunc.
func (mock *MoqCmdable) Quit(ctx context.Context) *redis.StatusCmd {
	if mock.QuitFunc == nil {
		panic("MoqCmdable.QuitFunc: method is nil but Cmdable.Quit was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockQuit.Lock()
	mock.calls.Quit = append(mock.calls.Quit, callInfo)
	mock.lockQuit.Unlock()
	return mock.QuitFunc(ctx)
}

// QuitCalls gets all the calls that were made to Quit.
// Check the length with:
//
//	len(mockedCmdable.QuitCalls())
func (mock *MoqCmdable) QuitCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockQuit.RLock()
	calls = mock.calls.Quit
	mock.lockQuit.RUnlock()
	return calls
}

// ResetQuitCalls reset all the calls that were made to Quit.
func (mock *MoqCmdable) ResetQuitCalls() {
	mock.lockQuit.Lock()
	mock.calls.Quit = nil
	mock.lockQuit.Unlock()
}

// RPop calls RPopFunc.
func (mock *MoqCmdable) RPop(ctx context.Context, key string) *redis.StringCmd {
	if mock.RPopFunc == nil {
		panic("MoqCmdable.RPopFunc: method is nil but Cmdable.RPop was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockRPop.Lock()
	mock.calls.RPop = append(mock.calls.RPop, callInfo)
	mock.lockRPop.Unlock()
	return mock.RPopFunc(ctx, key)
}

// RPopCalls gets all the calls that were made to RPop.
// Check the length with:
//
//	len(mockedCmdable.RPopCalls())
func (mock *MoqCmdable) RPopCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockRPop.RLock()
	calls = mock.calls.RPop
	mock.lockRPop.RUnlock()
	return calls
}

// ResetRPopCalls reset all the calls that were made to RPop.
func (mock *MoqCmdable) ResetRPopCalls() {
	mock.lockRPop.Lock()
	mock.calls.RPop = nil
	mock.lockRPop.Unlock()
}

// RPopCount calls RPopCountFunc.
func (mock *MoqCmdable) RPopCount(ctx context.Context, key string, count int) *redis.StringSliceCmd {
	if mock.RPopCountFunc == nil {
		panic("MoqCmdable.RPopCountFunc: method is nil but Cmdable.RPopCount was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Count int
	}{
		Ctx:   ctx,
		Key:   key,
		Count: count,
	}
	mock.lockRPopCount.Lock()
	mock.calls.RPopCount = append(mock.calls.RPopCount, callInfo)
	mock.lockRPopCount.Unlock()
	return mock.RPopCountFunc(ctx, key, count)
}

// RPopCountCalls gets all the calls that were made to RPopCount.
// Check the length with:
//
//	len(mockedCmdable.RPopCountCalls())
func (mock *MoqCmdable) RPopCountCalls() []struct {
	Ctx   context.Context
	Key   string
	Count int
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Count int
	}
	mock.lockRPopCount.RLock()
	calls = mock.calls.RPopCount
	mock.lockRPopCount.RUnlock()
	return calls
}

// ResetRPopCountCalls reset all the calls that were made to RPopCount.
func (mock *MoqCmdable) ResetRPopCountCalls() {
	mock.lockRPopCount.Lock()
	mock.calls.RPopCount = nil
	mock.lockRPopCount.Unlock()
}

// RPopLPush calls RPopLPushFunc.
func (mock *MoqCmdable) RPopLPush(ctx context.Context, source string, destination string) *redis.StringCmd {
	if mock.RPopLPushFunc == nil {
		panic("MoqCmdable.RPopLPushFunc: method is nil but Cmdable.RPopLPush was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		Source      string
		Destination string
	}{
		Ctx:         ctx,
		Source:      source,
		Destination: destination,
	}
	mock.lockRPopLPush.Lock()
	mock.calls.RPopLPush = append(mock.calls.RPopLPush, callInfo)
	mock.lockRPopLPush.Unlock()
	return mock.RPopLPushFunc(ctx, source, destination)
}

// RPopLPushCalls gets all the calls that were made to RPopLPush.
// Check the length with:
//
//	len(mockedCmdable.RPopLPushCalls())
func (mock *MoqCmdable) RPopLPushCalls() []struct {
	Ctx         context.Context
	Source      string
	Destination string
} {
	var calls []struct {
		Ctx         context.Context
		Source      string
		Destination string
	}
	mock.lockRPopLPush.RLock()
	calls = mock.calls.RPopLPush
	mock.lockRPopLPush.RUnlock()
	return calls
}

// ResetRPopLPushCalls reset all the calls that were made to RPopLPush.
func (mock *MoqCmdable) ResetRPopLPushCalls() {
	mock.lockRPopLPush.Lock()
	mock.calls.RPopLPush = nil
	mock.lockRPopLPush.Unlock()
}

// RPush calls RPushFunc.
func (mock *MoqCmdable) RPush(ctx context.Context, key string, values ...interface{}) *redis.IntCmd {
	if mock.RPushFunc == nil {
		panic("MoqCmdable.RPushFunc: method is nil but Cmdable.RPush was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		Values []interface{}
	}{
		Ctx:    ctx,
		Key:    key,
		Values: values,
	}
	mock.lockRPush.Lock()
	mock.calls.RPush = append(mock.calls.RPush, callInfo)
	mock.lockRPush.Unlock()
	return mock.RPushFunc(ctx, key, values...)
}

// RPushCalls gets all the calls that were made to RPush.
// Check the length with:
//
//	len(mockedCmdable.RPushCalls())
func (mock *MoqCmdable) RPushCalls() []struct {
	Ctx    context.Context
	Key    string
	Values []interface{}
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		Values []interface{}
	}
	mock.lockRPush.RLock()
	calls = mock.calls.RPush
	mock.lockRPush.RUnlock()
	return calls
}

// ResetRPushCalls reset all the calls that were made to RPush.
func (mock *MoqCmdable) ResetRPushCalls() {
	mock.lockRPush.Lock()
	mock.calls.RPush = nil
	mock.lockRPush.Unlock()
}

// RPushX calls RPushXFunc.
func (mock *MoqCmdable) RPushX(ctx context.Context, key string, values ...interface{}) *redis.IntCmd {
	if mock.RPushXFunc == nil {
		panic("MoqCmdable.RPushXFunc: method is nil but Cmdable.RPushX was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		Values []interface{}
	}{
		Ctx:    ctx,
		Key:    key,
		Values: values,
	}
	mock.lockRPushX.Lock()
	mock.calls.RPushX = append(mock.calls.RPushX, callInfo)
	mock.lockRPushX.Unlock()
	return mock.RPushXFunc(ctx, key, values...)
}

// RPushXCalls gets all the calls that were made to RPushX.
// Check the length with:
//
//	len(mockedCmdable.RPushXCalls())
func (mock *MoqCmdable) RPushXCalls() []struct {
	Ctx    context.Context
	Key    string
	Values []interface{}
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		Values []interface{}
	}
	mock.lockRPushX.RLock()
	calls = mock.calls.RPushX
	mock.lockRPushX.RUnlock()
	return calls
}

// ResetRPushXCalls reset all the calls that were made to RPushX.
func (mock *MoqCmdable) ResetRPushXCalls() {
	mock.lockRPushX.Lock()
	mock.calls.RPushX = nil
	mock.lockRPushX.Unlock()
}

// RandomKey calls RandomKeyFunc.
func (mock *MoqCmdable) RandomKey(ctx context.Context) *redis.StringCmd {
	if mock.RandomKeyFunc == nil {
		panic("MoqCmdable.RandomKeyFunc: method is nil but Cmdable.RandomKey was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockRandomKey.Lock()
	mock.calls.RandomKey = append(mock.calls.RandomKey, callInfo)
	mock.lockRandomKey.Unlock()
	return mock.RandomKeyFunc(ctx)
}

// RandomKeyCalls gets all the calls that were made to RandomKey.
// Check the length with:
//
//	len(mockedCmdable.RandomKeyCalls())
func (mock *MoqCmdable) RandomKeyCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockRandomKey.RLock()
	calls = mock.calls.RandomKey
	mock.lockRandomKey.RUnlock()
	return calls
}

// ResetRandomKeyCalls reset all the calls that were made to RandomKey.
func (mock *MoqCmdable) ResetRandomKeyCalls() {
	mock.lockRandomKey.Lock()
	mock.calls.RandomKey = nil
	mock.lockRandomKey.Unlock()
}

// ReadOnly calls ReadOnlyFunc.
func (mock *MoqCmdable) ReadOnly(ctx context.Context) *redis.StatusCmd {
	if mock.ReadOnlyFunc == nil {
		panic("MoqCmdable.ReadOnlyFunc: method is nil but Cmdable.ReadOnly was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockReadOnly.Lock()
	mock.calls.ReadOnly = append(mock.calls.ReadOnly, callInfo)
	mock.lockReadOnly.Unlock()
	return mock.ReadOnlyFunc(ctx)
}

// ReadOnlyCalls gets all the calls that were made to ReadOnly.
// Check the length with:
//
//	len(mockedCmdable.ReadOnlyCalls())
func (mock *MoqCmdable) ReadOnlyCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockReadOnly.RLock()
	calls = mock.calls.ReadOnly
	mock.lockReadOnly.RUnlock()
	return calls
}

// ResetReadOnlyCalls reset all the calls that were made to ReadOnly.
func (mock *MoqCmdable) ResetReadOnlyCalls() {
	mock.lockReadOnly.Lock()
	mock.calls.ReadOnly = nil
	mock.lockReadOnly.Unlock()
}

// ReadWrite calls ReadWriteFunc.
func (mock *MoqCmdable) ReadWrite(ctx context.Context) *redis.StatusCmd {
	if mock.ReadWriteFunc == nil {
		panic("MoqCmdable.ReadWriteFunc: method is nil but Cmdable.ReadWrite was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockReadWrite.Lock()
	mock.calls.ReadWrite = append(mock.calls.ReadWrite, callInfo)
	mock.lockReadWrite.Unlock()
	return mock.ReadWriteFunc(ctx)
}

// ReadWriteCalls gets all the calls that were made to ReadWrite.
// Check the length with:
//
//	len(mockedCmdable.ReadWriteCalls())
func (mock *MoqCmdable) ReadWriteCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockReadWrite.RLock()
	calls = mock.calls.ReadWrite
	mock.lockReadWrite.RUnlock()
	return calls
}

// ResetReadWriteCalls reset all the calls that were made to ReadWrite.
func (mock *MoqCmdable) ResetReadWriteCalls() {
	mock.lockReadWrite.Lock()
	mock.calls.ReadWrite = nil
	mock.lockReadWrite.Unlock()
}

// Rename calls RenameFunc.
func (mock *MoqCmdable) Rename(ctx context.Context, key string, newkey string) *redis.StatusCmd {
	if mock.RenameFunc == nil {
		panic("MoqCmdable.RenameFunc: method is nil but Cmdable.Rename was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		Newkey string
	}{
		Ctx:    ctx,
		Key:    key,
		Newkey: newkey,
	}
	mock.lockRename.Lock()
	mock.calls.Rename = append(mock.calls.Rename, callInfo)
	mock.lockRename.Unlock()
	return mock.RenameFunc(ctx, key, newkey)
}

// RenameCalls gets all the calls that were made to Rename.
// Check the length with:
//
//	len(mockedCmdable.RenameCalls())
func (mock *MoqCmdable) RenameCalls() []struct {
	Ctx    context.Context
	Key    string
	Newkey string
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		Newkey string
	}
	mock.lockRename.RLock()
	calls = mock.calls.Rename
	mock.lockRename.RUnlock()
	return calls
}

// ResetRenameCalls reset all the calls that were made to Rename.
func (mock *MoqCmdable) ResetRenameCalls() {
	mock.lockRename.Lock()
	mock.calls.Rename = nil
	mock.lockRename.Unlock()
}

// RenameNX calls RenameNXFunc.
func (mock *MoqCmdable) RenameNX(ctx context.Context, key string, newkey string) *redis.BoolCmd {
	if mock.RenameNXFunc == nil {
		panic("MoqCmdable.RenameNXFunc: method is nil but Cmdable.RenameNX was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		Newkey string
	}{
		Ctx:    ctx,
		Key:    key,
		Newkey: newkey,
	}
	mock.lockRenameNX.Lock()
	mock.calls.RenameNX = append(mock.calls.RenameNX, callInfo)
	mock.lockRenameNX.Unlock()
	return mock.RenameNXFunc(ctx, key, newkey)
}

// RenameNXCalls gets all the calls that were made to RenameNX.
// Check the length with:
//
//	len(mockedCmdable.RenameNXCalls())
func (mock *MoqCmdable) RenameNXCalls() []struct {
	Ctx    context.Context
	Key    string
	Newkey string
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		Newkey string
	}
	mock.lockRenameNX.RLock()
	calls = mock.calls.RenameNX
	mock.lockRenameNX.RUnlock()
	return calls
}

// ResetRenameNXCalls reset all the calls that were made to RenameNX.
func (mock *MoqCmdable) ResetRenameNXCalls() {
	mock.lockRenameNX.Lock()
	mock.calls.RenameNX = nil
	mock.lockRenameNX.Unlock()
}

// Restore calls RestoreFunc.
func (mock *MoqCmdable) Restore(ctx context.Context, key string, ttl time.Duration, value string) *redis.StatusCmd {
	if mock.RestoreFunc == nil {
		panic("MoqCmdable.RestoreFunc: method is nil but Cmdable.Restore was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		TTL   time.Duration
		Value string
	}{
		Ctx:   ctx,
		Key:   key,
		TTL:   ttl,
		Value: value,
	}
	mock.lockRestore.Lock()
	mock.calls.Restore = append(mock.calls.Restore, callInfo)
	mock.lockRestore.Unlock()
	return mock.RestoreFunc(ctx, key, ttl, value)
}

// RestoreCalls gets all the calls that were made to Restore.
// Check the length with:
//
//	len(mockedCmdable.RestoreCalls())
func (mock *MoqCmdable) RestoreCalls() []struct {
	Ctx   context.Context
	Key   string
	TTL   time.Duration
	Value string
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		TTL   time.Duration
		Value string
	}
	mock.lockRestore.RLock()
	calls = mock.calls.Restore
	mock.lockRestore.RUnlock()
	return calls
}

// ResetRestoreCalls reset all the calls that were made to Restore.
func (mock *MoqCmdable) ResetRestoreCalls() {
	mock.lockRestore.Lock()
	mock.calls.Restore = nil
	mock.lockRestore.Unlock()
}

// RestoreReplace calls RestoreReplaceFunc.
func (mock *MoqCmdable) RestoreReplace(ctx context.Context, key string, ttl time.Duration, value string) *redis.StatusCmd {
	if mock.RestoreReplaceFunc == nil {
		panic("MoqCmdable.RestoreReplaceFunc: method is nil but Cmdable.RestoreReplace was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		TTL   time.Duration
		Value string
	}{
		Ctx:   ctx,
		Key:   key,
		TTL:   ttl,
		Value: value,
	}
	mock.lockRestoreReplace.Lock()
	mock.calls.RestoreReplace = append(mock.calls.RestoreReplace, callInfo)
	mock.lockRestoreReplace.Unlock()
	return mock.RestoreReplaceFunc(ctx, key, ttl, value)
}

// RestoreReplaceCalls gets all the calls that were made to RestoreReplace.
// Check the length with:
//
//	len(mockedCmdable.RestoreReplaceCalls())
func (mock *MoqCmdable) RestoreReplaceCalls() []struct {
	Ctx   context.Context
	Key   string
	TTL   time.Duration
	Value string
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		TTL   time.Duration
		Value string
	}
	mock.lockRestoreReplace.RLock()
	calls = mock.calls.RestoreReplace
	mock.lockRestoreReplace.RUnlock()
	return calls
}

// ResetRestoreReplaceCalls reset all the calls that were made to RestoreReplace.
func (mock *MoqCmdable) ResetRestoreReplaceCalls() {
	mock.lockRestoreReplace.Lock()
	mock.calls.RestoreReplace = nil
	mock.lockRestoreReplace.Unlock()
}

// SAdd calls SAddFunc.
func (mock *MoqCmdable) SAdd(ctx context.Context, key string, members ...interface{}) *redis.IntCmd {
	if mock.SAddFunc == nil {
		panic("MoqCmdable.SAddFunc: method is nil but Cmdable.SAdd was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Key     string
		Members []interface{}
	}{
		Ctx:     ctx,
		Key:     key,
		Members: members,
	}
	mock.lockSAdd.Lock()
	mock.calls.SAdd = append(mock.calls.SAdd, callInfo)
	mock.lockSAdd.Unlock()
	return mock.SAddFunc(ctx, key, members...)
}

// SAddCalls gets all the calls that were made to SAdd.
// Check the length with:
//
//	len(mockedCmdable.SAddCalls())
func (mock *MoqCmdable) SAddCalls() []struct {
	Ctx     context.Context
	Key     string
	Members []interface{}
} {
	var calls []struct {
		Ctx     context.Context
		Key     string
		Members []interface{}
	}
	mock.lockSAdd.RLock()
	calls = mock.calls.SAdd
	mock.lockSAdd.RUnlock()
	return calls
}

// ResetSAddCalls reset all the calls that were made to SAdd.
func (mock *MoqCmdable) ResetSAddCalls() {
	mock.lockSAdd.Lock()
	mock.calls.SAdd = nil
	mock.lockSAdd.Unlock()
}

// SCard calls SCardFunc.
func (mock *MoqCmdable) SCard(ctx context.Context, key string) *redis.IntCmd {
	if mock.SCardFunc == nil {
		panic("MoqCmdable.SCardFunc: method is nil but Cmdable.SCard was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockSCard.Lock()
	mock.calls.SCard = append(mock.calls.SCard, callInfo)
	mock.lockSCard.Unlock()
	return mock.SCardFunc(ctx, key)
}

// SCardCalls gets all the calls that were made to SCard.
// Check the length with:
//
//	len(mockedCmdable.SCardCalls())
func (mock *MoqCmdable) SCardCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockSCard.RLock()
	calls = mock.calls.SCard
	mock.lockSCard.RUnlock()
	return calls
}

// ResetSCardCalls reset all the calls that were made to SCard.
func (mock *MoqCmdable) ResetSCardCalls() {
	mock.lockSCard.Lock()
	mock.calls.SCard = nil
	mock.lockSCard.Unlock()
}

// SDiff calls SDiffFunc.
func (mock *MoqCmdable) SDiff(ctx context.Context, keys ...string) *redis.StringSliceCmd {
	if mock.SDiffFunc == nil {
		panic("MoqCmdable.SDiffFunc: method is nil but Cmdable.SDiff was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Keys []string
	}{
		Ctx:  ctx,
		Keys: keys,
	}
	mock.lockSDiff.Lock()
	mock.calls.SDiff = append(mock.calls.SDiff, callInfo)
	mock.lockSDiff.Unlock()
	return mock.SDiffFunc(ctx, keys...)
}

// SDiffCalls gets all the calls that were made to SDiff.
// Check the length with:
//
//	len(mockedCmdable.SDiffCalls())
func (mock *MoqCmdable) SDiffCalls() []struct {
	Ctx  context.Context
	Keys []string
} {
	var calls []struct {
		Ctx  context.Context
		Keys []string
	}
	mock.lockSDiff.RLock()
	calls = mock.calls.SDiff
	mock.lockSDiff.RUnlock()
	return calls
}

// ResetSDiffCalls reset all the calls that were made to SDiff.
func (mock *MoqCmdable) ResetSDiffCalls() {
	mock.lockSDiff.Lock()
	mock.calls.SDiff = nil
	mock.lockSDiff.Unlock()
}

// SDiffStore calls SDiffStoreFunc.
func (mock *MoqCmdable) SDiffStore(ctx context.Context, destination string, keys ...string) *redis.IntCmd {
	if mock.SDiffStoreFunc == nil {
		panic("MoqCmdable.SDiffStoreFunc: method is nil but Cmdable.SDiffStore was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		Destination string
		Keys        []string
	}{
		Ctx:         ctx,
		Destination: destination,
		Keys:        keys,
	}
	mock.lockSDiffStore.Lock()
	mock.calls.SDiffStore = append(mock.calls.SDiffStore, callInfo)
	mock.lockSDiffStore.Unlock()
	return mock.SDiffStoreFunc(ctx, destination, keys...)
}

// SDiffStoreCalls gets all the calls that were made to SDiffStore.
// Check the length with:
//
//	len(mockedCmdable.SDiffStoreCalls())
func (mock *MoqCmdable) SDiffStoreCalls() []struct {
	Ctx         context.Context
	Destination string
	Keys        []string
} {
	var calls []struct {
		Ctx         context.Context
		Destination string
		Keys        []string
	}
	mock.lockSDiffStore.RLock()
	calls = mock.calls.SDiffStore
	mock.lockSDiffStore.RUnlock()
	return calls
}

// ResetSDiffStoreCalls reset all the calls that were made to SDiffStore.
func (mock *MoqCmdable) ResetSDiffStoreCalls() {
	mock.lockSDiffStore.Lock()
	mock.calls.SDiffStore = nil
	mock.lockSDiffStore.Unlock()
}

// SInter calls SInterFunc.
func (mock *MoqCmdable) SInter(ctx context.Context, keys ...string) *redis.StringSliceCmd {
	if mock.SInterFunc == nil {
		panic("MoqCmdable.SInterFunc: method is nil but Cmdable.SInter was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Keys []string
	}{
		Ctx:  ctx,
		Keys: keys,
	}
	mock.lockSInter.Lock()
	mock.calls.SInter = append(mock.calls.SInter, callInfo)
	mock.lockSInter.Unlock()
	return mock.SInterFunc(ctx, keys...)
}

// SInterCalls gets all the calls that were made to SInter.
// Check the length with:
//
//	len(mockedCmdable.SInterCalls())
func (mock *MoqCmdable) SInterCalls() []struct {
	Ctx  context.Context
	Keys []string
} {
	var calls []struct {
		Ctx  context.Context
		Keys []string
	}
	mock.lockSInter.RLock()
	calls = mock.calls.SInter
	mock.lockSInter.RUnlock()
	return calls
}

// ResetSInterCalls reset all the calls that were made to SInter.
func (mock *MoqCmdable) ResetSInterCalls() {
	mock.lockSInter.Lock()
	mock.calls.SInter = nil
	mock.lockSInter.Unlock()
}

// SInterCard calls SInterCardFunc.
func (mock *MoqCmdable) SInterCard(ctx context.Context, limit int64, keys ...string) *redis.IntCmd {
	if mock.SInterCardFunc == nil {
		panic("MoqCmdable.SInterCardFunc: method is nil but Cmdable.SInterCard was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Limit int64
		Keys  []string
	}{
		Ctx:   ctx,
		Limit: limit,
		Keys:  keys,
	}
	mock.lockSInterCard.Lock()
	mock.calls.SInterCard = append(mock.calls.SInterCard, callInfo)
	mock.lockSInterCard.Unlock()
	return mock.SInterCardFunc(ctx, limit, keys...)
}

// SInterCardCalls gets all the calls that were made to SInterCard.
// Check the length with:
//
//	len(mockedCmdable.SInterCardCalls())
func (mock *MoqCmdable) SInterCardCalls() []struct {
	Ctx   context.Context
	Limit int64
	Keys  []string
} {
	var calls []struct {
		Ctx   context.Context
		Limit int64
		Keys  []string
	}
	mock.lockSInterCard.RLock()
	calls = mock.calls.SInterCard
	mock.lockSInterCard.RUnlock()
	return calls
}

// ResetSInterCardCalls reset all the calls that were made to SInterCard.
func (mock *MoqCmdable) ResetSInterCardCalls() {
	mock.lockSInterCard.Lock()
	mock.calls.SInterCard = nil
	mock.lockSInterCard.Unlock()
}

// SInterStore calls SInterStoreFunc.
func (mock *MoqCmdable) SInterStore(ctx context.Context, destination string, keys ...string) *redis.IntCmd {
	if mock.SInterStoreFunc == nil {
		panic("MoqCmdable.SInterStoreFunc: method is nil but Cmdable.SInterStore was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		Destination string
		Keys        []string
	}{
		Ctx:         ctx,
		Destination: destination,
		Keys:        keys,
	}
	mock.lockSInterStore.Lock()
	mock.calls.SInterStore = append(mock.calls.SInterStore, callInfo)
	mock.lockSInterStore.Unlock()
	return mock.SInterStoreFunc(ctx, destination, keys...)
}

// SInterStoreCalls gets all the calls that were made to SInterStore.
// Check the length with:
//
//	len(mockedCmdable.SInterStoreCalls())
func (mock *MoqCmdable) SInterStoreCalls() []struct {
	Ctx         context.Context
	Destination string
	Keys        []string
} {
	var calls []struct {
		Ctx         context.Context
		Destination string
		Keys        []string
	}
	mock.lockSInterStore.RLock()
	calls = mock.calls.SInterStore
	mock.lockSInterStore.RUnlock()
	return calls
}

// ResetSInterStoreCalls reset all the calls that were made to SInterStore.
func (mock *MoqCmdable) ResetSInterStoreCalls() {
	mock.lockSInterStore.Lock()
	mock.calls.SInterStore = nil
	mock.lockSInterStore.Unlock()
}

// SIsMember calls SIsMemberFunc.
func (mock *MoqCmdable) SIsMember(ctx context.Context, key string, member interface{}) *redis.BoolCmd {
	if mock.SIsMemberFunc == nil {
		panic("MoqCmdable.SIsMemberFunc: method is nil but Cmdable.SIsMember was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		Member interface{}
	}{
		Ctx:    ctx,
		Key:    key,
		Member: member,
	}
	mock.lockSIsMember.Lock()
	mock.calls.SIsMember = append(mock.calls.SIsMember, callInfo)
	mock.lockSIsMember.Unlock()
	return mock.SIsMemberFunc(ctx, key, member)
}

// SIsMemberCalls gets all the calls that were made to SIsMember.
// Check the length with:
//
//	len(mockedCmdable.SIsMemberCalls())
func (mock *MoqCmdable) SIsMemberCalls() []struct {
	Ctx    context.Context
	Key    string
	Member interface{}
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		Member interface{}
	}
	mock.lockSIsMember.RLock()
	calls = mock.calls.SIsMember
	mock.lockSIsMember.RUnlock()
	return calls
}

// ResetSIsMemberCalls reset all the calls that were made to SIsMember.
func (mock *MoqCmdable) ResetSIsMemberCalls() {
	mock.lockSIsMember.Lock()
	mock.calls.SIsMember = nil
	mock.lockSIsMember.Unlock()
}

// SMIsMember calls SMIsMemberFunc.
func (mock *MoqCmdable) SMIsMember(ctx context.Context, key string, members ...interface{}) *redis.BoolSliceCmd {
	if mock.SMIsMemberFunc == nil {
		panic("MoqCmdable.SMIsMemberFunc: method is nil but Cmdable.SMIsMember was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Key     string
		Members []interface{}
	}{
		Ctx:     ctx,
		Key:     key,
		Members: members,
	}
	mock.lockSMIsMember.Lock()
	mock.calls.SMIsMember = append(mock.calls.SMIsMember, callInfo)
	mock.lockSMIsMember.Unlock()
	return mock.SMIsMemberFunc(ctx, key, members...)
}

// SMIsMemberCalls gets all the calls that were made to SMIsMember.
// Check the length with:
//
//	len(mockedCmdable.SMIsMemberCalls())
func (mock *MoqCmdable) SMIsMemberCalls() []struct {
	Ctx     context.Context
	Key     string
	Members []interface{}
} {
	var calls []struct {
		Ctx     context.Context
		Key     string
		Members []interface{}
	}
	mock.lockSMIsMember.RLock()
	calls = mock.calls.SMIsMember
	mock.lockSMIsMember.RUnlock()
	return calls
}

// ResetSMIsMemberCalls reset all the calls that were made to SMIsMember.
func (mock *MoqCmdable) ResetSMIsMemberCalls() {
	mock.lockSMIsMember.Lock()
	mock.calls.SMIsMember = nil
	mock.lockSMIsMember.Unlock()
}

// SMembers calls SMembersFunc.
func (mock *MoqCmdable) SMembers(ctx context.Context, key string) *redis.StringSliceCmd {
	if mock.SMembersFunc == nil {
		panic("MoqCmdable.SMembersFunc: method is nil but Cmdable.SMembers was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockSMembers.Lock()
	mock.calls.SMembers = append(mock.calls.SMembers, callInfo)
	mock.lockSMembers.Unlock()
	return mock.SMembersFunc(ctx, key)
}

// SMembersCalls gets all the calls that were made to SMembers.
// Check the length with:
//
//	len(mockedCmdable.SMembersCalls())
func (mock *MoqCmdable) SMembersCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockSMembers.RLock()
	calls = mock.calls.SMembers
	mock.lockSMembers.RUnlock()
	return calls
}

// ResetSMembersCalls reset all the calls that were made to SMembers.
func (mock *MoqCmdable) ResetSMembersCalls() {
	mock.lockSMembers.Lock()
	mock.calls.SMembers = nil
	mock.lockSMembers.Unlock()
}

// SMembersMap calls SMembersMapFunc.
func (mock *MoqCmdable) SMembersMap(ctx context.Context, key string) *redis.StringStructMapCmd {
	if mock.SMembersMapFunc == nil {
		panic("MoqCmdable.SMembersMapFunc: method is nil but Cmdable.SMembersMap was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockSMembersMap.Lock()
	mock.calls.SMembersMap = append(mock.calls.SMembersMap, callInfo)
	mock.lockSMembersMap.Unlock()
	return mock.SMembersMapFunc(ctx, key)
}

// SMembersMapCalls gets all the calls that were made to SMembersMap.
// Check the length with:
//
//	len(mockedCmdable.SMembersMapCalls())
func (mock *MoqCmdable) SMembersMapCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockSMembersMap.RLock()
	calls = mock.calls.SMembersMap
	mock.lockSMembersMap.RUnlock()
	return calls
}

// ResetSMembersMapCalls reset all the calls that were made to SMembersMap.
func (mock *MoqCmdable) ResetSMembersMapCalls() {
	mock.lockSMembersMap.Lock()
	mock.calls.SMembersMap = nil
	mock.lockSMembersMap.Unlock()
}

// SMove calls SMoveFunc.
func (mock *MoqCmdable) SMove(ctx context.Context, source string, destination string, member interface{}) *redis.BoolCmd {
	if mock.SMoveFunc == nil {
		panic("MoqCmdable.SMoveFunc: method is nil but Cmdable.SMove was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		Source      string
		Destination string
		Member      interface{}
	}{
		Ctx:         ctx,
		Source:      source,
		Destination: destination,
		Member:      member,
	}
	mock.lockSMove.Lock()
	mock.calls.SMove = append(mock.calls.SMove, callInfo)
	mock.lockSMove.Unlock()
	return mock.SMoveFunc(ctx, source, destination, member)
}

// SMoveCalls gets all the calls that were made to SMove.
// Check the length with:
//
//	len(mockedCmdable.SMoveCalls())
func (mock *MoqCmdable) SMoveCalls() []struct {
	Ctx         context.Context
	Source      string
	Destination string
	Member      interface{}
} {
	var calls []struct {
		Ctx         context.Context
		Source      string
		Destination string
		Member      interface{}
	}
	mock.lockSMove.RLock()
	calls = mock.calls.SMove
	mock.lockSMove.RUnlock()
	return calls
}

// ResetSMoveCalls reset all the calls that were made to SMove.
func (mock *MoqCmdable) ResetSMoveCalls() {
	mock.lockSMove.Lock()
	mock.calls.SMove = nil
	mock.lockSMove.Unlock()
}

// SPop calls SPopFunc.
func (mock *MoqCmdable) SPop(ctx context.Context, key string) *redis.StringCmd {
	if mock.SPopFunc == nil {
		panic("MoqCmdable.SPopFunc: method is nil but Cmdable.SPop was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockSPop.Lock()
	mock.calls.SPop = append(mock.calls.SPop, callInfo)
	mock.lockSPop.Unlock()
	return mock.SPopFunc(ctx, key)
}

// SPopCalls gets all the calls that were made to SPop.
// Check the length with:
//
//	len(mockedCmdable.SPopCalls())
func (mock *MoqCmdable) SPopCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockSPop.RLock()
	calls = mock.calls.SPop
	mock.lockSPop.RUnlock()
	return calls
}

// ResetSPopCalls reset all the calls that were made to SPop.
func (mock *MoqCmdable) ResetSPopCalls() {
	mock.lockSPop.Lock()
	mock.calls.SPop = nil
	mock.lockSPop.Unlock()
}

// SPopN calls SPopNFunc.
func (mock *MoqCmdable) SPopN(ctx context.Context, key string, count int64) *redis.StringSliceCmd {
	if mock.SPopNFunc == nil {
		panic("MoqCmdable.SPopNFunc: method is nil but Cmdable.SPopN was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Count int64
	}{
		Ctx:   ctx,
		Key:   key,
		Count: count,
	}
	mock.lockSPopN.Lock()
	mock.calls.SPopN = append(mock.calls.SPopN, callInfo)
	mock.lockSPopN.Unlock()
	return mock.SPopNFunc(ctx, key, count)
}

// SPopNCalls gets all the calls that were made to SPopN.
// Check the length with:
//
//	len(mockedCmdable.SPopNCalls())
func (mock *MoqCmdable) SPopNCalls() []struct {
	Ctx   context.Context
	Key   string
	Count int64
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Count int64
	}
	mock.lockSPopN.RLock()
	calls = mock.calls.SPopN
	mock.lockSPopN.RUnlock()
	return calls
}

// ResetSPopNCalls reset all the calls that were made to SPopN.
func (mock *MoqCmdable) ResetSPopNCalls() {
	mock.lockSPopN.Lock()
	mock.calls.SPopN = nil
	mock.lockSPopN.Unlock()
}

// SPublish calls SPublishFunc.
func (mock *MoqCmdable) SPublish(ctx context.Context, channel string, message interface{}) *redis.IntCmd {
	if mock.SPublishFunc == nil {
		panic("MoqCmdable.SPublishFunc: method is nil but Cmdable.SPublish was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Channel string
		Message interface{}
	}{
		Ctx:     ctx,
		Channel: channel,
		Message: message,
	}
	mock.lockSPublish.Lock()
	mock.calls.SPublish = append(mock.calls.SPublish, callInfo)
	mock.lockSPublish.Unlock()
	return mock.SPublishFunc(ctx, channel, message)
}

// SPublishCalls gets all the calls that were made to SPublish.
// Check the length with:
//
//	len(mockedCmdable.SPublishCalls())
func (mock *MoqCmdable) SPublishCalls() []struct {
	Ctx     context.Context
	Channel string
	Message interface{}
} {
	var calls []struct {
		Ctx     context.Context
		Channel string
		Message interface{}
	}
	mock.lockSPublish.RLock()
	calls = mock.calls.SPublish
	mock.lockSPublish.RUnlock()
	return calls
}

// ResetSPublishCalls reset all the calls that were made to SPublish.
func (mock *MoqCmdable) ResetSPublishCalls() {
	mock.lockSPublish.Lock()
	mock.calls.SPublish = nil
	mock.lockSPublish.Unlock()
}

// SRandMember calls SRandMemberFunc.
func (mock *MoqCmdable) SRandMember(ctx context.Context, key string) *redis.StringCmd {
	if mock.SRandMemberFunc == nil {
		panic("MoqCmdable.SRandMemberFunc: method is nil but Cmdable.SRandMember was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockSRandMember.Lock()
	mock.calls.SRandMember = append(mock.calls.SRandMember, callInfo)
	mock.lockSRandMember.Unlock()
	return mock.SRandMemberFunc(ctx, key)
}

// SRandMemberCalls gets all the calls that were made to SRandMember.
// Check the length with:
//
//	len(mockedCmdable.SRandMemberCalls())
func (mock *MoqCmdable) SRandMemberCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockSRandMember.RLock()
	calls = mock.calls.SRandMember
	mock.lockSRandMember.RUnlock()
	return calls
}

// ResetSRandMemberCalls reset all the calls that were made to SRandMember.
func (mock *MoqCmdable) ResetSRandMemberCalls() {
	mock.lockSRandMember.Lock()
	mock.calls.SRandMember = nil
	mock.lockSRandMember.Unlock()
}

// SRandMemberN calls SRandMemberNFunc.
func (mock *MoqCmdable) SRandMemberN(ctx context.Context, key string, count int64) *redis.StringSliceCmd {
	if mock.SRandMemberNFunc == nil {
		panic("MoqCmdable.SRandMemberNFunc: method is nil but Cmdable.SRandMemberN was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Count int64
	}{
		Ctx:   ctx,
		Key:   key,
		Count: count,
	}
	mock.lockSRandMemberN.Lock()
	mock.calls.SRandMemberN = append(mock.calls.SRandMemberN, callInfo)
	mock.lockSRandMemberN.Unlock()
	return mock.SRandMemberNFunc(ctx, key, count)
}

// SRandMemberNCalls gets all the calls that were made to SRandMemberN.
// Check the length with:
//
//	len(mockedCmdable.SRandMemberNCalls())
func (mock *MoqCmdable) SRandMemberNCalls() []struct {
	Ctx   context.Context
	Key   string
	Count int64
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Count int64
	}
	mock.lockSRandMemberN.RLock()
	calls = mock.calls.SRandMemberN
	mock.lockSRandMemberN.RUnlock()
	return calls
}

// ResetSRandMemberNCalls reset all the calls that were made to SRandMemberN.
func (mock *MoqCmdable) ResetSRandMemberNCalls() {
	mock.lockSRandMemberN.Lock()
	mock.calls.SRandMemberN = nil
	mock.lockSRandMemberN.Unlock()
}

// SRem calls SRemFunc.
func (mock *MoqCmdable) SRem(ctx context.Context, key string, members ...interface{}) *redis.IntCmd {
	if mock.SRemFunc == nil {
		panic("MoqCmdable.SRemFunc: method is nil but Cmdable.SRem was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Key     string
		Members []interface{}
	}{
		Ctx:     ctx,
		Key:     key,
		Members: members,
	}
	mock.lockSRem.Lock()
	mock.calls.SRem = append(mock.calls.SRem, callInfo)
	mock.lockSRem.Unlock()
	return mock.SRemFunc(ctx, key, members...)
}

// SRemCalls gets all the calls that were made to SRem.
// Check the length with:
//
//	len(mockedCmdable.SRemCalls())
func (mock *MoqCmdable) SRemCalls() []struct {
	Ctx     context.Context
	Key     string
	Members []interface{}
} {
	var calls []struct {
		Ctx     context.Context
		Key     string
		Members []interface{}
	}
	mock.lockSRem.RLock()
	calls = mock.calls.SRem
	mock.lockSRem.RUnlock()
	return calls
}

// ResetSRemCalls reset all the calls that were made to SRem.
func (mock *MoqCmdable) ResetSRemCalls() {
	mock.lockSRem.Lock()
	mock.calls.SRem = nil
	mock.lockSRem.Unlock()
}

// SScan calls SScanFunc.
func (mock *MoqCmdable) SScan(ctx context.Context, key string, cursor uint64, match string, count int64) *redis.ScanCmd {
	if mock.SScanFunc == nil {
		panic("MoqCmdable.SScanFunc: method is nil but Cmdable.SScan was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		Cursor uint64
		Match  string
		Count  int64
	}{
		Ctx:    ctx,
		Key:    key,
		Cursor: cursor,
		Match:  match,
		Count:  count,
	}
	mock.lockSScan.Lock()
	mock.calls.SScan = append(mock.calls.SScan, callInfo)
	mock.lockSScan.Unlock()
	return mock.SScanFunc(ctx, key, cursor, match, count)
}

// SScanCalls gets all the calls that were made to SScan.
// Check the length with:
//
//	len(mockedCmdable.SScanCalls())
func (mock *MoqCmdable) SScanCalls() []struct {
	Ctx    context.Context
	Key    string
	Cursor uint64
	Match  string
	Count  int64
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		Cursor uint64
		Match  string
		Count  int64
	}
	mock.lockSScan.RLock()
	calls = mock.calls.SScan
	mock.lockSScan.RUnlock()
	return calls
}

// ResetSScanCalls reset all the calls that were made to SScan.
func (mock *MoqCmdable) ResetSScanCalls() {
	mock.lockSScan.Lock()
	mock.calls.SScan = nil
	mock.lockSScan.Unlock()
}

// SUnion calls SUnionFunc.
func (mock *MoqCmdable) SUnion(ctx context.Context, keys ...string) *redis.StringSliceCmd {
	if mock.SUnionFunc == nil {
		panic("MoqCmdable.SUnionFunc: method is nil but Cmdable.SUnion was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Keys []string
	}{
		Ctx:  ctx,
		Keys: keys,
	}
	mock.lockSUnion.Lock()
	mock.calls.SUnion = append(mock.calls.SUnion, callInfo)
	mock.lockSUnion.Unlock()
	return mock.SUnionFunc(ctx, keys...)
}

// SUnionCalls gets all the calls that were made to SUnion.
// Check the length with:
//
//	len(mockedCmdable.SUnionCalls())
func (mock *MoqCmdable) SUnionCalls() []struct {
	Ctx  context.Context
	Keys []string
} {
	var calls []struct {
		Ctx  context.Context
		Keys []string
	}
	mock.lockSUnion.RLock()
	calls = mock.calls.SUnion
	mock.lockSUnion.RUnlock()
	return calls
}

// ResetSUnionCalls reset all the calls that were made to SUnion.
func (mock *MoqCmdable) ResetSUnionCalls() {
	mock.lockSUnion.Lock()
	mock.calls.SUnion = nil
	mock.lockSUnion.Unlock()
}

// SUnionStore calls SUnionStoreFunc.
func (mock *MoqCmdable) SUnionStore(ctx context.Context, destination string, keys ...string) *redis.IntCmd {
	if mock.SUnionStoreFunc == nil {
		panic("MoqCmdable.SUnionStoreFunc: method is nil but Cmdable.SUnionStore was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		Destination string
		Keys        []string
	}{
		Ctx:         ctx,
		Destination: destination,
		Keys:        keys,
	}
	mock.lockSUnionStore.Lock()
	mock.calls.SUnionStore = append(mock.calls.SUnionStore, callInfo)
	mock.lockSUnionStore.Unlock()
	return mock.SUnionStoreFunc(ctx, destination, keys...)
}

// SUnionStoreCalls gets all the calls that were made to SUnionStore.
// Check the length with:
//
//	len(mockedCmdable.SUnionStoreCalls())
func (mock *MoqCmdable) SUnionStoreCalls() []struct {
	Ctx         context.Context
	Destination string
	Keys        []string
} {
	var calls []struct {
		Ctx         context.Context
		Destination string
		Keys        []string
	}
	mock.lockSUnionStore.RLock()
	calls = mock.calls.SUnionStore
	mock.lockSUnionStore.RUnlock()
	return calls
}

// ResetSUnionStoreCalls reset all the calls that were made to SUnionStore.
func (mock *MoqCmdable) ResetSUnionStoreCalls() {
	mock.lockSUnionStore.Lock()
	mock.calls.SUnionStore = nil
	mock.lockSUnionStore.Unlock()
}

// Save calls SaveFunc.
func (mock *MoqCmdable) Save(ctx context.Context) *redis.StatusCmd {
	if mock.SaveFunc == nil {
		panic("MoqCmdable.SaveFunc: method is nil but Cmdable.Save was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockSave.Lock()
	mock.calls.Save = append(mock.calls.Save, callInfo)
	mock.lockSave.Unlock()
	return mock.SaveFunc(ctx)
}

// SaveCalls gets all the calls that were made to Save.
// Check the length with:
//
//	len(mockedCmdable.SaveCalls())
func (mock *MoqCmdable) SaveCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockSave.RLock()
	calls = mock.calls.Save
	mock.lockSave.RUnlock()
	return calls
}

// ResetSaveCalls reset all the calls that were made to Save.
func (mock *MoqCmdable) ResetSaveCalls() {
	mock.lockSave.Lock()
	mock.calls.Save = nil
	mock.lockSave.Unlock()
}

// Scan calls ScanFunc.
func (mock *MoqCmdable) Scan(ctx context.Context, cursor uint64, match string, count int64) *redis.ScanCmd {
	if mock.ScanFunc == nil {
		panic("MoqCmdable.ScanFunc: method is nil but Cmdable.Scan was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Cursor uint64
		Match  string
		Count  int64
	}{
		Ctx:    ctx,
		Cursor: cursor,
		Match:  match,
		Count:  count,
	}
	mock.lockScan.Lock()
	mock.calls.Scan = append(mock.calls.Scan, callInfo)
	mock.lockScan.Unlock()
	return mock.ScanFunc(ctx, cursor, match, count)
}

// ScanCalls gets all the calls that were made to Scan.
// Check the length with:
//
//	len(mockedCmdable.ScanCalls())
func (mock *MoqCmdable) ScanCalls() []struct {
	Ctx    context.Context
	Cursor uint64
	Match  string
	Count  int64
} {
	var calls []struct {
		Ctx    context.Context
		Cursor uint64
		Match  string
		Count  int64
	}
	mock.lockScan.RLock()
	calls = mock.calls.Scan
	mock.lockScan.RUnlock()
	return calls
}

// ResetScanCalls reset all the calls that were made to Scan.
func (mock *MoqCmdable) ResetScanCalls() {
	mock.lockScan.Lock()
	mock.calls.Scan = nil
	mock.lockScan.Unlock()
}

// ScanType calls ScanTypeFunc.
func (mock *MoqCmdable) ScanType(ctx context.Context, cursor uint64, match string, count int64, keyType string) *redis.ScanCmd {
	if mock.ScanTypeFunc == nil {
		panic("MoqCmdable.ScanTypeFunc: method is nil but Cmdable.ScanType was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Cursor  uint64
		Match   string
		Count   int64
		KeyType string
	}{
		Ctx:     ctx,
		Cursor:  cursor,
		Match:   match,
		Count:   count,
		KeyType: keyType,
	}
	mock.lockScanType.Lock()
	mock.calls.ScanType = append(mock.calls.ScanType, callInfo)
	mock.lockScanType.Unlock()
	return mock.ScanTypeFunc(ctx, cursor, match, count, keyType)
}

// ScanTypeCalls gets all the calls that were made to ScanType.
// Check the length with:
//
//	len(mockedCmdable.ScanTypeCalls())
func (mock *MoqCmdable) ScanTypeCalls() []struct {
	Ctx     context.Context
	Cursor  uint64
	Match   string
	Count   int64
	KeyType string
} {
	var calls []struct {
		Ctx     context.Context
		Cursor  uint64
		Match   string
		Count   int64
		KeyType string
	}
	mock.lockScanType.RLock()
	calls = mock.calls.ScanType
	mock.lockScanType.RUnlock()
	return calls
}

// ResetScanTypeCalls reset all the calls that were made to ScanType.
func (mock *MoqCmdable) ResetScanTypeCalls() {
	mock.lockScanType.Lock()
	mock.calls.ScanType = nil
	mock.lockScanType.Unlock()
}

// ScriptExists calls ScriptExistsFunc.
func (mock *MoqCmdable) ScriptExists(ctx context.Context, hashes ...string) *redis.BoolSliceCmd {
	if mock.ScriptExistsFunc == nil {
		panic("MoqCmdable.ScriptExistsFunc: method is nil but Cmdable.ScriptExists was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Hashes []string
	}{
		Ctx:    ctx,
		Hashes: hashes,
	}
	mock.lockScriptExists.Lock()
	mock.calls.ScriptExists = append(mock.calls.ScriptExists, callInfo)
	mock.lockScriptExists.Unlock()
	return mock.ScriptExistsFunc(ctx, hashes...)
}

// ScriptExistsCalls gets all the calls that were made to ScriptExists.
// Check the length with:
//
//	len(mockedCmdable.ScriptExistsCalls())
func (mock *MoqCmdable) ScriptExistsCalls() []struct {
	Ctx    context.Context
	Hashes []string
} {
	var calls []struct {
		Ctx    context.Context
		Hashes []string
	}
	mock.lockScriptExists.RLock()
	calls = mock.calls.ScriptExists
	mock.lockScriptExists.RUnlock()
	return calls
}

// ResetScriptExistsCalls reset all the calls that were made to ScriptExists.
func (mock *MoqCmdable) ResetScriptExistsCalls() {
	mock.lockScriptExists.Lock()
	mock.calls.ScriptExists = nil
	mock.lockScriptExists.Unlock()
}

// ScriptFlush calls ScriptFlushFunc.
func (mock *MoqCmdable) ScriptFlush(ctx context.Context) *redis.StatusCmd {
	if mock.ScriptFlushFunc == nil {
		panic("MoqCmdable.ScriptFlushFunc: method is nil but Cmdable.ScriptFlush was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockScriptFlush.Lock()
	mock.calls.ScriptFlush = append(mock.calls.ScriptFlush, callInfo)
	mock.lockScriptFlush.Unlock()
	return mock.ScriptFlushFunc(ctx)
}

// ScriptFlushCalls gets all the calls that were made to ScriptFlush.
// Check the length with:
//
//	len(mockedCmdable.ScriptFlushCalls())
func (mock *MoqCmdable) ScriptFlushCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockScriptFlush.RLock()
	calls = mock.calls.ScriptFlush
	mock.lockScriptFlush.RUnlock()
	return calls
}

// ResetScriptFlushCalls reset all the calls that were made to ScriptFlush.
func (mock *MoqCmdable) ResetScriptFlushCalls() {
	mock.lockScriptFlush.Lock()
	mock.calls.ScriptFlush = nil
	mock.lockScriptFlush.Unlock()
}

// ScriptKill calls ScriptKillFunc.
func (mock *MoqCmdable) ScriptKill(ctx context.Context) *redis.StatusCmd {
	if mock.ScriptKillFunc == nil {
		panic("MoqCmdable.ScriptKillFunc: method is nil but Cmdable.ScriptKill was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockScriptKill.Lock()
	mock.calls.ScriptKill = append(mock.calls.ScriptKill, callInfo)
	mock.lockScriptKill.Unlock()
	return mock.ScriptKillFunc(ctx)
}

// ScriptKillCalls gets all the calls that were made to ScriptKill.
// Check the length with:
//
//	len(mockedCmdable.ScriptKillCalls())
func (mock *MoqCmdable) ScriptKillCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockScriptKill.RLock()
	calls = mock.calls.ScriptKill
	mock.lockScriptKill.RUnlock()
	return calls
}

// ResetScriptKillCalls reset all the calls that were made to ScriptKill.
func (mock *MoqCmdable) ResetScriptKillCalls() {
	mock.lockScriptKill.Lock()
	mock.calls.ScriptKill = nil
	mock.lockScriptKill.Unlock()
}

// ScriptLoad calls ScriptLoadFunc.
func (mock *MoqCmdable) ScriptLoad(ctx context.Context, script string) *redis.StringCmd {
	if mock.ScriptLoadFunc == nil {
		panic("MoqCmdable.ScriptLoadFunc: method is nil but Cmdable.ScriptLoad was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Script string
	}{
		Ctx:    ctx,
		Script: script,
	}
	mock.lockScriptLoad.Lock()
	mock.calls.ScriptLoad = append(mock.calls.ScriptLoad, callInfo)
	mock.lockScriptLoad.Unlock()
	return mock.ScriptLoadFunc(ctx, script)
}

// ScriptLoadCalls gets all the calls that were made to ScriptLoad.
// Check the length with:
//
//	len(mockedCmdable.ScriptLoadCalls())
func (mock *MoqCmdable) ScriptLoadCalls() []struct {
	Ctx    context.Context
	Script string
} {
	var calls []struct {
		Ctx    context.Context
		Script string
	}
	mock.lockScriptLoad.RLock()
	calls = mock.calls.ScriptLoad
	mock.lockScriptLoad.RUnlock()
	return calls
}

// ResetScriptLoadCalls reset all the calls that were made to ScriptLoad.
func (mock *MoqCmdable) ResetScriptLoadCalls() {
	mock.lockScriptLoad.Lock()
	mock.calls.ScriptLoad = nil
	mock.lockScriptLoad.Unlock()
}

// Set calls SetFunc.
func (mock *MoqCmdable) Set(ctx context.Context, key string, value interface{}, expiration time.Duration) *redis.StatusCmd {
	if mock.SetFunc == nil {
		panic("MoqCmdable.SetFunc: method is nil but Cmdable.Set was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Key        string
		Value      interface{}
		Expiration time.Duration
	}{
		Ctx:        ctx,
		Key:        key,
		Value:      value,
		Expiration: expiration,
	}
	mock.lockSet.Lock()
	mock.calls.Set = append(mock.calls.Set, callInfo)
	mock.lockSet.Unlock()
	return mock.SetFunc(ctx, key, value, expiration)
}

// SetCalls gets all the calls that were made to Set.
// Check the length with:
//
//	len(mockedCmdable.SetCalls())
func (mock *MoqCmdable) SetCalls() []struct {
	Ctx        context.Context
	Key        string
	Value      interface{}
	Expiration time.Duration
} {
	var calls []struct {
		Ctx        context.Context
		Key        string
		Value      interface{}
		Expiration time.Duration
	}
	mock.lockSet.RLock()
	calls = mock.calls.Set
	mock.lockSet.RUnlock()
	return calls
}

// ResetSetCalls reset all the calls that were made to Set.
func (mock *MoqCmdable) ResetSetCalls() {
	mock.lockSet.Lock()
	mock.calls.Set = nil
	mock.lockSet.Unlock()
}

// SetArgs calls SetArgsFunc.
func (mock *MoqCmdable) SetArgs(ctx context.Context, key string, value interface{}, a redis.SetArgs) *redis.StatusCmd {
	if mock.SetArgsFunc == nil {
		panic("MoqCmdable.SetArgsFunc: method is nil but Cmdable.SetArgs was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Value interface{}
		A     redis.SetArgs
	}{
		Ctx:   ctx,
		Key:   key,
		Value: value,
		A:     a,
	}
	mock.lockSetArgs.Lock()
	mock.calls.SetArgs = append(mock.calls.SetArgs, callInfo)
	mock.lockSetArgs.Unlock()
	return mock.SetArgsFunc(ctx, key, value, a)
}

// SetArgsCalls gets all the calls that were made to SetArgs.
// Check the length with:
//
//	len(mockedCmdable.SetArgsCalls())
func (mock *MoqCmdable) SetArgsCalls() []struct {
	Ctx   context.Context
	Key   string
	Value interface{}
	A     redis.SetArgs
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Value interface{}
		A     redis.SetArgs
	}
	mock.lockSetArgs.RLock()
	calls = mock.calls.SetArgs
	mock.lockSetArgs.RUnlock()
	return calls
}

// ResetSetArgsCalls reset all the calls that were made to SetArgs.
func (mock *MoqCmdable) ResetSetArgsCalls() {
	mock.lockSetArgs.Lock()
	mock.calls.SetArgs = nil
	mock.lockSetArgs.Unlock()
}

// SetBit calls SetBitFunc.
func (mock *MoqCmdable) SetBit(ctx context.Context, key string, offset int64, value int) *redis.IntCmd {
	if mock.SetBitFunc == nil {
		panic("MoqCmdable.SetBitFunc: method is nil but Cmdable.SetBit was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		Offset int64
		Value  int
	}{
		Ctx:    ctx,
		Key:    key,
		Offset: offset,
		Value:  value,
	}
	mock.lockSetBit.Lock()
	mock.calls.SetBit = append(mock.calls.SetBit, callInfo)
	mock.lockSetBit.Unlock()
	return mock.SetBitFunc(ctx, key, offset, value)
}

// SetBitCalls gets all the calls that were made to SetBit.
// Check the length with:
//
//	len(mockedCmdable.SetBitCalls())
func (mock *MoqCmdable) SetBitCalls() []struct {
	Ctx    context.Context
	Key    string
	Offset int64
	Value  int
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		Offset int64
		Value  int
	}
	mock.lockSetBit.RLock()
	calls = mock.calls.SetBit
	mock.lockSetBit.RUnlock()
	return calls
}

// ResetSetBitCalls reset all the calls that were made to SetBit.
func (mock *MoqCmdable) ResetSetBitCalls() {
	mock.lockSetBit.Lock()
	mock.calls.SetBit = nil
	mock.lockSetBit.Unlock()
}

// SetEx calls SetExFunc.
func (mock *MoqCmdable) SetEx(ctx context.Context, key string, value interface{}, expiration time.Duration) *redis.StatusCmd {
	if mock.SetExFunc == nil {
		panic("MoqCmdable.SetExFunc: method is nil but Cmdable.SetEx was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Key        string
		Value      interface{}
		Expiration time.Duration
	}{
		Ctx:        ctx,
		Key:        key,
		Value:      value,
		Expiration: expiration,
	}
	mock.lockSetEx.Lock()
	mock.calls.SetEx = append(mock.calls.SetEx, callInfo)
	mock.lockSetEx.Unlock()
	return mock.SetExFunc(ctx, key, value, expiration)
}

// SetExCalls gets all the calls that were made to SetEx.
// Check the length with:
//
//	len(mockedCmdable.SetExCalls())
func (mock *MoqCmdable) SetExCalls() []struct {
	Ctx        context.Context
	Key        string
	Value      interface{}
	Expiration time.Duration
} {
	var calls []struct {
		Ctx        context.Context
		Key        string
		Value      interface{}
		Expiration time.Duration
	}
	mock.lockSetEx.RLock()
	calls = mock.calls.SetEx
	mock.lockSetEx.RUnlock()
	return calls
}

// ResetSetExCalls reset all the calls that were made to SetEx.
func (mock *MoqCmdable) ResetSetExCalls() {
	mock.lockSetEx.Lock()
	mock.calls.SetEx = nil
	mock.lockSetEx.Unlock()
}

// SetIFDEQ calls SetIFDEQFunc.
func (mock *MoqCmdable) SetIFDEQ(ctx context.Context, key string, value interface{}, matchDigest uint64, expiration time.Duration) *redis.StatusCmd {
	if mock.SetIFDEQFunc == nil {
		panic("MoqCmdable.SetIFDEQFunc: method is nil but Cmdable.SetIFDEQ was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		Key         string
		Value       interface{}
		MatchDigest uint64
		Expiration  time.Duration
	}{
		Ctx:         ctx,
		Key:         key,
		Value:       value,
		MatchDigest: matchDigest,
		Expiration:  expiration,
	}
	mock.lockSetIFDEQ.Lock()
	mock.calls.SetIFDEQ = append(mock.calls.SetIFDEQ, callInfo)
	mock.lockSetIFDEQ.Unlock()
	return mock.SetIFDEQFunc(ctx, key, value, matchDigest, expiration)
}

// SetIFDEQCalls gets all the calls that were made to SetIFDEQ.
// Check the length with:
//
//	len(mockedCmdable.SetIFDEQCalls())
func (mock *MoqCmdable) SetIFDEQCalls() []struct {
	Ctx         context.Context
	Key         string
	Value       interface{}
	MatchDigest uint64
	Expiration  time.Duration
} {
	var calls []struct {
		Ctx         context.Context
		Key         string
		Value       interface{}
		MatchDigest uint64
		Expiration  time.Duration
	}
	mock.lockSetIFDEQ.RLock()
	calls = mock.calls.SetIFDEQ
	mock.lockSetIFDEQ.RUnlock()
	return calls
}

// ResetSetIFDEQCalls reset all the calls that were made to SetIFDEQ.
func (mock *MoqCmdable) ResetSetIFDEQCalls() {
	mock.lockSetIFDEQ.Lock()
	mock.calls.SetIFDEQ = nil
	mock.lockSetIFDEQ.Unlock()
}

// SetIFDEQGet calls SetIFDEQGetFunc.
func (mock *MoqCmdable) SetIFDEQGet(ctx context.Context, key string, value interface{}, matchDigest uint64, expiration time.Duration) *redis.StringCmd {
	if mock.SetIFDEQGetFunc == nil {
		panic("MoqCmdable.SetIFDEQGetFunc: method is nil but Cmdable.SetIFDEQGet was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		Key         string
		Value       interface{}
		MatchDigest uint64
		Expiration  time.Duration
	}{
		Ctx:         ctx,
		Key:         key,
		Value:       value,
		MatchDigest: matchDigest,
		Expiration:  expiration,
	}
	mock.lockSetIFDEQGet.Lock()
	mock.calls.SetIFDEQGet = append(mock.calls.SetIFDEQGet, callInfo)
	mock.lockSetIFDEQGet.Unlock()
	return mock.SetIFDEQGetFunc(ctx, key, value, matchDigest, expiration)
}

// SetIFDEQGetCalls gets all the calls that were made to SetIFDEQGet.
// Check the length with:
//
//	len(mockedCmdable.SetIFDEQGetCalls())
func (mock *MoqCmdable) SetIFDEQGetCalls() []struct {
	Ctx         context.Context
	Key         string
	Value       interface{}
	MatchDigest uint64
	Expiration  time.Duration
} {
	var calls []struct {
		Ctx         context.Context
		Key         string
		Value       interface{}
		MatchDigest uint64
		Expiration  time.Duration
	}
	mock.lockSetIFDEQGet.RLock()
	calls = mock.calls.SetIFDEQGet
	mock.lockSetIFDEQGet.RUnlock()
	return calls
}

// ResetSetIFDEQGetCalls reset all the calls that were made to SetIFDEQGet.
func (mock *MoqCmdable) ResetSetIFDEQGetCalls() {
	mock.lockSetIFDEQGet.Lock()
	mock.calls.SetIFDEQGet = nil
	mock.lockSetIFDEQGet.Unlock()
}

// SetIFDNE calls SetIFDNEFunc.
func (mock *MoqCmdable) SetIFDNE(ctx context.Context, key string, value interface{}, matchDigest uint64, expiration time.Duration) *redis.StatusCmd {
	if mock.SetIFDNEFunc == nil {
		panic("MoqCmdable.SetIFDNEFunc: method is nil but Cmdable.SetIFDNE was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		Key         string
		Value       interface{}
		MatchDigest uint64
		Expiration  time.Duration
	}{
		Ctx:         ctx,
		Key:         key,
		Value:       value,
		MatchDigest: matchDigest,
		Expiration:  expiration,
	}
	mock.lockSetIFDNE.Lock()
	mock.calls.SetIFDNE = append(mock.calls.SetIFDNE, callInfo)
	mock.lockSetIFDNE.Unlock()
	return mock.SetIFDNEFunc(ctx, key, value, matchDigest, expiration)
}

// SetIFDNECalls gets all the calls that were made to SetIFDNE.
// Check the length with:
//
//	len(mockedCmdable.SetIFDNECalls())
func (mock *MoqCmdable) SetIFDNECalls() []struct {
	Ctx         context.Context
	Key         string
	Value       interface{}
	MatchDigest uint64
	Expiration  time.Duration
} {
	var calls []struct {
		Ctx         context.Context
		Key         string
		Value       interface{}
		MatchDigest uint64
		Expiration  time.Duration
	}
	mock.lockSetIFDNE.RLock()
	calls = mock.calls.SetIFDNE
	mock.lockSetIFDNE.RUnlock()
	return calls
}

// ResetSetIFDNECalls reset all the calls that were made to SetIFDNE.
func (mock *MoqCmdable) ResetSetIFDNECalls() {
	mock.lockSetIFDNE.Lock()
	mock.calls.SetIFDNE = nil
	mock.lockSetIFDNE.Unlock()
}

// SetIFDNEGet calls SetIFDNEGetFunc.
func (mock *MoqCmdable) SetIFDNEGet(ctx context.Context, key string, value interface{}, matchDigest uint64, expiration time.Duration) *redis.StringCmd {
	if mock.SetIFDNEGetFunc == nil {
		panic("MoqCmdable.SetIFDNEGetFunc: method is nil but Cmdable.SetIFDNEGet was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		Key         string
		Value       interface{}
		MatchDigest uint64
		Expiration  time.Duration
	}{
		Ctx:         ctx,
		Key:         key,
		Value:       value,
		MatchDigest: matchDigest,
		Expiration:  expiration,
	}
	mock.lockSetIFDNEGet.Lock()
	mock.calls.SetIFDNEGet = append(mock.calls.SetIFDNEGet, callInfo)
	mock.lockSetIFDNEGet.Unlock()
	return mock.SetIFDNEGetFunc(ctx, key, value, matchDigest, expiration)
}

// SetIFDNEGetCalls gets all the calls that were made to SetIFDNEGet.
// Check the length with:
//
//	len(mockedCmdable.SetIFDNEGetCalls())
func (mock *MoqCmdable) SetIFDNEGetCalls() []struct {
	Ctx         context.Context
	Key         string
	Value       interface{}
	MatchDigest uint64
	Expiration  time.Duration
} {
	var calls []struct {
		Ctx         context.Context
		Key         string
		Value       interface{}
		MatchDigest uint64
		Expiration  time.Duration
	}
	mock.lockSetIFDNEGet.RLock()
	calls = mock.calls.SetIFDNEGet
	mock.lockSetIFDNEGet.RUnlock()
	return calls
}

// ResetSetIFDNEGetCalls reset all the calls that were made to SetIFDNEGet.
func (mock *MoqCmdable) ResetSetIFDNEGetCalls() {
	mock.lockSetIFDNEGet.Lock()
	mock.calls.SetIFDNEGet = nil
	mock.lockSetIFDNEGet.Unlock()
}

// SetIFEQ calls SetIFEQFunc.
func (mock *MoqCmdable) SetIFEQ(ctx context.Context, key string, value interface{}, matchValue interface{}, expiration time.Duration) *redis.StatusCmd {
	if mock.SetIFEQFunc == nil {
		panic("MoqCmdable.SetIFEQFunc: method is nil but Cmdable.SetIFEQ was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Key        string
		Value      interface{}
		MatchValue interface{}
		Expiration time.Duration
	}{
		Ctx:        ctx,
		Key:        key,
		Value:      value,
		MatchValue: matchValue,
		Expiration: expiration,
	}
	mock.lockSetIFEQ.Lock()
	mock.calls.SetIFEQ = append(mock.calls.SetIFEQ, callInfo)
	mock.lockSetIFEQ.Unlock()
	return mock.SetIFEQFunc(ctx, key, value, matchValue, expiration)
}

// SetIFEQCalls gets all the calls that were made to SetIFEQ.
// Check the length with:
//
//	len(mockedCmdable.SetIFEQCalls())
func (mock *MoqCmdable) SetIFEQCalls() []struct {
	Ctx        context.Context
	Key        string
	Value      interface{}
	MatchValue interface{}
	Expiration time.Duration
} {
	var calls []struct {
		Ctx        context.Context
		Key        string
		Value      interface{}
		MatchValue interface{}
		Expiration time.Duration
	}
	mock.lockSetIFEQ.RLock()
	calls = mock.calls.SetIFEQ
	mock.lockSetIFEQ.RUnlock()
	return calls
}

// ResetSetIFEQCalls reset all the calls that were made to SetIFEQ.
func (mock *MoqCmdable) ResetSetIFEQCalls() {
	mock.lockSetIFEQ.Lock()
	mock.calls.SetIFEQ = nil
	mock.lockSetIFEQ.Unlock()
}

// SetIFEQGet calls SetIFEQGetFunc.
func (mock *MoqCmdable) SetIFEQGet(ctx context.Context, key string, value interface{}, matchValue interface{}, expiration time.Duration) *redis.StringCmd {
	if mock.SetIFEQGetFunc == nil {
		panic("MoqCmdable.SetIFEQGetFunc: method is nil but Cmdable.SetIFEQGet was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Key        string
		Value      interface{}
		MatchValue interface{}
		Expiration time.Duration
	}{
		Ctx:        ctx,
		Key:        key,
		Value:      value,
		MatchValue: matchValue,
		Expiration: expiration,
	}
	mock.lockSetIFEQGet.Lock()
	mock.calls.SetIFEQGet = append(mock.calls.SetIFEQGet, callInfo)
	mock.lockSetIFEQGet.Unlock()
	return mock.SetIFEQGetFunc(ctx, key, value, matchValue, expiration)
}

// SetIFEQGetCalls gets all the calls that were made to SetIFEQGet.
// Check the length with:
//
//	len(mockedCmdable.SetIFEQGetCalls())
func (mock *MoqCmdable) SetIFEQGetCalls() []struct {
	Ctx        context.Context
	Key        string
	Value      interface{}
	MatchValue interface{}
	Expiration time.Duration
} {
	var calls []struct {
		Ctx        context.Context
		Key        string
		Value      interface{}
		MatchValue interface{}
		Expiration time.Duration
	}
	mock.lockSetIFEQGet.RLock()
	calls = mock.calls.SetIFEQGet
	mock.lockSetIFEQGet.RUnlock()
	return calls
}

// ResetSetIFEQGetCalls reset all the calls that were made to SetIFEQGet.
func (mock *MoqCmdable) ResetSetIFEQGetCalls() {
	mock.lockSetIFEQGet.Lock()
	mock.calls.SetIFEQGet = nil
	mock.lockSetIFEQGet.Unlock()
}

// SetIFNE calls SetIFNEFunc.
func (mock *MoqCmdable) SetIFNE(ctx context.Context, key string, value interface{}, matchValue interface{}, expiration time.Duration) *redis.StatusCmd {
	if mock.SetIFNEFunc == nil {
		panic("MoqCmdable.SetIFNEFunc: method is nil but Cmdable.SetIFNE was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Key        string
		Value      interface{}
		MatchValue interface{}
		Expiration time.Duration
	}{
		Ctx:        ctx,
		Key:        key,
		Value:      value,
		MatchValue: matchValue,
		Expiration: expiration,
	}
	mock.lockSetIFNE.Lock()
	mock.calls.SetIFNE = append(mock.calls.SetIFNE, callInfo)
	mock.lockSetIFNE.Unlock()
	return mock.SetIFNEFunc(ctx, key, value, matchValue, expiration)
}

// SetIFNECalls gets all the calls that were made to SetIFNE.
// Check the length with:
//
//	len(mockedCmdable.SetIFNECalls())
func (mock *MoqCmdable) SetIFNECalls() []struct {
	Ctx        context.Context
	Key        string
	Value      interface{}
	MatchValue interface{}
	Expiration time.Duration
} {
	var calls []struct {
		Ctx        context.Context
		Key        string
		Value      interface{}
		MatchValue interface{}
		Expiration time.Duration
	}
	mock.lockSetIFNE.RLock()
	calls = mock.calls.SetIFNE
	mock.lockSetIFNE.RUnlock()
	return calls
}

// ResetSetIFNECalls reset all the calls that were made to SetIFNE.
func (mock *MoqCmdable) ResetSetIFNECalls() {
	mock.lockSetIFNE.Lock()
	mock.calls.SetIFNE = nil
	mock.lockSetIFNE.Unlock()
}

// SetIFNEGet calls SetIFNEGetFunc.
func (mock *MoqCmdable) SetIFNEGet(ctx context.Context, key string, value interface{}, matchValue interface{}, expiration time.Duration) *redis.StringCmd {
	if mock.SetIFNEGetFunc == nil {
		panic("MoqCmdable.SetIFNEGetFunc: method is nil but Cmdable.SetIFNEGet was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Key        string
		Value      interface{}
		MatchValue interface{}
		Expiration time.Duration
	}{
		Ctx:        ctx,
		Key:        key,
		Value:      value,
		MatchValue: matchValue,
		Expiration: expiration,
	}
	mock.lockSetIFNEGet.Lock()
	mock.calls.SetIFNEGet = append(mock.calls.SetIFNEGet, callInfo)
	mock.lockSetIFNEGet.Unlock()
	return mock.SetIFNEGetFunc(ctx, key, value, matchValue, expiration)
}

// SetIFNEGetCalls gets all the calls that were made to SetIFNEGet.
// Check the length with:
//
//	len(mockedCmdable.SetIFNEGetCalls())
func (mock *MoqCmdable) SetIFNEGetCalls() []struct {
	Ctx        context.Context
	Key        string
	Value      interface{}
	MatchValue interface{}
	Expiration time.Duration
} {
	var calls []struct {
		Ctx        context.Context
		Key        string
		Value      interface{}
		MatchValue interface{}
		Expiration time.Duration
	}
	mock.lockSetIFNEGet.RLock()
	calls = mock.calls.SetIFNEGet
	mock.lockSetIFNEGet.RUnlock()
	return calls
}

// ResetSetIFNEGetCalls reset all the calls that were made to SetIFNEGet.
func (mock *MoqCmdable) ResetSetIFNEGetCalls() {
	mock.lockSetIFNEGet.Lock()
	mock.calls.SetIFNEGet = nil
	mock.lockSetIFNEGet.Unlock()
}

// SetNX calls SetNXFunc.
func (mock *MoqCmdable) SetNX(ctx context.Context, key string, value interface{}, expiration time.Duration) *redis.BoolCmd {
	if mock.SetNXFunc == nil {
		panic("MoqCmdable.SetNXFunc: method is nil but Cmdable.SetNX was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Key        string
		Value      interface{}
		Expiration time.Duration
	}{
		Ctx:        ctx,
		Key:        key,
		Value:      value,
		Expiration: expiration,
	}
	mock.lockSetNX.Lock()
	mock.calls.SetNX = append(mock.calls.SetNX, callInfo)
	mock.lockSetNX.Unlock()
	return mock.SetNXFunc(ctx, key, value, expiration)
}

// SetNXCalls gets all the calls that were made to SetNX.
// Check the length with:
//
//	len(mockedCmdable.SetNXCalls())
func (mock *MoqCmdable) SetNXCalls() []struct {
	Ctx        context.Context
	Key        string
	Value      interface{}
	Expiration time.Duration
} {
	var calls []struct {
		Ctx        context.Context
		Key        string
		Value      interface{}
		Expiration time.Duration
	}
	mock.lockSetNX.RLock()
	calls = mock.calls.SetNX
	mock.lockSetNX.RUnlock()
	return calls
}

// ResetSetNXCalls reset all the calls that were made to SetNX.
func (mock *MoqCmdable) ResetSetNXCalls() {
	mock.lockSetNX.Lock()
	mock.calls.SetNX = nil
	mock.lockSetNX.Unlock()
}

// SetRange calls SetRangeFunc.
func (mock *MoqCmdable) SetRange(ctx context.Context, key string, offset int64, value string) *redis.IntCmd {
	if mock.SetRangeFunc == nil {
		panic("MoqCmdable.SetRangeFunc: method is nil but Cmdable.SetRange was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		Offset int64
		Value  string
	}{
		Ctx:    ctx,
		Key:    key,
		Offset: offset,
		Value:  value,
	}
	mock.lockSetRange.Lock()
	mock.calls.SetRange = append(mock.calls.SetRange, callInfo)
	mock.lockSetRange.Unlock()
	return mock.SetRangeFunc(ctx, key, offset, value)
}

// SetRangeCalls gets all the calls that were made to SetRange.
// Check the length with:
//
//	len(mockedCmdable.SetRangeCalls())
func (mock *MoqCmdable) SetRangeCalls() []struct {
	Ctx    context.Context
	Key    string
	Offset int64
	Value  string
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		Offset int64
		Value  string
	}
	mock.lockSetRange.RLock()
	calls = mock.calls.SetRange
	mock.lockSetRange.RUnlock()
	return calls
}

// ResetSetRangeCalls reset all the calls that were made to SetRange.
func (mock *MoqCmdable) ResetSetRangeCalls() {
	mock.lockSetRange.Lock()
	mock.calls.SetRange = nil
	mock.lockSetRange.Unlock()
}

// SetXX calls SetXXFunc.
func (mock *MoqCmdable) SetXX(ctx context.Context, key string, value interface{}, expiration time.Duration) *redis.BoolCmd {
	if mock.SetXXFunc == nil {
		panic("MoqCmdable.SetXXFunc: method is nil but Cmdable.SetXX was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Key        string
		Value      interface{}
		Expiration time.Duration
	}{
		Ctx:        ctx,
		Key:        key,
		Value:      value,
		Expiration: expiration,
	}
	mock.lockSetXX.Lock()
	mock.calls.SetXX = append(mock.calls.SetXX, callInfo)
	mock.lockSetXX.Unlock()
	return mock.SetXXFunc(ctx, key, value, expiration)
}

// SetXXCalls gets all the calls that were made to SetXX.
// Check the length with:
//
//	len(mockedCmdable.SetXXCalls())
func (mock *MoqCmdable) SetXXCalls() []struct {
	Ctx        context.Context
	Key        string
	Value      interface{}
	Expiration time.Duration
} {
	var calls []struct {
		Ctx        context.Context
		Key        string
		Value      interface{}
		Expiration time.Duration
	}
	mock.lockSetXX.RLock()
	calls = mock.calls.SetXX
	mock.lockSetXX.RUnlock()
	return calls
}

// ResetSetXXCalls reset all the calls that were made to SetXX.
func (mock *MoqCmdable) ResetSetXXCalls() {
	mock.lockSetXX.Lock()
	mock.calls.SetXX = nil
	mock.lockSetXX.Unlock()
}

// Shutdown calls ShutdownFunc.
func (mock *MoqCmdable) Shutdown(ctx context.Context) *redis.StatusCmd {
	if mock.ShutdownFunc == nil {
		panic("MoqCmdable.ShutdownFunc: method is nil but Cmdable.Shutdown was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockShutdown.Lock()
	mock.calls.Shutdown = append(mock.calls.Shutdown, callInfo)
	mock.lockShutdown.Unlock()
	return mock.ShutdownFunc(ctx)
}

// ShutdownCalls gets all the calls that were made to Shutdown.
// Check the length with:
//
//	len(mockedCmdable.ShutdownCalls())
func (mock *MoqCmdable) ShutdownCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockShutdown.RLock()
	calls = mock.calls.Shutdown
	mock.lockShutdown.RUnlock()
	return calls
}

// ResetShutdownCalls reset all the calls that were made to Shutdown.
func (mock *MoqCmdable) ResetShutdownCalls() {
	mock.lockShutdown.Lock()
	mock.calls.Shutdown = nil
	mock.lockShutdown.Unlock()
}

// ShutdownNoSave calls ShutdownNoSaveFunc.
func (mock *MoqCmdable) ShutdownNoSave(ctx context.Context) *redis.StatusCmd {
	if mock.ShutdownNoSaveFunc == nil {
		panic("MoqCmdable.ShutdownNoSaveFunc: method is nil but Cmdable.ShutdownNoSave was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockShutdownNoSave.Lock()
	mock.calls.ShutdownNoSave = append(mock.calls.ShutdownNoSave, callInfo)
	mock.lockShutdownNoSave.Unlock()
	return mock.ShutdownNoSaveFunc(ctx)
}

// ShutdownNoSaveCalls gets all the calls that were made to ShutdownNoSave.
// Check the length with:
//
//	len(mockedCmdable.ShutdownNoSaveCalls())
func (mock *MoqCmdable) ShutdownNoSaveCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockShutdownNoSave.RLock()
	calls = mock.calls.ShutdownNoSave
	mock.lockShutdownNoSave.RUnlock()
	return calls
}

// ResetShutdownNoSaveCalls reset all the calls that were made to ShutdownNoSave.
func (mock *MoqCmdable) ResetShutdownNoSaveCalls() {
	mock.lockShutdownNoSave.Lock()
	mock.calls.ShutdownNoSave = nil
	mock.lockShutdownNoSave.Unlock()
}

// ShutdownSave calls ShutdownSaveFunc.
func (mock *MoqCmdable) ShutdownSave(ctx context.Context) *redis.StatusCmd {
	if mock.ShutdownSaveFunc == nil {
		panic("MoqCmdable.ShutdownSaveFunc: method is nil but Cmdable.ShutdownSave was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockShutdownSave.Lock()
	mock.calls.ShutdownSave = append(mock.calls.ShutdownSave, callInfo)
	mock.lockShutdownSave.Unlock()
	return mock.ShutdownSaveFunc(ctx)
}

// ShutdownSaveCalls gets all the calls that were made to ShutdownSave.
// Check the length with:
//
//	len(mockedCmdable.ShutdownSaveCalls())
func (mock *MoqCmdable) ShutdownSaveCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockShutdownSave.RLock()
	calls = mock.calls.ShutdownSave
	mock.lockShutdownSave.RUnlock()
	return calls
}

// ResetShutdownSaveCalls reset all the calls that were made to ShutdownSave.
func (mock *MoqCmdable) ResetShutdownSaveCalls() {
	mock.lockShutdownSave.Lock()
	mock.calls.ShutdownSave = nil
	mock.lockShutdownSave.Unlock()
}

// SlaveOf calls SlaveOfFunc.
func (mock *MoqCmdable) SlaveOf(ctx context.Context, host string, port string) *redis.StatusCmd {
	if mock.SlaveOfFunc == nil {
		panic("MoqCmdable.SlaveOfFunc: method is nil but Cmdable.SlaveOf was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Host string
		Port string
	}{
		Ctx:  ctx,
		Host: host,
		Port: port,
	}
	mock.lockSlaveOf.Lock()
	mock.calls.SlaveOf = append(mock.calls.SlaveOf, callInfo)
	mock.lockSlaveOf.Unlock()
	return mock.SlaveOfFunc(ctx, host, port)
}

// SlaveOfCalls gets all the calls that were made to SlaveOf.
// Check the length with:
//
//	len(mockedCmdable.SlaveOfCalls())
func (mock *MoqCmdable) SlaveOfCalls() []struct {
	Ctx  context.Context
	Host string
	Port string
} {
	var calls []struct {
		Ctx  context.Context
		Host string
		Port string
	}
	mock.lockSlaveOf.RLock()
	calls = mock.calls.SlaveOf
	mock.lockSlaveOf.RUnlock()
	return calls
}

// ResetSlaveOfCalls reset all the calls that were made to SlaveOf.
func (mock *MoqCmdable) ResetSlaveOfCalls() {
	mock.lockSlaveOf.Lock()
	mock.calls.SlaveOf = nil
	mock.lockSlaveOf.Unlock()
}

// SlowLogGet calls SlowLogGetFunc.
func (mock *MoqCmdable) SlowLogGet(ctx context.Context, num int64) *redis.SlowLogCmd {
	if mock.SlowLogGetFunc == nil {
		panic("MoqCmdable.SlowLogGetFunc: method is nil but Cmdable.SlowLogGet was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Num int64
	}{
		Ctx: ctx,
		Num: num,
	}
	mock.lockSlowLogGet.Lock()
	mock.calls.SlowLogGet = append(mock.calls.SlowLogGet, callInfo)
	mock.lockSlowLogGet.Unlock()
	return mock.SlowLogGetFunc(ctx, num)
}

// SlowLogGetCalls gets all the calls that were made to SlowLogGet.
// Check the length with:
//
//	len(mockedCmdable.SlowLogGetCalls())
func (mock *MoqCmdable) SlowLogGetCalls() []struct {
	Ctx context.Context
	Num int64
} {
	var calls []struct {
		Ctx context.Context
		Num int64
	}
	mock.lockSlowLogGet.RLock()
	calls = mock.calls.SlowLogGet
	mock.lockSlowLogGet.RUnlock()
	return calls
}

// ResetSlowLogGetCalls reset all the calls that were made to SlowLogGet.
func (mock *MoqCmdable) ResetSlowLogGetCalls() {
	mock.lockSlowLogGet.Lock()
	mock.calls.SlowLogGet = nil
	mock.lockSlowLogGet.Unlock()
}

// SlowLogLen calls SlowLogLenFunc.
func (mock *MoqCmdable) SlowLogLen(ctx context.Context) *redis.IntCmd {
	if mock.SlowLogLenFunc == nil {
		panic("MoqCmdable.SlowLogLenFunc: method is nil but Cmdable.SlowLogLen was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockSlowLogLen.Lock()
	mock.calls.SlowLogLen = append(mock.calls.SlowLogLen, callInfo)
	mock.lockSlowLogLen.Unlock()
	return mock.SlowLogLenFunc(ctx)
}

// SlowLogLenCalls gets all the calls that were made to SlowLogLen.
// Check the length with:
//
//	len(mockedCmdable.SlowLogLenCalls())
func (mock *MoqCmdable) SlowLogLenCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockSlowLogLen.RLock()
	calls = mock.calls.SlowLogLen
	mock.lockSlowLogLen.RUnlock()
	return calls
}

// ResetSlowLogLenCalls reset all the calls that were made to SlowLogLen.
func (mock *MoqCmdable) ResetSlowLogLenCalls() {
	mock.lockSlowLogLen.Lock()
	mock.calls.SlowLogLen = nil
	mock.lockSlowLogLen.Unlock()
}

// SlowLogReset calls SlowLogResetFunc.
func (mock *MoqCmdable) SlowLogReset(ctx context.Context) *redis.StatusCmd {
	if mock.SlowLogResetFunc == nil {
		panic("MoqCmdable.SlowLogResetFunc: method is nil but Cmdable.SlowLogReset was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockSlowLogReset.Lock()
	mock.calls.SlowLogReset = append(mock.calls.SlowLogReset, callInfo)
	mock.lockSlowLogReset.Unlock()
	return mock.SlowLogResetFunc(ctx)
}

// SlowLogResetCalls gets all the calls that were made to SlowLogReset.
// Check the length with:
//
//	len(mockedCmdable.SlowLogResetCalls())
func (mock *MoqCmdable) SlowLogResetCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockSlowLogReset.RLock()
	calls = mock.calls.SlowLogReset
	mock.lockSlowLogReset.RUnlock()
	return calls
}

// ResetSlowLogResetCalls reset all the calls that were made to SlowLogReset.
func (mock *MoqCmdable) ResetSlowLogResetCalls() {
	mock.lockSlowLogReset.Lock()
	mock.calls.SlowLogReset = nil
	mock.lockSlowLogReset.Unlock()
}

// Sort calls SortFunc.
func (mock *MoqCmdable) Sort(ctx context.Context, key string, sort *redis.Sort) *redis.StringSliceCmd {
	if mock.SortFunc == nil {
		panic("MoqCmdable.SortFunc: method is nil but Cmdable.Sort was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Key  string
		Sort *redis.Sort
	}{
		Ctx:  ctx,
		Key:  key,
		Sort: sort,
	}
	mock.lockSort.Lock()
	mock.calls.Sort = append(mock.calls.Sort, callInfo)
	mock.lockSort.Unlock()
	return mock.SortFunc(ctx, key, sort)
}

// SortCalls gets all the calls that were made to Sort.
// Check the length with:
//
//	len(mockedCmdable.SortCalls())
func (mock *MoqCmdable) SortCalls() []struct {
	Ctx  context.Context
	Key  string
	Sort *redis.Sort
} {
	var calls []struct {
		Ctx  context.Context
		Key  string
		Sort *redis.Sort
	}
	mock.lockSort.RLock()
	calls = mock.calls.Sort
	mock.lockSort.RUnlock()
	return calls
}

// ResetSortCalls reset all the calls that were made to Sort.
func (mock *MoqCmdable) ResetSortCalls() {
	mock.lockSort.Lock()
	mock.calls.Sort = nil
	mock.lockSort.Unlock()
}

// SortInterfaces calls SortInterfacesFunc.
func (mock *MoqCmdable) SortInterfaces(ctx context.Context, key string, sort *redis.Sort) *redis.SliceCmd {
	if mock.SortInterfacesFunc == nil {
		panic("MoqCmdable.SortInterfacesFunc: method is nil but Cmdable.SortInterfaces was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Key  string
		Sort *redis.Sort
	}{
		Ctx:  ctx,
		Key:  key,
		Sort: sort,
	}
	mock.lockSortInterfaces.Lock()
	mock.calls.SortInterfaces = append(mock.calls.SortInterfaces, callInfo)
	mock.lockSortInterfaces.Unlock()
	return mock.SortInterfacesFunc(ctx, key, sort)
}

// SortInterfacesCalls gets all the calls that were made to SortInterfaces.
// Check the length with:
//
//	len(mockedCmdable.SortInterfacesCalls())
func (mock *MoqCmdable) SortInterfacesCalls() []struct {
	Ctx  context.Context
	Key  string
	Sort *redis.Sort
} {
	var calls []struct {
		Ctx  context.Context
		Key  string
		Sort *redis.Sort
	}
	mock.lockSortInterfaces.RLock()
	calls = mock.calls.SortInterfaces
	mock.lockSortInterfaces.RUnlock()
	return calls
}

// ResetSortInterfacesCalls reset all the calls that were made to SortInterfaces.
func (mock *MoqCmdable) ResetSortInterfacesCalls() {
	mock.lockSortInterfaces.Lock()
	mock.calls.SortInterfaces = nil
	mock.lockSortInterfaces.Unlock()
}

// SortRO calls SortROFunc.
func (mock *MoqCmdable) SortRO(ctx context.Context, key string, sort *redis.Sort) *redis.StringSliceCmd {
	if mock.SortROFunc == nil {
		panic("MoqCmdable.SortROFunc: method is nil but Cmdable.SortRO was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Key  string
		Sort *redis.Sort
	}{
		Ctx:  ctx,
		Key:  key,
		Sort: sort,
	}
	mock.lockSortRO.Lock()
	mock.calls.SortRO = append(mock.calls.SortRO, callInfo)
	mock.lockSortRO.Unlock()
	return mock.SortROFunc(ctx, key, sort)
}

// SortROCalls gets all the calls that were made to SortRO.
// Check the length with:
//
//	len(mockedCmdable.SortROCalls())
func (mock *MoqCmdable) SortROCalls() []struct {
	Ctx  context.Context
	Key  string
	Sort *redis.Sort
} {
	var calls []struct {
		Ctx  context.Context
		Key  string
		Sort *redis.Sort
	}
	mock.lockSortRO.RLock()
	calls = mock.calls.SortRO
	mock.lockSortRO.RUnlock()
	return calls
}

// ResetSortROCalls reset all the calls that were made to SortRO.
func (mock *MoqCmdable) ResetSortROCalls() {
	mock.lockSortRO.Lock()
	mock.calls.SortRO = nil
	mock.lockSortRO.Unlock()
}

// SortStore calls SortStoreFunc.
func (mock *MoqCmdable) SortStore(ctx context.Context, key string, store string, sort *redis.Sort) *redis.IntCmd {
	if mock.SortStoreFunc == nil {
		panic("MoqCmdable.SortStoreFunc: method is nil but Cmdable.SortStore was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Store string
		Sort  *redis.Sort
	}{
		Ctx:   ctx,
		Key:   key,
		Store: store,
		Sort:  sort,
	}
	mock.lockSortStore.Lock()
	mock.calls.SortStore = append(mock.calls.SortStore, callInfo)
	mock.lockSortStore.Unlock()
	return mock.SortStoreFunc(ctx, key, store, sort)
}

// SortStoreCalls gets all the calls that were made to SortStore.
// Check the length with:
//
//	len(mockedCmdable.SortStoreCalls())
func (mock *MoqCmdable) SortStoreCalls() []struct {
	Ctx   context.Context
	Key   string
	Store string
	Sort  *redis.Sort
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Store string
		Sort  *redis.Sort
	}
	mock.lockSortStore.RLock()
	calls = mock.calls.SortStore
	mock.lockSortStore.RUnlock()
	return calls
}

// ResetSortStoreCalls reset all the calls that were made to SortStore.
func (mock *MoqCmdable) ResetSortStoreCalls() {
	mock.lockSortStore.Lock()
	mock.calls.SortStore = nil
	mock.lockSortStore.Unlock()
}

// StrLen calls StrLenFunc.
func (mock *MoqCmdable) StrLen(ctx context.Context, key string) *redis.IntCmd {
	if mock.StrLenFunc == nil {
		panic("MoqCmdable.StrLenFunc: method is nil but Cmdable.StrLen was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockStrLen.Lock()
	mock.calls.StrLen = append(mock.calls.StrLen, callInfo)
	mock.lockStrLen.Unlock()
	return mock.StrLenFunc(ctx, key)
}

// StrLenCalls gets all the calls that were made to StrLen.
// Check the length with:
//
//	len(mockedCmdable.StrLenCalls())
func (mock *MoqCmdable) StrLenCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockStrLen.RLock()
	calls = mock.calls.StrLen
	mock.lockStrLen.RUnlock()
	return calls
}

// ResetStrLenCalls reset all the calls that were made to StrLen.
func (mock *MoqCmdable) ResetStrLenCalls() {
	mock.lockStrLen.Lock()
	mock.calls.StrLen = nil
	mock.lockStrLen.Unlock()
}

// Subscribe calls SubscribeFunc.
func (mock *MoqCmdable) Subscribe(ctx context.Context, channels ...string) *redis.PubSub {
	if mock.SubscribeFunc == nil {
		panic("MoqCmdable.SubscribeFunc: method is nil but Cmdable.Subscribe was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Channels []string
	}{
		Ctx:      ctx,
		Channels: channels,
	}
	mock.lockSubscribe.Lock()
	mock.calls.Subscribe = append(mock.calls.Subscribe, callInfo)
	mock.lockSubscribe.Unlock()
	return mock.SubscribeFunc(ctx, channels...)
}

// SubscribeCalls gets all the calls that were made to Subscribe.
// Check the length with:
//
//	len(mockedCmdable.SubscribeCalls())
func (mock *MoqCmdable) SubscribeCalls() []struct {
	Ctx      context.Context
	Channels []string
} {
	var calls []struct {
		Ctx      context.Context
		Channels []string
	}
	mock.lockSubscribe.RLock()
	calls = mock.calls.Subscribe
	mock.lockSubscribe.RUnlock()
	return calls
}

// ResetSubscribeCalls reset all the calls that were made to Subscribe.
func (mock *MoqCmdable) ResetSubscribeCalls() {
	mock.lockSubscribe.Lock()
	mock.calls.Subscribe = nil
	mock.lockSubscribe.Unlock()
}

// TDigestAdd calls TDigestAddFunc.
func (mock *MoqCmdable) TDigestAdd(ctx context.Context, key string, elements ...float64) *redis.StatusCmd {
	if mock.TDigestAddFunc == nil {
		panic("MoqCmdable.TDigestAddFunc: method is nil but Cmdable.TDigestAdd was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Key      string
		Elements []float64
	}{
		Ctx:      ctx,
		Key:      key,
		Elements: elements,
	}
	mock.lockTDigestAdd.Lock()
	mock.calls.TDigestAdd = append(mock.calls.TDigestAdd, callInfo)
	mock.lockTDigestAdd.Unlock()
	return mock.TDigestAddFunc(ctx, key, elements...)
}

// TDigestAddCalls gets all the calls that were made to TDigestAdd.
// Check the length with:
//
//	len(mockedCmdable.TDigestAddCalls())
func (mock *MoqCmdable) TDigestAddCalls() []struct {
	Ctx      context.Context
	Key      string
	Elements []float64
} {
	var calls []struct {
		Ctx      context.Context
		Key      string
		Elements []float64
	}
	mock.lockTDigestAdd.RLock()
	calls = mock.calls.TDigestAdd
	mock.lockTDigestAdd.RUnlock()
	return calls
}

// ResetTDigestAddCalls reset all the calls that were made to TDigestAdd.
func (mock *MoqCmdable) ResetTDigestAddCalls() {
	mock.lockTDigestAdd.Lock()
	mock.calls.TDigestAdd = nil
	mock.lockTDigestAdd.Unlock()
}

// TDigestByRank calls TDigestByRankFunc.
func (mock *MoqCmdable) TDigestByRank(ctx context.Context, key string, rank ...uint64) *redis.FloatSliceCmd {
	if mock.TDigestByRankFunc == nil {
		panic("MoqCmdable.TDigestByRankFunc: method is nil but Cmdable.TDigestByRank was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Key  string
		Rank []uint64
	}{
		Ctx:  ctx,
		Key:  key,
		Rank: rank,
	}
	mock.lockTDigestByRank.Lock()
	mock.calls.TDigestByRank = append(mock.calls.TDigestByRank, callInfo)
	mock.lockTDigestByRank.Unlock()
	return mock.TDigestByRankFunc(ctx, key, rank...)
}

// TDigestByRankCalls gets all the calls that were made to TDigestByRank.
// Check the length with:
//
//	len(mockedCmdable.TDigestByRankCalls())
func (mock *MoqCmdable) TDigestByRankCalls() []struct {
	Ctx  context.Context
	Key  string
	Rank []uint64
} {
	var calls []struct {
		Ctx  context.Context
		Key  string
		Rank []uint64
	}
	mock.lockTDigestByRank.RLock()
	calls = mock.calls.TDigestByRank
	mock.lockTDigestByRank.RUnlock()
	return calls
}

// ResetTDigestByRankCalls reset all the calls that were made to TDigestByRank.
func (mock *MoqCmdable) ResetTDigestByRankCalls() {
	mock.lockTDigestByRank.Lock()
	mock.calls.TDigestByRank = nil
	mock.lockTDigestByRank.Unlock()
}

// TDigestByRevRank calls TDigestByRevRankFunc.
func (mock *MoqCmdable) TDigestByRevRank(ctx context.Context, key string, rank ...uint64) *redis.FloatSliceCmd {
	if mock.TDigestByRevRankFunc == nil {
		panic("MoqCmdable.TDigestByRevRankFunc: method is nil but Cmdable.TDigestByRevRank was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Key  string
		Rank []uint64
	}{
		Ctx:  ctx,
		Key:  key,
		Rank: rank,
	}
	mock.lockTDigestByRevRank.Lock()
	mock.calls.TDigestByRevRank = append(mock.calls.TDigestByRevRank, callInfo)
	mock.lockTDigestByRevRank.Unlock()
	return mock.TDigestByRevRankFunc(ctx, key, rank...)
}

// TDigestByRevRankCalls gets all the calls that were made to TDigestByRevRank.
// Check the length with:
//
//	len(mockedCmdable.TDigestByRevRankCalls())
func (mock *MoqCmdable) TDigestByRevRankCalls() []struct {
	Ctx  context.Context
	Key  string
	Rank []uint64
} {
	var calls []struct {
		Ctx  context.Context
		Key  string
		Rank []uint64
	}
	mock.lockTDigestByRevRank.RLock()
	calls = mock.calls.TDigestByRevRank
	mock.lockTDigestByRevRank.RUnlock()
	return calls
}

// ResetTDigestByRevRankCalls reset all the calls that were made to TDigestByRevRank.
func (mock *MoqCmdable) ResetTDigestByRevRankCalls() {
	mock.lockTDigestByRevRank.Lock()
	mock.calls.TDigestByRevRank = nil
	mock.lockTDigestByRevRank.Unlock()
}

// TDigestCDF calls TDigestCDFFunc.
func (mock *MoqCmdable) TDigestCDF(ctx context.Context, key string, elements ...float64) *redis.FloatSliceCmd {
	if mock.TDigestCDFFunc == nil {
		panic("MoqCmdable.TDigestCDFFunc: method is nil but Cmdable.TDigestCDF was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Key      string
		Elements []float64
	}{
		Ctx:      ctx,
		Key:      key,
		Elements: elements,
	}
	mock.lockTDigestCDF.Lock()
	mock.calls.TDigestCDF = append(mock.calls.TDigestCDF, callInfo)
	mock.lockTDigestCDF.Unlock()
	return mock.TDigestCDFFunc(ctx, key, elements...)
}

// TDigestCDFCalls gets all the calls that were made to TDigestCDF.
// Check the length with:
//
//	len(mockedCmdable.TDigestCDFCalls())
func (mock *MoqCmdable) TDigestCDFCalls() []struct {
	Ctx      context.Context
	Key      string
	Elements []float64
} {
	var calls []struct {
		Ctx      context.Context
		Key      string
		Elements []float64
	}
	mock.lockTDigestCDF.RLock()
	calls = mock.calls.TDigestCDF
	mock.lockTDigestCDF.RUnlock()
	return calls
}

// ResetTDigestCDFCalls reset all the calls that were made to TDigestCDF.
func (mock *MoqCmdable) ResetTDigestCDFCalls() {
	mock.lockTDigestCDF.Lock()
	mock.calls.TDigestCDF = nil
	mock.lockTDigestCDF.Unlock()
}

// TDigestCreate calls TDigestCreateFunc.
func (mock *MoqCmdable) TDigestCreate(ctx context.Context, key string) *redis.StatusCmd {
	if mock.TDigestCreateFunc == nil {
		panic("MoqCmdable.TDigestCreateFunc: method is nil but Cmdable.TDigestCreate was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockTDigestCreate.Lock()
	mock.calls.TDigestCreate = append(mock.calls.TDigestCreate, callInfo)
	mock.lockTDigestCreate.Unlock()
	return mock.TDigestCreateFunc(ctx, key)
}

// TDigestCreateCalls gets all the calls that were made to TDigestCreate.
// Check the length with:
//
//	len(mockedCmdable.TDigestCreateCalls())
func (mock *MoqCmdable) TDigestCreateCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockTDigestCreate.RLock()
	calls = mock.calls.TDigestCreate
	mock.lockTDigestCreate.RUnlock()
	return calls
}

// ResetTDigestCreateCalls reset all the calls that were made to TDigestCreate.
func (mock *MoqCmdable) ResetTDigestCreateCalls() {
	mock.lockTDigestCreate.Lock()
	mock.calls.TDigestCreate = nil
	mock.lockTDigestCreate.Unlock()
}

// TDigestCreateWithCompression calls TDigestCreateWithCompressionFunc.
func (mock *MoqCmdable) TDigestCreateWithCompression(ctx context.Context, key string, compression int64) *redis.StatusCmd {
	if mock.TDigestCreateWithCompressionFunc == nil {
		panic("MoqCmdable.TDigestCreateWithCompressionFunc: method is nil but Cmdable.TDigestCreateWithCompression was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		Key         string
		Compression int64
	}{
		Ctx:         ctx,
		Key:         key,
		Compression: compression,
	}
	mock.lockTDigestCreateWithCompression.Lock()
	mock.calls.TDigestCreateWithCompression = append(mock.calls.TDigestCreateWithCompression, callInfo)
	mock.lockTDigestCreateWithCompression.Unlock()
	return mock.TDigestCreateWithCompressionFunc(ctx, key, compression)
}

// TDigestCreateWithCompressionCalls gets all the calls that were made to TDigestCreateWithCompression.
// Check the length with:
//
//	len(mockedCmdable.TDigestCreateWithCompressionCalls())
func (mock *MoqCmdable) TDigestCreateWithCompressionCalls() []struct {
	Ctx         context.Context
	Key         string
	Compression int64
} {
	var calls []struct {
		Ctx         context.Context
		Key         string
		Compression int64
	}
	mock.lockTDigestCreateWithCompression.RLock()
	calls = mock.calls.TDigestCreateWithCompression
	mock.lockTDigestCreateWithCompression.RUnlock()
	return calls
}

// ResetTDigestCreateWithCompressionCalls reset all the calls that were made to TDigestCreateWithCompression.
func (mock *MoqCmdable) ResetTDigestCreateWithCompressionCalls() {
	mock.lockTDigestCreateWithCompression.Lock()
	mock.calls.TDigestCreateWithCompression = nil
	mock.lockTDigestCreateWithCompression.Unlock()
}

// TDigestInfo calls TDigestInfoFunc.
func (mock *MoqCmdable) TDigestInfo(ctx context.Context, key string) *redis.TDigestInfoCmd {
	if mock.TDigestInfoFunc == nil {
		panic("MoqCmdable.TDigestInfoFunc: method is nil but Cmdable.TDigestInfo was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockTDigestInfo.Lock()
	mock.calls.TDigestInfo = append(mock.calls.TDigestInfo, callInfo)
	mock.lockTDigestInfo.Unlock()
	return mock.TDigestInfoFunc(ctx, key)
}

// TDigestInfoCalls gets all the calls that were made to TDigestInfo.
// Check the length with:
//
//	len(mockedCmdable.TDigestInfoCalls())
func (mock *MoqCmdable) TDigestInfoCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockTDigestInfo.RLock()
	calls = mock.calls.TDigestInfo
	mock.lockTDigestInfo.RUnlock()
	return calls
}

// ResetTDigestInfoCalls reset all the calls that were made to TDigestInfo.
func (mock *MoqCmdable) ResetTDigestInfoCalls() {
	mock.lockTDigestInfo.Lock()
	mock.calls.TDigestInfo = nil
	mock.lockTDigestInfo.Unlock()
}

// TDigestMax calls TDigestMaxFunc.
func (mock *MoqCmdable) TDigestMax(ctx context.Context, key string) *redis.FloatCmd {
	if mock.TDigestMaxFunc == nil {
		panic("MoqCmdable.TDigestMaxFunc: method is nil but Cmdable.TDigestMax was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockTDigestMax.Lock()
	mock.calls.TDigestMax = append(mock.calls.TDigestMax, callInfo)
	mock.lockTDigestMax.Unlock()
	return mock.TDigestMaxFunc(ctx, key)
}

// TDigestMaxCalls gets all the calls that were made to TDigestMax.
// Check the length with:
//
//	len(mockedCmdable.TDigestMaxCalls())
func (mock *MoqCmdable) TDigestMaxCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockTDigestMax.RLock()
	calls = mock.calls.TDigestMax
	mock.lockTDigestMax.RUnlock()
	return calls
}

// ResetTDigestMaxCalls reset all the calls that were made to TDigestMax.
func (mock *MoqCmdable) ResetTDigestMaxCalls() {
	mock.lockTDigestMax.Lock()
	mock.calls.TDigestMax = nil
	mock.lockTDigestMax.Unlock()
}

// TDigestMerge calls TDigestMergeFunc.
func (mock *MoqCmdable) TDigestMerge(ctx context.Context, destKey string, options *redis.TDigestMergeOptions, sourceKeys ...string) *redis.StatusCmd {
	if mock.TDigestMergeFunc == nil {
		panic("MoqCmdable.TDigestMergeFunc: method is nil but Cmdable.TDigestMerge was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		DestKey    string
		Options    *redis.TDigestMergeOptions
		SourceKeys []string
	}{
		Ctx:        ctx,
		DestKey:    destKey,
		Options:    options,
		SourceKeys: sourceKeys,
	}
	mock.lockTDigestMerge.Lock()
	mock.calls.TDigestMerge = append(mock.calls.TDigestMerge, callInfo)
	mock.lockTDigestMerge.Unlock()
	return mock.TDigestMergeFunc(ctx, destKey, options, sourceKeys...)
}

// TDigestMergeCalls gets all the calls that were made to TDigestMerge.
// Check the length with:
//
//	len(mockedCmdable.TDigestMergeCalls())
func (mock *MoqCmdable) TDigestMergeCalls() []struct {
	Ctx        context.Context
	DestKey    string
	Options    *redis.TDigestMergeOptions
	SourceKeys []string
} {
	var calls []struct {
		Ctx        context.Context
		DestKey    string
		Options    *redis.TDigestMergeOptions
		SourceKeys []string
	}
	mock.lockTDigestMerge.RLock()
	calls = mock.calls.TDigestMerge
	mock.lockTDigestMerge.RUnlock()
	return calls
}

// ResetTDigestMergeCalls reset all the calls that were made to TDigestMerge.
func (mock *MoqCmdable) ResetTDigestMergeCalls() {
	mock.lockTDigestMerge.Lock()
	mock.calls.TDigestMerge = nil
	mock.lockTDigestMerge.Unlock()
}

// TDigestMin calls TDigestMinFunc.
func (mock *MoqCmdable) TDigestMin(ctx context.Context, key string) *redis.FloatCmd {
	if mock.TDigestMinFunc == nil {
		panic("MoqCmdable.TDigestMinFunc: method is nil but Cmdable.TDigestMin was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockTDigestMin.Lock()
	mock.calls.TDigestMin = append(mock.calls.TDigestMin, callInfo)
	mock.lockTDigestMin.Unlock()
	return mock.TDigestMinFunc(ctx, key)
}

// TDigestMinCalls gets all the calls that were made to TDigestMin.
// Check the length with:
//
//	len(mockedCmdable.TDigestMinCalls())
func (mock *MoqCmdable) TDigestMinCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockTDigestMin.RLock()
	calls = mock.calls.TDigestMin
	mock.lockTDigestMin.RUnlock()
	return calls
}

// ResetTDigestMinCalls reset all the calls that were made to TDigestMin.
func (mock *MoqCmdable) ResetTDigestMinCalls() {
	mock.lockTDigestMin.Lock()
	mock.calls.TDigestMin = nil
	mock.lockTDigestMin.Unlock()
}

// TDigestQuantile calls TDigestQuantileFunc.
func (mock *MoqCmdable) TDigestQuantile(ctx context.Context, key string, elements ...float64) *redis.FloatSliceCmd {
	if mock.TDigestQuantileFunc == nil {
		panic("MoqCmdable.TDigestQuantileFunc: method is nil but Cmdable.TDigestQuantile was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Key      string
		Elements []float64
	}{
		Ctx:      ctx,
		Key:      key,
		Elements: elements,
	}
	mock.lockTDigestQuantile.Lock()
	mock.calls.TDigestQuantile = append(mock.calls.TDigestQuantile, callInfo)
	mock.lockTDigestQuantile.Unlock()
	return mock.TDigestQuantileFunc(ctx, key, elements...)
}

// TDigestQuantileCalls gets all the calls that were made to TDigestQuantile.
// Check the length with:
//
//	len(mockedCmdable.TDigestQuantileCalls())
func (mock *MoqCmdable) TDigestQuantileCalls() []struct {
	Ctx      context.Context
	Key      string
	Elements []float64
} {
	var calls []struct {
		Ctx      context.Context
		Key      string
		Elements []float64
	}
	mock.lockTDigestQuantile.RLock()
	calls = mock.calls.TDigestQuantile
	mock.lockTDigestQuantile.RUnlock()
	return calls
}

// ResetTDigestQuantileCalls reset all the calls that were made to TDigestQuantile.
func (mock *MoqCmdable) ResetTDigestQuantileCalls() {
	mock.lockTDigestQuantile.Lock()
	mock.calls.TDigestQuantile = nil
	mock.lockTDigestQuantile.Unlock()
}

// TDigestRank calls TDigestRankFunc.
func (mock *MoqCmdable) TDigestRank(ctx context.Context, key string, values ...float64) *redis.IntSliceCmd {
	if mock.TDigestRankFunc == nil {
		panic("MoqCmdable.TDigestRankFunc: method is nil but Cmdable.TDigestRank was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		Values []float64
	}{
		Ctx:    ctx,
		Key:    key,
		Values: values,
	}
	mock.lockTDigestRank.Lock()
	mock.calls.TDigestRank = append(mock.calls.TDigestRank, callInfo)
	mock.lockTDigestRank.Unlock()
	return mock.TDigestRankFunc(ctx, key, values...)
}

// TDigestRankCalls gets all the calls that were made to TDigestRank.
// Check the length with:
//
//	len(mockedCmdable.TDigestRankCalls())
func (mock *MoqCmdable) TDigestRankCalls() []struct {
	Ctx    context.Context
	Key    string
	Values []float64
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		Values []float64
	}
	mock.lockTDigestRank.RLock()
	calls = mock.calls.TDigestRank
	mock.lockTDigestRank.RUnlock()
	return calls
}

// ResetTDigestRankCalls reset all the calls that were made to TDigestRank.
func (mock *MoqCmdable) ResetTDigestRankCalls() {
	mock.lockTDigestRank.Lock()
	mock.calls.TDigestRank = nil
	mock.lockTDigestRank.Unlock()
}

// TDigestReset calls TDigestResetFunc.
func (mock *MoqCmdable) TDigestReset(ctx context.Context, key string) *redis.StatusCmd {
	if mock.TDigestResetFunc == nil {
		panic("MoqCmdable.TDigestResetFunc: method is nil but Cmdable.TDigestReset was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockTDigestReset.Lock()
	mock.calls.TDigestReset = append(mock.calls.TDigestReset, callInfo)
	mock.lockTDigestReset.Unlock()
	return mock.TDigestResetFunc(ctx, key)
}

// TDigestResetCalls gets all the calls that were made to TDigestReset.
// Check the length with:
//
//	len(mockedCmdable.TDigestResetCalls())
func (mock *MoqCmdable) TDigestResetCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockTDigestReset.RLock()
	calls = mock.calls.TDigestReset
	mock.lockTDigestReset.RUnlock()
	return calls
}

// ResetTDigestResetCalls reset all the calls that were made to TDigestReset.
func (mock *MoqCmdable) ResetTDigestResetCalls() {
	mock.lockTDigestReset.Lock()
	mock.calls.TDigestReset = nil
	mock.lockTDigestReset.Unlock()
}

// TDigestRevRank calls TDigestRevRankFunc.
func (mock *MoqCmdable) TDigestRevRank(ctx context.Context, key string, values ...float64) *redis.IntSliceCmd {
	if mock.TDigestRevRankFunc == nil {
		panic("MoqCmdable.TDigestRevRankFunc: method is nil but Cmdable.TDigestRevRank was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		Values []float64
	}{
		Ctx:    ctx,
		Key:    key,
		Values: values,
	}
	mock.lockTDigestRevRank.Lock()
	mock.calls.TDigestRevRank = append(mock.calls.TDigestRevRank, callInfo)
	mock.lockTDigestRevRank.Unlock()
	return mock.TDigestRevRankFunc(ctx, key, values...)
}

// TDigestRevRankCalls gets all the calls that were made to TDigestRevRank.
// Check the length with:
//
//	len(mockedCmdable.TDigestRevRankCalls())
func (mock *MoqCmdable) TDigestRevRankCalls() []struct {
	Ctx    context.Context
	Key    string
	Values []float64
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		Values []float64
	}
	mock.lockTDigestRevRank.RLock()
	calls = mock.calls.TDigestRevRank
	mock.lockTDigestRevRank.RUnlock()
	return calls
}

// ResetTDigestRevRankCalls reset all the calls that were made to TDigestRevRank.
func (mock *MoqCmdable) ResetTDigestRevRankCalls() {
	mock.lockTDigestRevRank.Lock()
	mock.calls.TDigestRevRank = nil
	mock.lockTDigestRevRank.Unlock()
}

// TDigestTrimmedMean calls TDigestTrimmedMeanFunc.
func (mock *MoqCmdable) TDigestTrimmedMean(ctx context.Context, key string, lowCutQuantile float64, highCutQuantile float64) *redis.FloatCmd {
	if mock.TDigestTrimmedMeanFunc == nil {
		panic("MoqCmdable.TDigestTrimmedMeanFunc: method is nil but Cmdable.TDigestTrimmedMean was just called")
	}
	callInfo := struct {
		Ctx             context.Context
		Key             string
		LowCutQuantile  float64
		HighCutQuantile float64
	}{
		Ctx:             ctx,
		Key:             key,
		LowCutQuantile:  lowCutQuantile,
		HighCutQuantile: highCutQuantile,
	}
	mock.lockTDigestTrimmedMean.Lock()
	mock.calls.TDigestTrimmedMean = append(mock.calls.TDigestTrimmedMean, callInfo)
	mock.lockTDigestTrimmedMean.Unlock()
	return mock.TDigestTrimmedMeanFunc(ctx, key, lowCutQuantile, highCutQuantile)
}

// TDigestTrimmedMeanCalls gets all the calls that were made to TDigestTrimmedMean.
// Check the length with:
//
//	len(mockedCmdable.TDigestTrimmedMeanCalls())
func (mock *MoqCmdable) TDigestTrimmedMeanCalls() []struct {
	Ctx             context.Context
	Key             string
	LowCutQuantile  float64
	HighCutQuantile float64
} {
	var calls []struct {
		Ctx             context.Context
		Key             string
		LowCutQuantile  float64
		HighCutQuantile float64
	}
	mock.lockTDigestTrimmedMean.RLock()
	calls = mock.calls.TDigestTrimmedMean
	mock.lockTDigestTrimmedMean.RUnlock()
	return calls
}

// ResetTDigestTrimmedMeanCalls reset all the calls that were made to TDigestTrimmedMean.
func (mock *MoqCmdable) ResetTDigestTrimmedMeanCalls() {
	mock.lockTDigestTrimmedMean.Lock()
	mock.calls.TDigestTrimmedMean = nil
	mock.lockTDigestTrimmedMean.Unlock()
}

// TSAdd calls TSAddFunc.
func (mock *MoqCmdable) TSAdd(ctx context.Context, key string, timestamp interface{}, value float64) *redis.IntCmd {
	if mock.TSAddFunc == nil {
		panic("MoqCmdable.TSAddFunc: method is nil but Cmdable.TSAdd was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Key       string
		Timestamp interface{}
		Value     float64
	}{
		Ctx:       ctx,
		Key:       key,
		Timestamp: timestamp,
		Value:     value,
	}
	mock.lockTSAdd.Lock()
	mock.calls.TSAdd = append(mock.calls.TSAdd, callInfo)
	mock.lockTSAdd.Unlock()
	return mock.TSAddFunc(ctx, key, timestamp, value)
}

// TSAddCalls gets all the calls that were made to TSAdd.
// Check the length with:
//
//	len(mockedCmdable.TSAddCalls())
func (mock *MoqCmdable) TSAddCalls() []struct {
	Ctx       context.Context
	Key       string
	Timestamp interface{}
	Value     float64
} {
	var calls []struct {
		Ctx       context.Context
		Key       string
		Timestamp interface{}
		Value     float64
	}
	mock.lockTSAdd.RLock()
	calls = mock.calls.TSAdd
	mock.lockTSAdd.RUnlock()
	return calls
}

// ResetTSAddCalls reset all the calls that were made to TSAdd.
func (mock *MoqCmdable) ResetTSAddCalls() {
	mock.lockTSAdd.Lock()
	mock.calls.TSAdd = nil
	mock.lockTSAdd.Unlock()
}

// TSAddWithArgs calls TSAddWithArgsFunc.
func (mock *MoqCmdable) TSAddWithArgs(ctx context.Context, key string, timestamp interface{}, value float64, options *redis.TSOptions) *redis.IntCmd {
	if mock.TSAddWithArgsFunc == nil {
		panic("MoqCmdable.TSAddWithArgsFunc: method is nil but Cmdable.TSAddWithArgs was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Key       string
		Timestamp interface{}
		Value     float64
		Options   *redis.TSOptions
	}{
		Ctx:       ctx,
		Key:       key,
		Timestamp: timestamp,
		Value:     value,
		Options:   options,
	}
	mock.lockTSAddWithArgs.Lock()
	mock.calls.TSAddWithArgs = append(mock.calls.TSAddWithArgs, callInfo)
	mock.lockTSAddWithArgs.Unlock()
	return mock.TSAddWithArgsFunc(ctx, key, timestamp, value, options)
}

// TSAddWithArgsCalls gets all the calls that were made to TSAddWithArgs.
// Check the length with:
//
//	len(mockedCmdable.TSAddWithArgsCalls())
func (mock *MoqCmdable) TSAddWithArgsCalls() []struct {
	Ctx       context.Context
	Key       string
	Timestamp interface{}
	Value     float64
	Options   *redis.TSOptions
} {
	var calls []struct {
		Ctx       context.Context
		Key       string
		Timestamp interface{}
		Value     float64
		Options   *redis.TSOptions
	}
	mock.lockTSAddWithArgs.RLock()
	calls = mock.calls.TSAddWithArgs
	mock.lockTSAddWithArgs.RUnlock()
	return calls
}

// ResetTSAddWithArgsCalls reset all the calls that were made to TSAddWithArgs.
func (mock *MoqCmdable) ResetTSAddWithArgsCalls() {
	mock.lockTSAddWithArgs.Lock()
	mock.calls.TSAddWithArgs = nil
	mock.lockTSAddWithArgs.Unlock()
}

// TSAlter calls TSAlterFunc.
func (mock *MoqCmdable) TSAlter(ctx context.Context, key string, options *redis.TSAlterOptions) *redis.StatusCmd {
	if mock.TSAlterFunc == nil {
		panic("MoqCmdable.TSAlterFunc: method is nil but Cmdable.TSAlter was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Key     string
		Options *redis.TSAlterOptions
	}{
		Ctx:     ctx,
		Key:     key,
		Options: options,
	}
	mock.lockTSAlter.Lock()
	mock.calls.TSAlter = append(mock.calls.TSAlter, callInfo)
	mock.lockTSAlter.Unlock()
	return mock.TSAlterFunc(ctx, key, options)
}

// TSAlterCalls gets all the calls that were made to TSAlter.
// Check the length with:
//
//	len(mockedCmdable.TSAlterCalls())
func (mock *MoqCmdable) TSAlterCalls() []struct {
	Ctx     context.Context
	Key     string
	Options *redis.TSAlterOptions
} {
	var calls []struct {
		Ctx     context.Context
		Key     string
		Options *redis.TSAlterOptions
	}
	mock.lockTSAlter.RLock()
	calls = mock.calls.TSAlter
	mock.lockTSAlter.RUnlock()
	return calls
}

// ResetTSAlterCalls reset all the calls that were made to TSAlter.
func (mock *MoqCmdable) ResetTSAlterCalls() {
	mock.lockTSAlter.Lock()
	mock.calls.TSAlter = nil
	mock.lockTSAlter.Unlock()
}

// TSCreate calls TSCreateFunc.
func (mock *MoqCmdable) TSCreate(ctx context.Context, key string) *redis.StatusCmd {
	if mock.TSCreateFunc == nil {
		panic("MoqCmdable.TSCreateFunc: method is nil but Cmdable.TSCreate was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockTSCreate.Lock()
	mock.calls.TSCreate = append(mock.calls.TSCreate, callInfo)
	mock.lockTSCreate.Unlock()
	return mock.TSCreateFunc(ctx, key)
}

// TSCreateCalls gets all the calls that were made to TSCreate.
// Check the length with:
//
//	len(mockedCmdable.TSCreateCalls())
func (mock *MoqCmdable) TSCreateCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockTSCreate.RLock()
	calls = mock.calls.TSCreate
	mock.lockTSCreate.RUnlock()
	return calls
}

// ResetTSCreateCalls reset all the calls that were made to TSCreate.
func (mock *MoqCmdable) ResetTSCreateCalls() {
	mock.lockTSCreate.Lock()
	mock.calls.TSCreate = nil
	mock.lockTSCreate.Unlock()
}

// TSCreateRule calls TSCreateRuleFunc.
func (mock *MoqCmdable) TSCreateRule(ctx context.Context, sourceKey string, destKey string, aggregator redis.Aggregator, bucketDuration int) *redis.StatusCmd {
	if mock.TSCreateRuleFunc == nil {
		panic("MoqCmdable.TSCreateRuleFunc: method is nil but Cmdable.TSCreateRule was just called")
	}
	callInfo := struct {
		Ctx            context.Context
		SourceKey      string
		DestKey        string
		Aggregator     redis.Aggregator
		BucketDuration int
	}{
		Ctx:            ctx,
		SourceKey:      sourceKey,
		DestKey:        destKey,
		Aggregator:     aggregator,
		BucketDuration: bucketDuration,
	}
	mock.lockTSCreateRule.Lock()
	mock.calls.TSCreateRule = append(mock.calls.TSCreateRule, callInfo)
	mock.lockTSCreateRule.Unlock()
	return mock.TSCreateRuleFunc(ctx, sourceKey, destKey, aggregator, bucketDuration)
}

// TSCreateRuleCalls gets all the calls that were made to TSCreateRule.
// Check the length with:
//
//	len(mockedCmdable.TSCreateRuleCalls())
func (mock *MoqCmdable) TSCreateRuleCalls() []struct {
	Ctx            context.Context
	SourceKey      string
	DestKey        string
	Aggregator     redis.Aggregator
	BucketDuration int
} {
	var calls []struct {
		Ctx            context.Context
		SourceKey      string
		DestKey        string
		Aggregator     redis.Aggregator
		BucketDuration int
	}
	mock.lockTSCreateRule.RLock()
	calls = mock.calls.TSCreateRule
	mock.lockTSCreateRule.RUnlock()
	return calls
}

// ResetTSCreateRuleCalls reset all the calls that were made to TSCreateRule.
func (mock *MoqCmdable) ResetTSCreateRuleCalls() {
	mock.lockTSCreateRule.Lock()
	mock.calls.TSCreateRule = nil
	mock.lockTSCreateRule.Unlock()
}

// TSCreateRuleWithArgs calls TSCreateRuleWithArgsFunc.
func (mock *MoqCmdable) TSCreateRuleWithArgs(ctx context.Context, sourceKey string, destKey string, aggregator redis.Aggregator, bucketDuration int, options *redis.TSCreateRuleOptions) *redis.StatusCmd {
	if mock.TSCreateRuleWithArgsFunc == nil {
		panic("MoqCmdable.TSCreateRuleWithArgsFunc: method is nil but Cmdable.TSCreateRuleWithArgs was just called")
	}
	callInfo := struct {
		Ctx            context.Context
		SourceKey      string
		DestKey        string
		Aggregator     redis.Aggregator
		BucketDuration int
		Options        *redis.TSCreateRuleOptions
	}{
		Ctx:            ctx,
		SourceKey:      sourceKey,
		DestKey:        destKey,
		Aggregator:     aggregator,
		BucketDuration: bucketDuration,
		Options:        options,
	}
	mock.lockTSCreateRuleWithArgs.Lock()
	mock.calls.TSCreateRuleWithArgs = append(mock.calls.TSCreateRuleWithArgs, callInfo)
	mock.lockTSCreateRuleWithArgs.Unlock()
	return mock.TSCreateRuleWithArgsFunc(ctx, sourceKey, destKey, aggregator, bucketDuration, options)
}

// TSCreateRuleWithArgsCalls gets all the calls that were made to TSCreateRuleWithArgs.
// Check the length with:
//
//	len(mockedCmdable.TSCreateRuleWithArgsCalls())
func (mock *MoqCmdable) TSCreateRuleWithArgsCalls() []struct {
	Ctx            context.Context
	SourceKey      string
	DestKey        string
	Aggregator     redis.Aggregator
	BucketDuration int
	Options        *redis.TSCreateRuleOptions
} {
	var calls []struct {
		Ctx            context.Context
		SourceKey      string
		DestKey        string
		Aggregator     redis.Aggregator
		BucketDuration int
		Options        *redis.TSCreateRuleOptions
	}
	mock.lockTSCreateRuleWithArgs.RLock()
	calls = mock.calls.TSCreateRuleWithArgs
	mock.lockTSCreateRuleWithArgs.RUnlock()
	return calls
}

// ResetTSCreateRuleWithArgsCalls reset all the calls that were made to TSCreateRuleWithArgs.
func (mock *MoqCmdable) ResetTSCreateRuleWithArgsCalls() {
	mock.lockTSCreateRuleWithArgs.Lock()
	mock.calls.TSCreateRuleWithArgs = nil
	mock.lockTSCreateRuleWithArgs.Unlock()
}

// TSCreateWithArgs calls TSCreateWithArgsFunc.
func (mock *MoqCmdable) TSCreateWithArgs(ctx context.Context, key string, options *redis.TSOptions) *redis.StatusCmd {
	if mock.TSCreateWithArgsFunc == nil {
		panic("MoqCmdable.TSCreateWithArgsFunc: method is nil but Cmdable.TSCreateWithArgs was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Key     string
		Options *redis.TSOptions
	}{
		Ctx:     ctx,
		Key:     key,
		Options: options,
	}
	mock.lockTSCreateWithArgs.Lock()
	mock.calls.TSCreateWithArgs = append(mock.calls.TSCreateWithArgs, callInfo)
	mock.lockTSCreateWithArgs.Unlock()
	return mock.TSCreateWithArgsFunc(ctx, key, options)
}

// TSCreateWithArgsCalls gets all the calls that were made to TSCreateWithArgs.
// Check the length with:
//
//	len(mockedCmdable.TSCreateWithArgsCalls())
func (mock *MoqCmdable) TSCreateWithArgsCalls() []struct {
	Ctx     context.Context
	Key     string
	Options *redis.TSOptions
} {
	var calls []struct {
		Ctx     context.Context
		Key     string
		Options *redis.TSOptions
	}
	mock.lockTSCreateWithArgs.RLock()
	calls = mock.calls.TSCreateWithArgs
	mock.lockTSCreateWithArgs.RUnlock()
	return calls
}

// ResetTSCreateWithArgsCalls reset all the calls that were made to TSCreateWithArgs.
func (mock *MoqCmdable) ResetTSCreateWithArgsCalls() {
	mock.lockTSCreateWithArgs.Lock()
	mock.calls.TSCreateWithArgs = nil
	mock.lockTSCreateWithArgs.Unlock()
}

// TSDecrBy calls TSDecrByFunc.
func (mock *MoqCmdable) TSDecrBy(ctx context.Context, Key string, timestamp float64) *redis.IntCmd {
	if mock.TSDecrByFunc == nil {
		panic("MoqCmdable.TSDecrByFunc: method is nil but Cmdable.TSDecrBy was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Key       string
		Timestamp float64
	}{
		Ctx:       ctx,
		Key:       Key,
		Timestamp: timestamp,
	}
	mock.lockTSDecrBy.Lock()
	mock.calls.TSDecrBy = append(mock.calls.TSDecrBy, callInfo)
	mock.lockTSDecrBy.Unlock()
	return mock.TSDecrByFunc(ctx, Key, timestamp)
}

// TSDecrByCalls gets all the calls that were made to TSDecrBy.
// Check the length with:
//
//	len(mockedCmdable.TSDecrByCalls())
func (mock *MoqCmdable) TSDecrByCalls() []struct {
	Ctx       context.Context
	Key       string
	Timestamp float64
} {
	var calls []struct {
		Ctx       context.Context
		Key       string
		Timestamp float64
	}
	mock.lockTSDecrBy.RLock()
	calls = mock.calls.TSDecrBy
	mock.lockTSDecrBy.RUnlock()
	return calls
}

// ResetTSDecrByCalls reset all the calls that were made to TSDecrBy.
func (mock *MoqCmdable) ResetTSDecrByCalls() {
	mock.lockTSDecrBy.Lock()
	mock.calls.TSDecrBy = nil
	mock.lockTSDecrBy.Unlock()
}

// TSDecrByWithArgs calls TSDecrByWithArgsFunc.
func (mock *MoqCmdable) TSDecrByWithArgs(ctx context.Context, key string, timestamp float64, options *redis.TSIncrDecrOptions) *redis.IntCmd {
	if mock.TSDecrByWithArgsFunc == nil {
		panic("MoqCmdable.TSDecrByWithArgsFunc: method is nil but Cmdable.TSDecrByWithArgs was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Key       string
		Timestamp float64
		Options   *redis.TSIncrDecrOptions
	}{
		Ctx:       ctx,
		Key:       key,
		Timestamp: timestamp,
		Options:   options,
	}
	mock.lockTSDecrByWithArgs.Lock()
	mock.calls.TSDecrByWithArgs = append(mock.calls.TSDecrByWithArgs, callInfo)
	mock.lockTSDecrByWithArgs.Unlock()
	return mock.TSDecrByWithArgsFunc(ctx, key, timestamp, options)
}

// TSDecrByWithArgsCalls gets all the calls that were made to TSDecrByWithArgs.
// Check the length with:
//
//	len(mockedCmdable.TSDecrByWithArgsCalls())
func (mock *MoqCmdable) TSDecrByWithArgsCalls() []struct {
	Ctx       context.Context
	Key       string
	Timestamp float64
	Options   *redis.TSIncrDecrOptions
} {
	var calls []struct {
		Ctx       context.Context
		Key       string
		Timestamp float64
		Options   *redis.TSIncrDecrOptions
	}
	mock.lockTSDecrByWithArgs.RLock()
	calls = mock.calls.TSDecrByWithArgs
	mock.lockTSDecrByWithArgs.RUnlock()
	return calls
}

// ResetTSDecrByWithArgsCalls reset all the calls that were made to TSDecrByWithArgs.
func (mock *MoqCmdable) ResetTSDecrByWithArgsCalls() {
	mock.lockTSDecrByWithArgs.Lock()
	mock.calls.TSDecrByWithArgs = nil
	mock.lockTSDecrByWithArgs.Unlock()
}

// TSDel calls TSDelFunc.
func (mock *MoqCmdable) TSDel(ctx context.Context, Key string, fromTimestamp int, toTimestamp int) *redis.IntCmd {
	if mock.TSDelFunc == nil {
		panic("MoqCmdable.TSDelFunc: method is nil but Cmdable.TSDel was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		Key           string
		FromTimestamp int
		ToTimestamp   int
	}{
		Ctx:           ctx,
		Key:           Key,
		FromTimestamp: fromTimestamp,
		ToTimestamp:   toTimestamp,
	}
	mock.lockTSDel.Lock()
	mock.calls.TSDel = append(mock.calls.TSDel, callInfo)
	mock.lockTSDel.Unlock()
	return mock.TSDelFunc(ctx, Key, fromTimestamp, toTimestamp)
}

// TSDelCalls gets all the calls that were made to TSDel.
// Check the length with:
//
//	len(mockedCmdable.TSDelCalls())
func (mock *MoqCmdable) TSDelCalls() []struct {
	Ctx           context.Context
	Key           string
	FromTimestamp int
	ToTimestamp   int
} {
	var calls []struct {
		Ctx           context.Context
		Key           string
		FromTimestamp int
		ToTimestamp   int
	}
	mock.lockTSDel.RLock()
	calls = mock.calls.TSDel
	mock.lockTSDel.RUnlock()
	return calls
}

// ResetTSDelCalls reset all the calls that were made to TSDel.
func (mock *MoqCmdable) ResetTSDelCalls() {
	mock.lockTSDel.Lock()
	mock.calls.TSDel = nil
	mock.lockTSDel.Unlock()
}

// TSDeleteRule calls TSDeleteRuleFunc.
func (mock *MoqCmdable) TSDeleteRule(ctx context.Context, sourceKey string, destKey string) *redis.StatusCmd {
	if mock.TSDeleteRuleFunc == nil {
		panic("MoqCmdable.TSDeleteRuleFunc: method is nil but Cmdable.TSDeleteRule was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		SourceKey string
		DestKey   string
	}{
		Ctx:       ctx,
		SourceKey: sourceKey,
		DestKey:   destKey,
	}
	mock.lockTSDeleteRule.Lock()
	mock.calls.TSDeleteRule = append(mock.calls.TSDeleteRule, callInfo)
	mock.lockTSDeleteRule.Unlock()
	return mock.TSDeleteRuleFunc(ctx, sourceKey, destKey)
}

// TSDeleteRuleCalls gets all the calls that were made to TSDeleteRule.
// Check the length with:
//
//	len(mockedCmdable.TSDeleteRuleCalls())
func (mock *MoqCmdable) TSDeleteRuleCalls() []struct {
	Ctx       context.Context
	SourceKey string
	DestKey   string
} {
	var calls []struct {
		Ctx       context.Context
		SourceKey string
		DestKey   string
	}
	mock.lockTSDeleteRule.RLock()
	calls = mock.calls.TSDeleteRule
	mock.lockTSDeleteRule.RUnlock()
	return calls
}

// ResetTSDeleteRuleCalls reset all the calls that were made to TSDeleteRule.
func (mock *MoqCmdable) ResetTSDeleteRuleCalls() {
	mock.lockTSDeleteRule.Lock()
	mock.calls.TSDeleteRule = nil
	mock.lockTSDeleteRule.Unlock()
}

// TSGet calls TSGetFunc.
func (mock *MoqCmdable) TSGet(ctx context.Context, key string) *redis.TSTimestampValueCmd {
	if mock.TSGetFunc == nil {
		panic("MoqCmdable.TSGetFunc: method is nil but Cmdable.TSGet was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockTSGet.Lock()
	mock.calls.TSGet = append(mock.calls.TSGet, callInfo)
	mock.lockTSGet.Unlock()
	return mock.TSGetFunc(ctx, key)
}

// TSGetCalls gets all the calls that were made to TSGet.
// Check the length with:
//
//	len(mockedCmdable.TSGetCalls())
func (mock *MoqCmdable) TSGetCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockTSGet.RLock()
	calls = mock.calls.TSGet
	mock.lockTSGet.RUnlock()
	return calls
}

// ResetTSGetCalls reset all the calls that were made to TSGet.
func (mock *MoqCmdable) ResetTSGetCalls() {
	mock.lockTSGet.Lock()
	mock.calls.TSGet = nil
	mock.lockTSGet.Unlock()
}

// TSGetWithArgs calls TSGetWithArgsFunc.
func (mock *MoqCmdable) TSGetWithArgs(ctx context.Context, key string, options *redis.TSGetOptions) *redis.TSTimestampValueCmd {
	if mock.TSGetWithArgsFunc == nil {
		panic("MoqCmdable.TSGetWithArgsFunc: method is nil but Cmdable.TSGetWithArgs was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Key     string
		Options *redis.TSGetOptions
	}{
		Ctx:     ctx,
		Key:     key,
		Options: options,
	}
	mock.lockTSGetWithArgs.Lock()
	mock.calls.TSGetWithArgs = append(mock.calls.TSGetWithArgs, callInfo)
	mock.lockTSGetWithArgs.Unlock()
	return mock.TSGetWithArgsFunc(ctx, key, options)
}

// TSGetWithArgsCalls gets all the calls that were made to TSGetWithArgs.
// Check the length with:
//
//	len(mockedCmdable.TSGetWithArgsCalls())
func (mock *MoqCmdable) TSGetWithArgsCalls() []struct {
	Ctx     context.Context
	Key     string
	Options *redis.TSGetOptions
} {
	var calls []struct {
		Ctx     context.Context
		Key     string
		Options *redis.TSGetOptions
	}
	mock.lockTSGetWithArgs.RLock()
	calls = mock.calls.TSGetWithArgs
	mock.lockTSGetWithArgs.RUnlock()
	return calls
}

// ResetTSGetWithArgsCalls reset all the calls that were made to TSGetWithArgs.
func (mock *MoqCmdable) ResetTSGetWithArgsCalls() {
	mock.lockTSGetWithArgs.Lock()
	mock.calls.TSGetWithArgs = nil
	mock.lockTSGetWithArgs.Unlock()
}

// TSIncrBy calls TSIncrByFunc.
func (mock *MoqCmdable) TSIncrBy(ctx context.Context, Key string, timestamp float64) *redis.IntCmd {
	if mock.TSIncrByFunc == nil {
		panic("MoqCmdable.TSIncrByFunc: method is nil but Cmdable.TSIncrBy was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Key       string
		Timestamp float64
	}{
		Ctx:       ctx,
		Key:       Key,
		Timestamp: timestamp,
	}
	mock.lockTSIncrBy.Lock()
	mock.calls.TSIncrBy = append(mock.calls.TSIncrBy, callInfo)
	mock.lockTSIncrBy.Unlock()
	return mock.TSIncrByFunc(ctx, Key, timestamp)
}

// TSIncrByCalls gets all the calls that were made to TSIncrBy.
// Check the length with:
//
//	len(mockedCmdable.TSIncrByCalls())
func (mock *MoqCmdable) TSIncrByCalls() []struct {
	Ctx       context.Context
	Key       string
	Timestamp float64
} {
	var calls []struct {
		Ctx       context.Context
		Key       string
		Timestamp float64
	}
	mock.lockTSIncrBy.RLock()
	calls = mock.calls.TSIncrBy
	mock.lockTSIncrBy.RUnlock()
	return calls
}

// ResetTSIncrByCalls reset all the calls that were made to TSIncrBy.
func (mock *MoqCmdable) ResetTSIncrByCalls() {
	mock.lockTSIncrBy.Lock()
	mock.calls.TSIncrBy = nil
	mock.lockTSIncrBy.Unlock()
}

// TSIncrByWithArgs calls TSIncrByWithArgsFunc.
func (mock *MoqCmdable) TSIncrByWithArgs(ctx context.Context, key string, timestamp float64, options *redis.TSIncrDecrOptions) *redis.IntCmd {
	if mock.TSIncrByWithArgsFunc == nil {
		panic("MoqCmdable.TSIncrByWithArgsFunc: method is nil but Cmdable.TSIncrByWithArgs was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Key       string
		Timestamp float64
		Options   *redis.TSIncrDecrOptions
	}{
		Ctx:       ctx,
		Key:       key,
		Timestamp: timestamp,
		Options:   options,
	}
	mock.lockTSIncrByWithArgs.Lock()
	mock.calls.TSIncrByWithArgs = append(mock.calls.TSIncrByWithArgs, callInfo)
	mock.lockTSIncrByWithArgs.Unlock()
	return mock.TSIncrByWithArgsFunc(ctx, key, timestamp, options)
}

// TSIncrByWithArgsCalls gets all the calls that were made to TSIncrByWithArgs.
// Check the length with:
//
//	len(mockedCmdable.TSIncrByWithArgsCalls())
func (mock *MoqCmdable) TSIncrByWithArgsCalls() []struct {
	Ctx       context.Context
	Key       string
	Timestamp float64
	Options   *redis.TSIncrDecrOptions
} {
	var calls []struct {
		Ctx       context.Context
		Key       string
		Timestamp float64
		Options   *redis.TSIncrDecrOptions
	}
	mock.lockTSIncrByWithArgs.RLock()
	calls = mock.calls.TSIncrByWithArgs
	mock.lockTSIncrByWithArgs.RUnlock()
	return calls
}

// ResetTSIncrByWithArgsCalls reset all the calls that were made to TSIncrByWithArgs.
func (mock *MoqCmdable) ResetTSIncrByWithArgsCalls() {
	mock.lockTSIncrByWithArgs.Lock()
	mock.calls.TSIncrByWithArgs = nil
	mock.lockTSIncrByWithArgs.Unlock()
}

// TSInfo calls TSInfoFunc.
func (mock *MoqCmdable) TSInfo(ctx context.Context, key string) *redis.MapStringInterfaceCmd {
	if mock.TSInfoFunc == nil {
		panic("MoqCmdable.TSInfoFunc: method is nil but Cmdable.TSInfo was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockTSInfo.Lock()
	mock.calls.TSInfo = append(mock.calls.TSInfo, callInfo)
	mock.lockTSInfo.Unlock()
	return mock.TSInfoFunc(ctx, key)
}

// TSInfoCalls gets all the calls that were made to TSInfo.
// Check the length with:
//
//	len(mockedCmdable.TSInfoCalls())
func (mock *MoqCmdable) TSInfoCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockTSInfo.RLock()
	calls = mock.calls.TSInfo
	mock.lockTSInfo.RUnlock()
	return calls
}

// ResetTSInfoCalls reset all the calls that were made to TSInfo.
func (mock *MoqCmdable) ResetTSInfoCalls() {
	mock.lockTSInfo.Lock()
	mock.calls.TSInfo = nil
	mock.lockTSInfo.Unlock()
}

// TSInfoWithArgs calls TSInfoWithArgsFunc.
func (mock *MoqCmdable) TSInfoWithArgs(ctx context.Context, key string, options *redis.TSInfoOptions) *redis.MapStringInterfaceCmd {
	if mock.TSInfoWithArgsFunc == nil {
		panic("MoqCmdable.TSInfoWithArgsFunc: method is nil but Cmdable.TSInfoWithArgs was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Key     string
		Options *redis.TSInfoOptions
	}{
		Ctx:     ctx,
		Key:     key,
		Options: options,
	}
	mock.lockTSInfoWithArgs.Lock()
	mock.calls.TSInfoWithArgs = append(mock.calls.TSInfoWithArgs, callInfo)
	mock.lockTSInfoWithArgs.Unlock()
	return mock.TSInfoWithArgsFunc(ctx, key, options)
}

// TSInfoWithArgsCalls gets all the calls that were made to TSInfoWithArgs.
// Check the length with:
//
//	len(mockedCmdable.TSInfoWithArgsCalls())
func (mock *MoqCmdable) TSInfoWithArgsCalls() []struct {
	Ctx     context.Context
	Key     string
	Options *redis.TSInfoOptions
} {
	var calls []struct {
		Ctx     context.Context
		Key     string
		Options *redis.TSInfoOptions
	}
	mock.lockTSInfoWithArgs.RLock()
	calls = mock.calls.TSInfoWithArgs
	mock.lockTSInfoWithArgs.RUnlock()
	return calls
}

// ResetTSInfoWithArgsCalls reset all the calls that were made to TSInfoWithArgs.
func (mock *MoqCmdable) ResetTSInfoWithArgsCalls() {
	mock.lockTSInfoWithArgs.Lock()
	mock.calls.TSInfoWithArgs = nil
	mock.lockTSInfoWithArgs.Unlock()
}

// TSMAdd calls TSMAddFunc.
func (mock *MoqCmdable) TSMAdd(ctx context.Context, ktvSlices [][]interface{}) *redis.IntSliceCmd {
	if mock.TSMAddFunc == nil {
		panic("MoqCmdable.TSMAddFunc: method is nil but Cmdable.TSMAdd was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		KtvSlices [][]interface{}
	}{
		Ctx:       ctx,
		KtvSlices: ktvSlices,
	}
	mock.lockTSMAdd.Lock()
	mock.calls.TSMAdd = append(mock.calls.TSMAdd, callInfo)
	mock.lockTSMAdd.Unlock()
	return mock.TSMAddFunc(ctx, ktvSlices)
}

// TSMAddCalls gets all the calls that were made to TSMAdd.
// Check the length with:
//
//	len(mockedCmdable.TSMAddCalls())
func (mock *MoqCmdable) TSMAddCalls() []struct {
	Ctx       context.Context
	KtvSlices [][]interface{}
} {
	var calls []struct {
		Ctx       context.Context
		KtvSlices [][]interface{}
	}
	mock.lockTSMAdd.RLock()
	calls = mock.calls.TSMAdd
	mock.lockTSMAdd.RUnlock()
	return calls
}

// ResetTSMAddCalls reset all the calls that were made to TSMAdd.
func (mock *MoqCmdable) ResetTSMAddCalls() {
	mock.lockTSMAdd.Lock()
	mock.calls.TSMAdd = nil
	mock.lockTSMAdd.Unlock()
}

// TSMGet calls TSMGetFunc.
func (mock *MoqCmdable) TSMGet(ctx context.Context, filters []string) *redis.MapStringSliceInterfaceCmd {
	if mock.TSMGetFunc == nil {
		panic("MoqCmdable.TSMGetFunc: method is nil but Cmdable.TSMGet was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Filters []string
	}{
		Ctx:     ctx,
		Filters: filters,
	}
	mock.lockTSMGet.Lock()
	mock.calls.TSMGet = append(mock.calls.TSMGet, callInfo)
	mock.lockTSMGet.Unlock()
	return mock.TSMGetFunc(ctx, filters)
}

// TSMGetCalls gets all the calls that were made to TSMGet.
// Check the length with:
//
//	len(mockedCmdable.TSMGetCalls())
func (mock *MoqCmdable) TSMGetCalls() []struct {
	Ctx     context.Context
	Filters []string
} {
	var calls []struct {
		Ctx     context.Context
		Filters []string
	}
	mock.lockTSMGet.RLock()
	calls = mock.calls.TSMGet
	mock.lockTSMGet.RUnlock()
	return calls
}

// ResetTSMGetCalls reset all the calls that were made to TSMGet.
func (mock *MoqCmdable) ResetTSMGetCalls() {
	mock.lockTSMGet.Lock()
	mock.calls.TSMGet = nil
	mock.lockTSMGet.Unlock()
}

// TSMGetWithArgs calls TSMGetWithArgsFunc.
func (mock *MoqCmdable) TSMGetWithArgs(ctx context.Context, filters []string, options *redis.TSMGetOptions) *redis.MapStringSliceInterfaceCmd {
	if mock.TSMGetWithArgsFunc == nil {
		panic("MoqCmdable.TSMGetWithArgsFunc: method is nil but Cmdable.TSMGetWithArgs was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Filters []string
		Options *redis.TSMGetOptions
	}{
		Ctx:     ctx,
		Filters: filters,
		Options: options,
	}
	mock.lockTSMGetWithArgs.Lock()
	mock.calls.TSMGetWithArgs = append(mock.calls.TSMGetWithArgs, callInfo)
	mock.lockTSMGetWithArgs.Unlock()
	return mock.TSMGetWithArgsFunc(ctx, filters, options)
}

// TSMGetWithArgsCalls gets all the calls that were made to TSMGetWithArgs.
// Check the length with:
//
//	len(mockedCmdable.TSMGetWithArgsCalls())
func (mock *MoqCmdable) TSMGetWithArgsCalls() []struct {
	Ctx     context.Context
	Filters []string
	Options *redis.TSMGetOptions
} {
	var calls []struct {
		Ctx     context.Context
		Filters []string
		Options *redis.TSMGetOptions
	}
	mock.lockTSMGetWithArgs.RLock()
	calls = mock.calls.TSMGetWithArgs
	mock.lockTSMGetWithArgs.RUnlock()
	return calls
}

// ResetTSMGetWithArgsCalls reset all the calls that were made to TSMGetWithArgs.
func (mock *MoqCmdable) ResetTSMGetWithArgsCalls() {
	mock.lockTSMGetWithArgs.Lock()
	mock.calls.TSMGetWithArgs = nil
	mock.lockTSMGetWithArgs.Unlock()
}

// TSMRange calls TSMRangeFunc.
func (mock *MoqCmdable) TSMRange(ctx context.Context, fromTimestamp int, toTimestamp int, filterExpr []string) *redis.MapStringSliceInterfaceCmd {
	if mock.TSMRangeFunc == nil {
		panic("MoqCmdable.TSMRangeFunc: method is nil but Cmdable.TSMRange was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		FromTimestamp int
		ToTimestamp   int
		FilterExpr    []string
	}{
		Ctx:           ctx,
		FromTimestamp: fromTimestamp,
		ToTimestamp:   toTimestamp,
		FilterExpr:    filterExpr,
	}
	mock.lockTSMRange.Lock()
	mock.calls.TSMRange = append(mock.calls.TSMRange, callInfo)
	mock.lockTSMRange.Unlock()
	return mock.TSMRangeFunc(ctx, fromTimestamp, toTimestamp, filterExpr)
}

// TSMRangeCalls gets all the calls that were made to TSMRange.
// Check the length with:
//
//	len(mockedCmdable.TSMRangeCalls())
func (mock *MoqCmdable) TSMRangeCalls() []struct {
	Ctx           context.Context
	FromTimestamp int
	ToTimestamp   int
	FilterExpr    []string
} {
	var calls []struct {
		Ctx           context.Context
		FromTimestamp int
		ToTimestamp   int
		FilterExpr    []string
	}
	mock.lockTSMRange.RLock()
	calls = mock.calls.TSMRange
	mock.lockTSMRange.RUnlock()
	return calls
}

// ResetTSMRangeCalls reset all the calls that were made to TSMRange.
func (mock *MoqCmdable) ResetTSMRangeCalls() {
	mock.lockTSMRange.Lock()
	mock.calls.TSMRange = nil
	mock.lockTSMRange.Unlock()
}

// TSMRangeWithArgs calls TSMRangeWithArgsFunc.
func (mock *MoqCmdable) TSMRangeWithArgs(ctx context.Context, fromTimestamp int, toTimestamp int, filterExpr []string, options *redis.TSMRangeOptions) *redis.MapStringSliceInterfaceCmd {
	if mock.TSMRangeWithArgsFunc == nil {
		panic("MoqCmdable.TSMRangeWithArgsFunc: method is nil but Cmdable.TSMRangeWithArgs was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		FromTimestamp int
		ToTimestamp   int
		FilterExpr    []string
		Options       *redis.TSMRangeOptions
	}{
		Ctx:           ctx,
		FromTimestamp: fromTimestamp,
		ToTimestamp:   toTimestamp,
		FilterExpr:    filterExpr,
		Options:       options,
	}
	mock.lockTSMRangeWithArgs.Lock()
	mock.calls.TSMRangeWithArgs = append(mock.calls.TSMRangeWithArgs, callInfo)
	mock.lockTSMRangeWithArgs.Unlock()
	return mock.TSMRangeWithArgsFunc(ctx, fromTimestamp, toTimestamp, filterExpr, options)
}

// TSMRangeWithArgsCalls gets all the calls that were made to TSMRangeWithArgs.
// Check the length with:
//
//	len(mockedCmdable.TSMRangeWithArgsCalls())
func (mock *MoqCmdable) TSMRangeWithArgsCalls() []struct {
	Ctx           context.Context
	FromTimestamp int
	ToTimestamp   int
	FilterExpr    []string
	Options       *redis.TSMRangeOptions
} {
	var calls []struct {
		Ctx           context.Context
		FromTimestamp int
		ToTimestamp   int
		FilterExpr    []string
		Options       *redis.TSMRangeOptions
	}
	mock.lockTSMRangeWithArgs.RLock()
	calls = mock.calls.TSMRangeWithArgs
	mock.lockTSMRangeWithArgs.RUnlock()
	return calls
}

// ResetTSMRangeWithArgsCalls reset all the calls that were made to TSMRangeWithArgs.
func (mock *MoqCmdable) ResetTSMRangeWithArgsCalls() {
	mock.lockTSMRangeWithArgs.Lock()
	mock.calls.TSMRangeWithArgs = nil
	mock.lockTSMRangeWithArgs.Unlock()
}

// TSMRevRange calls TSMRevRangeFunc.
func (mock *MoqCmdable) TSMRevRange(ctx context.Context, fromTimestamp int, toTimestamp int, filterExpr []string) *redis.MapStringSliceInterfaceCmd {
	if mock.TSMRevRangeFunc == nil {
		panic("MoqCmdable.TSMRevRangeFunc: method is nil but Cmdable.TSMRevRange was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		FromTimestamp int
		ToTimestamp   int
		FilterExpr    []string
	}{
		Ctx:           ctx,
		FromTimestamp: fromTimestamp,
		ToTimestamp:   toTimestamp,
		FilterExpr:    filterExpr,
	}
	mock.lockTSMRevRange.Lock()
	mock.calls.TSMRevRange = append(mock.calls.TSMRevRange, callInfo)
	mock.lockTSMRevRange.Unlock()
	return mock.TSMRevRangeFunc(ctx, fromTimestamp, toTimestamp, filterExpr)
}

// TSMRevRangeCalls gets all the calls that were made to TSMRevRange.
// Check the length with:
//
//	len(mockedCmdable.TSMRevRangeCalls())
func (mock *MoqCmdable) TSMRevRangeCalls() []struct {
	Ctx           context.Context
	FromTimestamp int
	ToTimestamp   int
	FilterExpr    []string
} {
	var calls []struct {
		Ctx           context.Context
		FromTimestamp int
		ToTimestamp   int
		FilterExpr    []string
	}
	mock.lockTSMRevRange.RLock()
	calls = mock.calls.TSMRevRange
	mock.lockTSMRevRange.RUnlock()
	return calls
}

// ResetTSMRevRangeCalls reset all the calls that were made to TSMRevRange.
func (mock *MoqCmdable) ResetTSMRevRangeCalls() {
	mock.lockTSMRevRange.Lock()
	mock.calls.TSMRevRange = nil
	mock.lockTSMRevRange.Unlock()
}

// TSMRevRangeWithArgs calls TSMRevRangeWithArgsFunc.
func (mock *MoqCmdable) TSMRevRangeWithArgs(ctx context.Context, fromTimestamp int, toTimestamp int, filterExpr []string, options *redis.TSMRevRangeOptions) *redis.MapStringSliceInterfaceCmd {
	if mock.TSMRevRangeWithArgsFunc == nil {
		panic("MoqCmdable.TSMRevRangeWithArgsFunc: method is nil but Cmdable.TSMRevRangeWithArgs was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		FromTimestamp int
		ToTimestamp   int
		FilterExpr    []string
		Options       *redis.TSMRevRangeOptions
	}{
		Ctx:           ctx,
		FromTimestamp: fromTimestamp,
		ToTimestamp:   toTimestamp,
		FilterExpr:    filterExpr,
		Options:       options,
	}
	mock.lockTSMRevRangeWithArgs.Lock()
	mock.calls.TSMRevRangeWithArgs = append(mock.calls.TSMRevRangeWithArgs, callInfo)
	mock.lockTSMRevRangeWithArgs.Unlock()
	return mock.TSMRevRangeWithArgsFunc(ctx, fromTimestamp, toTimestamp, filterExpr, options)
}

// TSMRevRangeWithArgsCalls gets all the calls that were made to TSMRevRangeWithArgs.
// Check the length with:
//
//	len(mockedCmdable.TSMRevRangeWithArgsCalls())
func (mock *MoqCmdable) TSMRevRangeWithArgsCalls() []struct {
	Ctx           context.Context
	FromTimestamp int
	ToTimestamp   int
	FilterExpr    []string
	Options       *redis.TSMRevRangeOptions
} {
	var calls []struct {
		Ctx           context.Context
		FromTimestamp int
		ToTimestamp   int
		FilterExpr    []string
		Options       *redis.TSMRevRangeOptions
	}
	mock.lockTSMRevRangeWithArgs.RLock()
	calls = mock.calls.TSMRevRangeWithArgs
	mock.lockTSMRevRangeWithArgs.RUnlock()
	return calls
}

// ResetTSMRevRangeWithArgsCalls reset all the calls that were made to TSMRevRangeWithArgs.
func (mock *MoqCmdable) ResetTSMRevRangeWithArgsCalls() {
	mock.lockTSMRevRangeWithArgs.Lock()
	mock.calls.TSMRevRangeWithArgs = nil
	mock.lockTSMRevRangeWithArgs.Unlock()
}

// TSQueryIndex calls TSQueryIndexFunc.
func (mock *MoqCmdable) TSQueryIndex(ctx context.Context, filterExpr []string) *redis.StringSliceCmd {
	if mock.TSQueryIndexFunc == nil {
		panic("MoqCmdable.TSQueryIndexFunc: method is nil but Cmdable.TSQueryIndex was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		FilterExpr []string
	}{
		Ctx:        ctx,
		FilterExpr: filterExpr,
	}
	mock.lockTSQueryIndex.Lock()
	mock.calls.TSQueryIndex = append(mock.calls.TSQueryIndex, callInfo)
	mock.lockTSQueryIndex.Unlock()
	return mock.TSQueryIndexFunc(ctx, filterExpr)
}

// TSQueryIndexCalls gets all the calls that were made to TSQueryIndex.
// Check the length with:
//
//	len(mockedCmdable.TSQueryIndexCalls())
func (mock *MoqCmdable) TSQueryIndexCalls() []struct {
	Ctx        context.Context
	FilterExpr []string
} {
	var calls []struct {
		Ctx        context.Context
		FilterExpr []string
	}
	mock.lockTSQueryIndex.RLock()
	calls = mock.calls.TSQueryIndex
	mock.lockTSQueryIndex.RUnlock()
	return calls
}

// ResetTSQueryIndexCalls reset all the calls that were made to TSQueryIndex.
func (mock *MoqCmdable) ResetTSQueryIndexCalls() {
	mock.lockTSQueryIndex.Lock()
	mock.calls.TSQueryIndex = nil
	mock.lockTSQueryIndex.Unlock()
}

// TSRange calls TSRangeFunc.
func (mock *MoqCmdable) TSRange(ctx context.Context, key string, fromTimestamp int, toTimestamp int) *redis.TSTimestampValueSliceCmd {
	if mock.TSRangeFunc == nil {
		panic("MoqCmdable.TSRangeFunc: method is nil but Cmdable.TSRange was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		Key           string
		FromTimestamp int
		ToTimestamp   int
	}{
		Ctx:           ctx,
		Key:           key,
		FromTimestamp: fromTimestamp,
		ToTimestamp:   toTimestamp,
	}
	mock.lockTSRange.Lock()
	mock.calls.TSRange = append(mock.calls.TSRange, callInfo)
	mock.lockTSRange.Unlock()
	return mock.TSRangeFunc(ctx, key, fromTimestamp, toTimestamp)
}

// TSRangeCalls gets all the calls that were made to TSRange.
// Check the length with:
//
//	len(mockedCmdable.TSRangeCalls())
func (mock *MoqCmdable) TSRangeCalls() []struct {
	Ctx           context.Context
	Key           string
	FromTimestamp int
	ToTimestamp   int
} {
	var calls []struct {
		Ctx           context.Context
		Key           string
		FromTimestamp int
		ToTimestamp   int
	}
	mock.lockTSRange.RLock()
	calls = mock.calls.TSRange
	mock.lockTSRange.RUnlock()
	return calls
}

// ResetTSRangeCalls reset all the calls that were made to TSRange.
func (mock *MoqCmdable) ResetTSRangeCalls() {
	mock.lockTSRange.Lock()
	mock.calls.TSRange = nil
	mock.lockTSRange.Unlock()
}

// TSRangeWithArgs calls TSRangeWithArgsFunc.
func (mock *MoqCmdable) TSRangeWithArgs(ctx context.Context, key string, fromTimestamp int, toTimestamp int, options *redis.TSRangeOptions) *redis.TSTimestampValueSliceCmd {
	if mock.TSRangeWithArgsFunc == nil {
		panic("MoqCmdable.TSRangeWithArgsFunc: method is nil but Cmdable.TSRangeWithArgs was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		Key           string
		FromTimestamp int
		ToTimestamp   int
		Options       *redis.TSRangeOptions
	}{
		Ctx:           ctx,
		Key:           key,
		FromTimestamp: fromTimestamp,
		ToTimestamp:   toTimestamp,
		Options:       options,
	}
	mock.lockTSRangeWithArgs.Lock()
	mock.calls.TSRangeWithArgs = append(mock.calls.TSRangeWithArgs, callInfo)
	mock.lockTSRangeWithArgs.Unlock()
	return mock.TSRangeWithArgsFunc(ctx, key, fromTimestamp, toTimestamp, options)
}

// TSRangeWithArgsCalls gets all the calls that were made to TSRangeWithArgs.
// Check the length with:
//
//	len(mockedCmdable.TSRangeWithArgsCalls())
func (mock *MoqCmdable) TSRangeWithArgsCalls() []struct {
	Ctx           context.Context
	Key           string
	FromTimestamp int
	ToTimestamp   int
	Options       *redis.TSRangeOptions
} {
	var calls []struct {
		Ctx           context.Context
		Key           string
		FromTimestamp int
		ToTimestamp   int
		Options       *redis.TSRangeOptions
	}
	mock.lockTSRangeWithArgs.RLock()
	calls = mock.calls.TSRangeWithArgs
	mock.lockTSRangeWithArgs.RUnlock()
	return calls
}

// ResetTSRangeWithArgsCalls reset all the calls that were made to TSRangeWithArgs.
func (mock *MoqCmdable) ResetTSRangeWithArgsCalls() {
	mock.lockTSRangeWithArgs.Lock()
	mock.calls.TSRangeWithArgs = nil
	mock.lockTSRangeWithArgs.Unlock()
}

// TSRevRange calls TSRevRangeFunc.
func (mock *MoqCmdable) TSRevRange(ctx context.Context, key string, fromTimestamp int, toTimestamp int) *redis.TSTimestampValueSliceCmd {
	if mock.TSRevRangeFunc == nil {
		panic("MoqCmdable.TSRevRangeFunc: method is nil but Cmdable.TSRevRange was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		Key           string
		FromTimestamp int
		ToTimestamp   int
	}{
		Ctx:           ctx,
		Key:           key,
		FromTimestamp: fromTimestamp,
		ToTimestamp:   toTimestamp,
	}
	mock.lockTSRevRange.Lock()
	mock.calls.TSRevRange = append(mock.calls.TSRevRange, callInfo)
	mock.lockTSRevRange.Unlock()
	return mock.TSRevRangeFunc(ctx, key, fromTimestamp, toTimestamp)
}

// TSRevRangeCalls gets all the calls that were made to TSRevRange.
// Check the length with:
//
//	len(mockedCmdable.TSRevRangeCalls())
func (mock *MoqCmdable) TSRevRangeCalls() []struct {
	Ctx           context.Context
	Key           string
	FromTimestamp int
	ToTimestamp   int
} {
	var calls []struct {
		Ctx           context.Context
		Key           string
		FromTimestamp int
		ToTimestamp   int
	}
	mock.lockTSRevRange.RLock()
	calls = mock.calls.TSRevRange
	mock.lockTSRevRange.RUnlock()
	return calls
}

// ResetTSRevRangeCalls reset all the calls that were made to TSRevRange.
func (mock *MoqCmdable) ResetTSRevRangeCalls() {
	mock.lockTSRevRange.Lock()
	mock.calls.TSRevRange = nil
	mock.lockTSRevRange.Unlock()
}

// TSRevRangeWithArgs calls TSRevRangeWithArgsFunc.
func (mock *MoqCmdable) TSRevRangeWithArgs(ctx context.Context, key string, fromTimestamp int, toTimestamp int, options *redis.TSRevRangeOptions) *redis.TSTimestampValueSliceCmd {
	if mock.TSRevRangeWithArgsFunc == nil {
		panic("MoqCmdable.TSRevRangeWithArgsFunc: method is nil but Cmdable.TSRevRangeWithArgs was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		Key           string
		FromTimestamp int
		ToTimestamp   int
		Options       *redis.TSRevRangeOptions
	}{
		Ctx:           ctx,
		Key:           key,
		FromTimestamp: fromTimestamp,
		ToTimestamp:   toTimestamp,
		Options:       options,
	}
	mock.lockTSRevRangeWithArgs.Lock()
	mock.calls.TSRevRangeWithArgs = append(mock.calls.TSRevRangeWithArgs, callInfo)
	mock.lockTSRevRangeWithArgs.Unlock()
	return mock.TSRevRangeWithArgsFunc(ctx, key, fromTimestamp, toTimestamp, options)
}

// TSRevRangeWithArgsCalls gets all the calls that were made to TSRevRangeWithArgs.
// Check the length with:
//
//	len(mockedCmdable.TSRevRangeWithArgsCalls())
func (mock *MoqCmdable) TSRevRangeWithArgsCalls() []struct {
	Ctx           context.Context
	Key           string
	FromTimestamp int
	ToTimestamp   int
	Options       *redis.TSRevRangeOptions
} {
	var calls []struct {
		Ctx           context.Context
		Key           string
		FromTimestamp int
		ToTimestamp   int
		Options       *redis.TSRevRangeOptions
	}
	mock.lockTSRevRangeWithArgs.RLock()
	calls = mock.calls.TSRevRangeWithArgs
	mock.lockTSRevRangeWithArgs.RUnlock()
	return calls
}

// ResetTSRevRangeWithArgsCalls reset all the calls that were made to TSRevRangeWithArgs.
func (mock *MoqCmdable) ResetTSRevRangeWithArgsCalls() {
	mock.lockTSRevRangeWithArgs.Lock()
	mock.calls.TSRevRangeWithArgs = nil
	mock.lockTSRevRangeWithArgs.Unlock()
}

// TTL calls TTLFunc.
func (mock *MoqCmdable) TTL(ctx context.Context, key string) *redis.DurationCmd {
	if mock.TTLFunc == nil {
		panic("MoqCmdable.TTLFunc: method is nil but Cmdable.TTL was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockTTL.Lock()
	mock.calls.TTL = append(mock.calls.TTL, callInfo)
	mock.lockTTL.Unlock()
	return mock.TTLFunc(ctx, key)
}

// TTLCalls gets all the calls that were made to TTL.
// Check the length with:
//
//	len(mockedCmdable.TTLCalls())
func (mock *MoqCmdable) TTLCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockTTL.RLock()
	calls = mock.calls.TTL
	mock.lockTTL.RUnlock()
	return calls
}

// ResetTTLCalls reset all the calls that were made to TTL.
func (mock *MoqCmdable) ResetTTLCalls() {
	mock.lockTTL.Lock()
	mock.calls.TTL = nil
	mock.lockTTL.Unlock()
}

// Time calls TimeFunc.
func (mock *MoqCmdable) Time(ctx context.Context) *redis.TimeCmd {
	if mock.TimeFunc == nil {
		panic("MoqCmdable.TimeFunc: method is nil but Cmdable.Time was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockTime.Lock()
	mock.calls.Time = append(mock.calls.Time, callInfo)
	mock.lockTime.Unlock()
	return mock.TimeFunc(ctx)
}

// TimeCalls gets all the calls that were made to Time.
// Check the length with:
//
//	len(mockedCmdable.TimeCalls())
func (mock *MoqCmdable) TimeCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockTime.RLock()
	calls = mock.calls.Time
	mock.lockTime.RUnlock()
	return calls
}

// ResetTimeCalls reset all the calls that were made to Time.
func (mock *MoqCmdable) ResetTimeCalls() {
	mock.lockTime.Lock()
	mock.calls.Time = nil
	mock.lockTime.Unlock()
}

// TopKAdd calls TopKAddFunc.
func (mock *MoqCmdable) TopKAdd(ctx context.Context, key string, elements ...interface{}) *redis.StringSliceCmd {
	if mock.TopKAddFunc == nil {
		panic("MoqCmdable.TopKAddFunc: method is nil but Cmdable.TopKAdd was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Key      string
		Elements []interface{}
	}{
		Ctx:      ctx,
		Key:      key,
		Elements: elements,
	}
	mock.lockTopKAdd.Lock()
	mock.calls.TopKAdd = append(mock.calls.TopKAdd, callInfo)
	mock.lockTopKAdd.Unlock()
	return mock.TopKAddFunc(ctx, key, elements...)
}

// TopKAddCalls gets all the calls that were made to TopKAdd.
// Check the length with:
//
//	len(mockedCmdable.TopKAddCalls())
func (mock *MoqCmdable) TopKAddCalls() []struct {
	Ctx      context.Context
	Key      string
	Elements []interface{}
} {
	var calls []struct {
		Ctx      context.Context
		Key      string
		Elements []interface{}
	}
	mock.lockTopKAdd.RLock()
	calls = mock.calls.TopKAdd
	mock.lockTopKAdd.RUnlock()
	return calls
}

// ResetTopKAddCalls reset all the calls that were made to TopKAdd.
func (mock *MoqCmdable) ResetTopKAddCalls() {
	mock.lockTopKAdd.Lock()
	mock.calls.TopKAdd = nil
	mock.lockTopKAdd.Unlock()
}

// TopKCount calls TopKCountFunc.
func (mock *MoqCmdable) TopKCount(ctx context.Context, key string, elements ...interface{}) *redis.IntSliceCmd {
	if mock.TopKCountFunc == nil {
		panic("MoqCmdable.TopKCountFunc: method is nil but Cmdable.TopKCount was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Key      string
		Elements []interface{}
	}{
		Ctx:      ctx,
		Key:      key,
		Elements: elements,
	}
	mock.lockTopKCount.Lock()
	mock.calls.TopKCount = append(mock.calls.TopKCount, callInfo)
	mock.lockTopKCount.Unlock()
	return mock.TopKCountFunc(ctx, key, elements...)
}

// TopKCountCalls gets all the calls that were made to TopKCount.
// Check the length with:
//
//	len(mockedCmdable.TopKCountCalls())
func (mock *MoqCmdable) TopKCountCalls() []struct {
	Ctx      context.Context
	Key      string
	Elements []interface{}
} {
	var calls []struct {
		Ctx      context.Context
		Key      string
		Elements []interface{}
	}
	mock.lockTopKCount.RLock()
	calls = mock.calls.TopKCount
	mock.lockTopKCount.RUnlock()
	return calls
}

// ResetTopKCountCalls reset all the calls that were made to TopKCount.
func (mock *MoqCmdable) ResetTopKCountCalls() {
	mock.lockTopKCount.Lock()
	mock.calls.TopKCount = nil
	mock.lockTopKCount.Unlock()
}

// TopKIncrBy calls TopKIncrByFunc.
func (mock *MoqCmdable) TopKIncrBy(ctx context.Context, key string, elements ...interface{}) *redis.StringSliceCmd {
	if mock.TopKIncrByFunc == nil {
		panic("MoqCmdable.TopKIncrByFunc: method is nil but Cmdable.TopKIncrBy was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Key      string
		Elements []interface{}
	}{
		Ctx:      ctx,
		Key:      key,
		Elements: elements,
	}
	mock.lockTopKIncrBy.Lock()
	mock.calls.TopKIncrBy = append(mock.calls.TopKIncrBy, callInfo)
	mock.lockTopKIncrBy.Unlock()
	return mock.TopKIncrByFunc(ctx, key, elements...)
}

// TopKIncrByCalls gets all the calls that were made to TopKIncrBy.
// Check the length with:
//
//	len(mockedCmdable.TopKIncrByCalls())
func (mock *MoqCmdable) TopKIncrByCalls() []struct {
	Ctx      context.Context
	Key      string
	Elements []interface{}
} {
	var calls []struct {
		Ctx      context.Context
		Key      string
		Elements []interface{}
	}
	mock.lockTopKIncrBy.RLock()
	calls = mock.calls.TopKIncrBy
	mock.lockTopKIncrBy.RUnlock()
	return calls
}

// ResetTopKIncrByCalls reset all the calls that were made to TopKIncrBy.
func (mock *MoqCmdable) ResetTopKIncrByCalls() {
	mock.lockTopKIncrBy.Lock()
	mock.calls.TopKIncrBy = nil
	mock.lockTopKIncrBy.Unlock()
}

// TopKInfo calls TopKInfoFunc.
func (mock *MoqCmdable) TopKInfo(ctx context.Context, key string) *redis.TopKInfoCmd {
	if mock.TopKInfoFunc == nil {
		panic("MoqCmdable.TopKInfoFunc: method is nil but Cmdable.TopKInfo was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockTopKInfo.Lock()
	mock.calls.TopKInfo = append(mock.calls.TopKInfo, callInfo)
	mock.lockTopKInfo.Unlock()
	return mock.TopKInfoFunc(ctx, key)
}

// TopKInfoCalls gets all the calls that were made to TopKInfo.
// Check the length with:
//
//	len(mockedCmdable.TopKInfoCalls())
func (mock *MoqCmdable) TopKInfoCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockTopKInfo.RLock()
	calls = mock.calls.TopKInfo
	mock.lockTopKInfo.RUnlock()
	return calls
}

// ResetTopKInfoCalls reset all the calls that were made to TopKInfo.
func (mock *MoqCmdable) ResetTopKInfoCalls() {
	mock.lockTopKInfo.Lock()
	mock.calls.TopKInfo = nil
	mock.lockTopKInfo.Unlock()
}

// TopKList calls TopKListFunc.
func (mock *MoqCmdable) TopKList(ctx context.Context, key string) *redis.StringSliceCmd {
	if mock.TopKListFunc == nil {
		panic("MoqCmdable.TopKListFunc: method is nil but Cmdable.TopKList was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockTopKList.Lock()
	mock.calls.TopKList = append(mock.calls.TopKList, callInfo)
	mock.lockTopKList.Unlock()
	return mock.TopKListFunc(ctx, key)
}

// TopKListCalls gets all the calls that were made to TopKList.
// Check the length with:
//
//	len(mockedCmdable.TopKListCalls())
func (mock *MoqCmdable) TopKListCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockTopKList.RLock()
	calls = mock.calls.TopKList
	mock.lockTopKList.RUnlock()
	return calls
}

// ResetTopKListCalls reset all the calls that were made to TopKList.
func (mock *MoqCmdable) ResetTopKListCalls() {
	mock.lockTopKList.Lock()
	mock.calls.TopKList = nil
	mock.lockTopKList.Unlock()
}

// TopKListWithCount calls TopKListWithCountFunc.
func (mock *MoqCmdable) TopKListWithCount(ctx context.Context, key string) *redis.MapStringIntCmd {
	if mock.TopKListWithCountFunc == nil {
		panic("MoqCmdable.TopKListWithCountFunc: method is nil but Cmdable.TopKListWithCount was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockTopKListWithCount.Lock()
	mock.calls.TopKListWithCount = append(mock.calls.TopKListWithCount, callInfo)
	mock.lockTopKListWithCount.Unlock()
	return mock.TopKListWithCountFunc(ctx, key)
}

// TopKListWithCountCalls gets all the calls that were made to TopKListWithCount.
// Check the length with:
//
//	len(mockedCmdable.TopKListWithCountCalls())
func (mock *MoqCmdable) TopKListWithCountCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockTopKListWithCount.RLock()
	calls = mock.calls.TopKListWithCount
	mock.lockTopKListWithCount.RUnlock()
	return calls
}

// ResetTopKListWithCountCalls reset all the calls that were made to TopKListWithCount.
func (mock *MoqCmdable) ResetTopKListWithCountCalls() {
	mock.lockTopKListWithCount.Lock()
	mock.calls.TopKListWithCount = nil
	mock.lockTopKListWithCount.Unlock()
}

// TopKQuery calls TopKQueryFunc.
func (mock *MoqCmdable) TopKQuery(ctx context.Context, key string, elements ...interface{}) *redis.BoolSliceCmd {
	if mock.TopKQueryFunc == nil {
		panic("MoqCmdable.TopKQueryFunc: method is nil but Cmdable.TopKQuery was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Key      string
		Elements []interface{}
	}{
		Ctx:      ctx,
		Key:      key,
		Elements: elements,
	}
	mock.lockTopKQuery.Lock()
	mock.calls.TopKQuery = append(mock.calls.TopKQuery, callInfo)
	mock.lockTopKQuery.Unlock()
	return mock.TopKQueryFunc(ctx, key, elements...)
}

// TopKQueryCalls gets all the calls that were made to TopKQuery.
// Check the length with:
//
//	len(mockedCmdable.TopKQueryCalls())
func (mock *MoqCmdable) TopKQueryCalls() []struct {
	Ctx      context.Context
	Key      string
	Elements []interface{}
} {
	var calls []struct {
		Ctx      context.Context
		Key      string
		Elements []interface{}
	}
	mock.lockTopKQuery.RLock()
	calls = mock.calls.TopKQuery
	mock.lockTopKQuery.RUnlock()
	return calls
}

// ResetTopKQueryCalls reset all the calls that were made to TopKQuery.
func (mock *MoqCmdable) ResetTopKQueryCalls() {
	mock.lockTopKQuery.Lock()
	mock.calls.TopKQuery = nil
	mock.lockTopKQuery.Unlock()
}

// TopKReserve calls TopKReserveFunc.
func (mock *MoqCmdable) TopKReserve(ctx context.Context, key string, k int64) *redis.StatusCmd {
	if mock.TopKReserveFunc == nil {
		panic("MoqCmdable.TopKReserveFunc: method is nil but Cmdable.TopKReserve was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
		K   int64
	}{
		Ctx: ctx,
		Key: key,
		K:   k,
	}
	mock.lockTopKReserve.Lock()
	mock.calls.TopKReserve = append(mock.calls.TopKReserve, callInfo)
	mock.lockTopKReserve.Unlock()
	return mock.TopKReserveFunc(ctx, key, k)
}

// TopKReserveCalls gets all the calls that were made to TopKReserve.
// Check the length with:
//
//	len(mockedCmdable.TopKReserveCalls())
func (mock *MoqCmdable) TopKReserveCalls() []struct {
	Ctx context.Context
	Key string
	K   int64
} {
	var calls []struct {
		Ctx context.Context
		Key string
		K   int64
	}
	mock.lockTopKReserve.RLock()
	calls = mock.calls.TopKReserve
	mock.lockTopKReserve.RUnlock()
	return calls
}

// ResetTopKReserveCalls reset all the calls that were made to TopKReserve.
func (mock *MoqCmdable) ResetTopKReserveCalls() {
	mock.lockTopKReserve.Lock()
	mock.calls.TopKReserve = nil
	mock.lockTopKReserve.Unlock()
}

// TopKReserveWithOptions calls TopKReserveWithOptionsFunc.
func (mock *MoqCmdable) TopKReserveWithOptions(ctx context.Context, key string, k int64, width int64, depth int64, decay float64) *redis.StatusCmd {
	if mock.TopKReserveWithOptionsFunc == nil {
		panic("MoqCmdable.TopKReserveWithOptionsFunc: method is nil but Cmdable.TopKReserveWithOptions was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		K     int64
		Width int64
		Depth int64
		Decay float64
	}{
		Ctx:   ctx,
		Key:   key,
		K:     k,
		Width: width,
		Depth: depth,
		Decay: decay,
	}
	mock.lockTopKReserveWithOptions.Lock()
	mock.calls.TopKReserveWithOptions = append(mock.calls.TopKReserveWithOptions, callInfo)
	mock.lockTopKReserveWithOptions.Unlock()
	return mock.TopKReserveWithOptionsFunc(ctx, key, k, width, depth, decay)
}

// TopKReserveWithOptionsCalls gets all the calls that were made to TopKReserveWithOptions.
// Check the length with:
//
//	len(mockedCmdable.TopKReserveWithOptionsCalls())
func (mock *MoqCmdable) TopKReserveWithOptionsCalls() []struct {
	Ctx   context.Context
	Key   string
	K     int64
	Width int64
	Depth int64
	Decay float64
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		K     int64
		Width int64
		Depth int64
		Decay float64
	}
	mock.lockTopKReserveWithOptions.RLock()
	calls = mock.calls.TopKReserveWithOptions
	mock.lockTopKReserveWithOptions.RUnlock()
	return calls
}

// ResetTopKReserveWithOptionsCalls reset all the calls that were made to TopKReserveWithOptions.
func (mock *MoqCmdable) ResetTopKReserveWithOptionsCalls() {
	mock.lockTopKReserveWithOptions.Lock()
	mock.calls.TopKReserveWithOptions = nil
	mock.lockTopKReserveWithOptions.Unlock()
}

// Touch calls TouchFunc.
func (mock *MoqCmdable) Touch(ctx context.Context, keys ...string) *redis.IntCmd {
	if mock.TouchFunc == nil {
		panic("MoqCmdable.TouchFunc: method is nil but Cmdable.Touch was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Keys []string
	}{
		Ctx:  ctx,
		Keys: keys,
	}
	mock.lockTouch.Lock()
	mock.calls.Touch = append(mock.calls.Touch, callInfo)
	mock.lockTouch.Unlock()
	return mock.TouchFunc(ctx, keys...)
}

// TouchCalls gets all the calls that were made to Touch.
// Check the length with:
//
//	len(mockedCmdable.TouchCalls())
func (mock *MoqCmdable) TouchCalls() []struct {
	Ctx  context.Context
	Keys []string
} {
	var calls []struct {
		Ctx  context.Context
		Keys []string
	}
	mock.lockTouch.RLock()
	calls = mock.calls.Touch
	mock.lockTouch.RUnlock()
	return calls
}

// ResetTouchCalls reset all the calls that were made to Touch.
func (mock *MoqCmdable) ResetTouchCalls() {
	mock.lockTouch.Lock()
	mock.calls.Touch = nil
	mock.lockTouch.Unlock()
}

// TxPipeline calls TxPipelineFunc.
func (mock *MoqCmdable) TxPipeline() redis.Pipeliner {
	if mock.TxPipelineFunc == nil {
		panic("MoqCmdable.TxPipelineFunc: method is nil but Cmdable.TxPipeline was just called")
	}
	callInfo := struct {
	}{}
	mock.lockTxPipeline.Lock()
	mock.calls.TxPipeline = append(mock.calls.TxPipeline, callInfo)
	mock.lockTxPipeline.Unlock()
	return mock.TxPipelineFunc()
}

// TxPipelineCalls gets all the calls that were made to TxPipeline.
// Check the length with:
//
//	len(mockedCmdable.TxPipelineCalls())
func (mock *MoqCmdable) TxPipelineCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockTxPipeline.RLock()
	calls = mock.calls.TxPipeline
	mock.lockTxPipeline.RUnlock()
	return calls
}

// ResetTxPipelineCalls reset all the calls that were made to TxPipeline.
func (mock *MoqCmdable) ResetTxPipelineCalls() {
	mock.lockTxPipeline.Lock()
	mock.calls.TxPipeline = nil
	mock.lockTxPipeline.Unlock()
}

// TxPipelined calls TxPipelinedFunc.
func (mock *MoqCmdable) TxPipelined(ctx context.Context, fn func(redis.Pipeliner) error) ([]redis.Cmder, error) {
	if mock.TxPipelinedFunc == nil {
		panic("MoqCmdable.TxPipelinedFunc: method is nil but Cmdable.TxPipelined was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Fn  func(redis.Pipeliner) error
	}{
		Ctx: ctx,
		Fn:  fn,
	}
	mock.lockTxPipelined.Lock()
	mock.calls.TxPipelined = append(mock.calls.TxPipelined, callInfo)
	mock.lockTxPipelined.Unlock()
	return mock.TxPipelinedFunc(ctx, fn)
}

// TxPipelinedCalls gets all the calls that were made to TxPipelined.
// Check the length with:
//
//	len(mockedCmdable.TxPipelinedCalls())
func (mock *MoqCmdable) TxPipelinedCalls() []struct {
	Ctx context.Context
	Fn  func(redis.Pipeliner) error
} {
	var calls []struct {
		Ctx context.Context
		Fn  func(redis.Pipeliner) error
	}
	mock.lockTxPipelined.RLock()
	calls = mock.calls.TxPipelined
	mock.lockTxPipelined.RUnlock()
	return calls
}

// ResetTxPipelinedCalls reset all the calls that were made to TxPipelined.
func (mock *MoqCmdable) ResetTxPipelinedCalls() {
	mock.lockTxPipelined.Lock()
	mock.calls.TxPipelined = nil
	mock.lockTxPipelined.Unlock()
}

// Type calls TypeFunc.
func (mock *MoqCmdable) Type(ctx context.Context, key string) *redis.StatusCmd {
	if mock.TypeFunc == nil {
		panic("MoqCmdable.TypeFunc: method is nil but Cmdable.Type was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockType.Lock()
	mock.calls.Type = append(mock.calls.Type, callInfo)
	mock.lockType.Unlock()
	return mock.TypeFunc(ctx, key)
}

// TypeCalls gets all the calls that were made to Type.
// Check the length with:
//
//	len(mockedCmdable.TypeCalls())
func (mock *MoqCmdable) TypeCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockType.RLock()
	calls = mock.calls.Type
	mock.lockType.RUnlock()
	return calls
}

// ResetTypeCalls reset all the calls that were made to Type.
func (mock *MoqCmdable) ResetTypeCalls() {
	mock.lockType.Lock()
	mock.calls.Type = nil
	mock.lockType.Unlock()
}

// Unlink calls UnlinkFunc.
func (mock *MoqCmdable) Unlink(ctx context.Context, keys ...string) *redis.IntCmd {
	if mock.UnlinkFunc == nil {
		panic("MoqCmdable.UnlinkFunc: method is nil but Cmdable.Unlink was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Keys []string
	}{
		Ctx:  ctx,
		Keys: keys,
	}
	mock.lockUnlink.Lock()
	mock.calls.Unlink = append(mock.calls.Unlink, callInfo)
	mock.lockUnlink.Unlock()
	return mock.UnlinkFunc(ctx, keys...)
}

// UnlinkCalls gets all the calls that were made to Unlink.
// Check the length with:
//
//	len(mockedCmdable.UnlinkCalls())
func (mock *MoqCmdable) UnlinkCalls() []struct {
	Ctx  context.Context
	Keys []string
} {
	var calls []struct {
		Ctx  context.Context
		Keys []string
	}
	mock.lockUnlink.RLock()
	calls = mock.calls.Unlink
	mock.lockUnlink.RUnlock()
	return calls
}

// ResetUnlinkCalls reset all the calls that were made to Unlink.
func (mock *MoqCmdable) ResetUnlinkCalls() {
	mock.lockUnlink.Lock()
	mock.calls.Unlink = nil
	mock.lockUnlink.Unlock()
}

// VAdd calls VAddFunc.
func (mock *MoqCmdable) VAdd(ctx context.Context, key string, element string, val redis.Vector) *redis.BoolCmd {
	if mock.VAddFunc == nil {
		panic("MoqCmdable.VAddFunc: method is nil but Cmdable.VAdd was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Key     string
		Element string
		Val     redis.Vector
	}{
		Ctx:     ctx,
		Key:     key,
		Element: element,
		Val:     val,
	}
	mock.lockVAdd.Lock()
	mock.calls.VAdd = append(mock.calls.VAdd, callInfo)
	mock.lockVAdd.Unlock()
	return mock.VAddFunc(ctx, key, element, val)
}

// VAddCalls gets all the calls that were made to VAdd.
// Check the length with:
//
//	len(mockedCmdable.VAddCalls())
func (mock *MoqCmdable) VAddCalls() []struct {
	Ctx     context.Context
	Key     string
	Element string
	Val     redis.Vector
} {
	var calls []struct {
		Ctx     context.Context
		Key     string
		Element string
		Val     redis.Vector
	}
	mock.lockVAdd.RLock()
	calls = mock.calls.VAdd
	mock.lockVAdd.RUnlock()
	return calls
}

// ResetVAddCalls reset all the calls that were made to VAdd.
func (mock *MoqCmdable) ResetVAddCalls() {
	mock.lockVAdd.Lock()
	mock.calls.VAdd = nil
	mock.lockVAdd.Unlock()
}

// VAddWithArgs calls VAddWithArgsFunc.
func (mock *MoqCmdable) VAddWithArgs(ctx context.Context, key string, element string, val redis.Vector, addArgs *redis.VAddArgs) *redis.BoolCmd {
	if mock.VAddWithArgsFunc == nil {
		panic("MoqCmdable.VAddWithArgsFunc: method is nil but Cmdable.VAddWithArgs was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Key     string
		Element string
		Val     redis.Vector
		AddArgs *redis.VAddArgs
	}{
		Ctx:     ctx,
		Key:     key,
		Element: element,
		Val:     val,
		AddArgs: addArgs,
	}
	mock.lockVAddWithArgs.Lock()
	mock.calls.VAddWithArgs = append(mock.calls.VAddWithArgs, callInfo)
	mock.lockVAddWithArgs.Unlock()
	return mock.VAddWithArgsFunc(ctx, key, element, val, addArgs)
}

// VAddWithArgsCalls gets all the calls that were made to VAddWithArgs.
// Check the length with:
//
//	len(mockedCmdable.VAddWithArgsCalls())
func (mock *MoqCmdable) VAddWithArgsCalls() []struct {
	Ctx     context.Context
	Key     string
	Element string
	Val     redis.Vector
	AddArgs *redis.VAddArgs
} {
	var calls []struct {
		Ctx     context.Context
		Key     string
		Element string
		Val     redis.Vector
		AddArgs *redis.VAddArgs
	}
	mock.lockVAddWithArgs.RLock()
	calls = mock.calls.VAddWithArgs
	mock.lockVAddWithArgs.RUnlock()
	return calls
}

// ResetVAddWithArgsCalls reset all the calls that were made to VAddWithArgs.
func (mock *MoqCmdable) ResetVAddWithArgsCalls() {
	mock.lockVAddWithArgs.Lock()
	mock.calls.VAddWithArgs = nil
	mock.lockVAddWithArgs.Unlock()
}

// VCard calls VCardFunc.
func (mock *MoqCmdable) VCard(ctx context.Context, key string) *redis.IntCmd {
	if mock.VCardFunc == nil {
		panic("MoqCmdable.VCardFunc: method is nil but Cmdable.VCard was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockVCard.Lock()
	mock.calls.VCard = append(mock.calls.VCard, callInfo)
	mock.lockVCard.Unlock()
	return mock.VCardFunc(ctx, key)
}

// VCardCalls gets all the calls that were made to VCard.
// Check the length with:
//
//	len(mockedCmdable.VCardCalls())
func (mock *MoqCmdable) VCardCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockVCard.RLock()
	calls = mock.calls.VCard
	mock.lockVCard.RUnlock()
	return calls
}

// ResetVCardCalls reset all the calls that were made to VCard.
func (mock *MoqCmdable) ResetVCardCalls() {
	mock.lockVCard.Lock()
	mock.calls.VCard = nil
	mock.lockVCard.Unlock()
}

// VClearAttributes calls VClearAttributesFunc.
func (mock *MoqCmdable) VClearAttributes(ctx context.Context, key string, element string) *redis.BoolCmd {
	if mock.VClearAttributesFunc == nil {
		panic("MoqCmdable.VClearAttributesFunc: method is nil but Cmdable.VClearAttributes was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Key     string
		Element string
	}{
		Ctx:     ctx,
		Key:     key,
		Element: element,
	}
	mock.lockVClearAttributes.Lock()
	mock.calls.VClearAttributes = append(mock.calls.VClearAttributes, callInfo)
	mock.lockVClearAttributes.Unlock()
	return mock.VClearAttributesFunc(ctx, key, element)
}

// VClearAttributesCalls gets all the calls that were made to VClearAttributes.
// Check the length with:
//
//	len(mockedCmdable.VClearAttributesCalls())
func (mock *MoqCmdable) VClearAttributesCalls() []struct {
	Ctx     context.Context
	Key     string
	Element string
} {
	var calls []struct {
		Ctx     context.Context
		Key     string
		Element string
	}
	mock.lockVClearAttributes.RLock()
	calls = mock.calls.VClearAttributes
	mock.lockVClearAttributes.RUnlock()
	return calls
}

// ResetVClearAttributesCalls reset all the calls that were made to VClearAttributes.
func (mock *MoqCmdable) ResetVClearAttributesCalls() {
	mock.lockVClearAttributes.Lock()
	mock.calls.VClearAttributes = nil
	mock.lockVClearAttributes.Unlock()
}

// VDim calls VDimFunc.
func (mock *MoqCmdable) VDim(ctx context.Context, key string) *redis.IntCmd {
	if mock.VDimFunc == nil {
		panic("MoqCmdable.VDimFunc: method is nil but Cmdable.VDim was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockVDim.Lock()
	mock.calls.VDim = append(mock.calls.VDim, callInfo)
	mock.lockVDim.Unlock()
	return mock.VDimFunc(ctx, key)
}

// VDimCalls gets all the calls that were made to VDim.
// Check the length with:
//
//	len(mockedCmdable.VDimCalls())
func (mock *MoqCmdable) VDimCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockVDim.RLock()
	calls = mock.calls.VDim
	mock.lockVDim.RUnlock()
	return calls
}

// ResetVDimCalls reset all the calls that were made to VDim.
func (mock *MoqCmdable) ResetVDimCalls() {
	mock.lockVDim.Lock()
	mock.calls.VDim = nil
	mock.lockVDim.Unlock()
}

// VEmb calls VEmbFunc.
func (mock *MoqCmdable) VEmb(ctx context.Context, key string, element string, raw bool) *redis.SliceCmd {
	if mock.VEmbFunc == nil {
		panic("MoqCmdable.VEmbFunc: method is nil but Cmdable.VEmb was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Key     string
		Element string
		Raw     bool
	}{
		Ctx:     ctx,
		Key:     key,
		Element: element,
		Raw:     raw,
	}
	mock.lockVEmb.Lock()
	mock.calls.VEmb = append(mock.calls.VEmb, callInfo)
	mock.lockVEmb.Unlock()
	return mock.VEmbFunc(ctx, key, element, raw)
}

// VEmbCalls gets all the calls that were made to VEmb.
// Check the length with:
//
//	len(mockedCmdable.VEmbCalls())
func (mock *MoqCmdable) VEmbCalls() []struct {
	Ctx     context.Context
	Key     string
	Element string
	Raw     bool
} {
	var calls []struct {
		Ctx     context.Context
		Key     string
		Element string
		Raw     bool
	}
	mock.lockVEmb.RLock()
	calls = mock.calls.VEmb
	mock.lockVEmb.RUnlock()
	return calls
}

// ResetVEmbCalls reset all the calls that were made to VEmb.
func (mock *MoqCmdable) ResetVEmbCalls() {
	mock.lockVEmb.Lock()
	mock.calls.VEmb = nil
	mock.lockVEmb.Unlock()
}

// VGetAttr calls VGetAttrFunc.
func (mock *MoqCmdable) VGetAttr(ctx context.Context, key string, element string) *redis.StringCmd {
	if mock.VGetAttrFunc == nil {
		panic("MoqCmdable.VGetAttrFunc: method is nil but Cmdable.VGetAttr was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Key     string
		Element string
	}{
		Ctx:     ctx,
		Key:     key,
		Element: element,
	}
	mock.lockVGetAttr.Lock()
	mock.calls.VGetAttr = append(mock.calls.VGetAttr, callInfo)
	mock.lockVGetAttr.Unlock()
	return mock.VGetAttrFunc(ctx, key, element)
}

// VGetAttrCalls gets all the calls that were made to VGetAttr.
// Check the length with:
//
//	len(mockedCmdable.VGetAttrCalls())
func (mock *MoqCmdable) VGetAttrCalls() []struct {
	Ctx     context.Context
	Key     string
	Element string
} {
	var calls []struct {
		Ctx     context.Context
		Key     string
		Element string
	}
	mock.lockVGetAttr.RLock()
	calls = mock.calls.VGetAttr
	mock.lockVGetAttr.RUnlock()
	return calls
}

// ResetVGetAttrCalls reset all the calls that were made to VGetAttr.
func (mock *MoqCmdable) ResetVGetAttrCalls() {
	mock.lockVGetAttr.Lock()
	mock.calls.VGetAttr = nil
	mock.lockVGetAttr.Unlock()
}

// VInfo calls VInfoFunc.
func (mock *MoqCmdable) VInfo(ctx context.Context, key string) *redis.MapStringInterfaceCmd {
	if mock.VInfoFunc == nil {
		panic("MoqCmdable.VInfoFunc: method is nil but Cmdable.VInfo was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockVInfo.Lock()
	mock.calls.VInfo = append(mock.calls.VInfo, callInfo)
	mock.lockVInfo.Unlock()
	return mock.VInfoFunc(ctx, key)
}

// VInfoCalls gets all the calls that were made to VInfo.
// Check the length with:
//
//	len(mockedCmdable.VInfoCalls())
func (mock *MoqCmdable) VInfoCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockVInfo.RLock()
	calls = mock.calls.VInfo
	mock.lockVInfo.RUnlock()
	return calls
}

// ResetVInfoCalls reset all the calls that were made to VInfo.
func (mock *MoqCmdable) ResetVInfoCalls() {
	mock.lockVInfo.Lock()
	mock.calls.VInfo = nil
	mock.lockVInfo.Unlock()
}

// VLinks calls VLinksFunc.
func (mock *MoqCmdable) VLinks(ctx context.Context, key string, element string) *redis.StringSliceCmd {
	if mock.VLinksFunc == nil {
		panic("MoqCmdable.VLinksFunc: method is nil but Cmdable.VLinks was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Key     string
		Element string
	}{
		Ctx:     ctx,
		Key:     key,
		Element: element,
	}
	mock.lockVLinks.Lock()
	mock.calls.VLinks = append(mock.calls.VLinks, callInfo)
	mock.lockVLinks.Unlock()
	return mock.VLinksFunc(ctx, key, element)
}

// VLinksCalls gets all the calls that were made to VLinks.
// Check the length with:
//
//	len(mockedCmdable.VLinksCalls())
func (mock *MoqCmdable) VLinksCalls() []struct {
	Ctx     context.Context
	Key     string
	Element string
} {
	var calls []struct {
		Ctx     context.Context
		Key     string
		Element string
	}
	mock.lockVLinks.RLock()
	calls = mock.calls.VLinks
	mock.lockVLinks.RUnlock()
	return calls
}

// ResetVLinksCalls reset all the calls that were made to VLinks.
func (mock *MoqCmdable) ResetVLinksCalls() {
	mock.lockVLinks.Lock()
	mock.calls.VLinks = nil
	mock.lockVLinks.Unlock()
}

// VLinksWithScores calls VLinksWithScoresFunc.
func (mock *MoqCmdable) VLinksWithScores(ctx context.Context, key string, element string) *redis.VectorScoreSliceCmd {
	if mock.VLinksWithScoresFunc == nil {
		panic("MoqCmdable.VLinksWithScoresFunc: method is nil but Cmdable.VLinksWithScores was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Key     string
		Element string
	}{
		Ctx:     ctx,
		Key:     key,
		Element: element,
	}
	mock.lockVLinksWithScores.Lock()
	mock.calls.VLinksWithScores = append(mock.calls.VLinksWithScores, callInfo)
	mock.lockVLinksWithScores.Unlock()
	return mock.VLinksWithScoresFunc(ctx, key, element)
}

// VLinksWithScoresCalls gets all the calls that were made to VLinksWithScores.
// Check the length with:
//
//	len(mockedCmdable.VLinksWithScoresCalls())
func (mock *MoqCmdable) VLinksWithScoresCalls() []struct {
	Ctx     context.Context
	Key     string
	Element string
} {
	var calls []struct {
		Ctx     context.Context
		Key     string
		Element string
	}
	mock.lockVLinksWithScores.RLock()
	calls = mock.calls.VLinksWithScores
	mock.lockVLinksWithScores.RUnlock()
	return calls
}

// ResetVLinksWithScoresCalls reset all the calls that were made to VLinksWithScores.
func (mock *MoqCmdable) ResetVLinksWithScoresCalls() {
	mock.lockVLinksWithScores.Lock()
	mock.calls.VLinksWithScores = nil
	mock.lockVLinksWithScores.Unlock()
}

// VRandMember calls VRandMemberFunc.
func (mock *MoqCmdable) VRandMember(ctx context.Context, key string) *redis.StringCmd {
	if mock.VRandMemberFunc == nil {
		panic("MoqCmdable.VRandMemberFunc: method is nil but Cmdable.VRandMember was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockVRandMember.Lock()
	mock.calls.VRandMember = append(mock.calls.VRandMember, callInfo)
	mock.lockVRandMember.Unlock()
	return mock.VRandMemberFunc(ctx, key)
}

// VRandMemberCalls gets all the calls that were made to VRandMember.
// Check the length with:
//
//	len(mockedCmdable.VRandMemberCalls())
func (mock *MoqCmdable) VRandMemberCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockVRandMember.RLock()
	calls = mock.calls.VRandMember
	mock.lockVRandMember.RUnlock()
	return calls
}

// ResetVRandMemberCalls reset all the calls that were made to VRandMember.
func (mock *MoqCmdable) ResetVRandMemberCalls() {
	mock.lockVRandMember.Lock()
	mock.calls.VRandMember = nil
	mock.lockVRandMember.Unlock()
}

// VRandMemberCount calls VRandMemberCountFunc.
func (mock *MoqCmdable) VRandMemberCount(ctx context.Context, key string, count int) *redis.StringSliceCmd {
	if mock.VRandMemberCountFunc == nil {
		panic("MoqCmdable.VRandMemberCountFunc: method is nil but Cmdable.VRandMemberCount was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Count int
	}{
		Ctx:   ctx,
		Key:   key,
		Count: count,
	}
	mock.lockVRandMemberCount.Lock()
	mock.calls.VRandMemberCount = append(mock.calls.VRandMemberCount, callInfo)
	mock.lockVRandMemberCount.Unlock()
	return mock.VRandMemberCountFunc(ctx, key, count)
}

// VRandMemberCountCalls gets all the calls that were made to VRandMemberCount.
// Check the length with:
//
//	len(mockedCmdable.VRandMemberCountCalls())
func (mock *MoqCmdable) VRandMemberCountCalls() []struct {
	Ctx   context.Context
	Key   string
	Count int
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Count int
	}
	mock.lockVRandMemberCount.RLock()
	calls = mock.calls.VRandMemberCount
	mock.lockVRandMemberCount.RUnlock()
	return calls
}

// ResetVRandMemberCountCalls reset all the calls that were made to VRandMemberCount.
func (mock *MoqCmdable) ResetVRandMemberCountCalls() {
	mock.lockVRandMemberCount.Lock()
	mock.calls.VRandMemberCount = nil
	mock.lockVRandMemberCount.Unlock()
}

// VRange calls VRangeFunc.
func (mock *MoqCmdable) VRange(ctx context.Context, key string, start string, end string, count int64) *redis.StringSliceCmd {
	if mock.VRangeFunc == nil {
		panic("MoqCmdable.VRangeFunc: method is nil but Cmdable.VRange was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Start string
		End   string
		Count int64
	}{
		Ctx:   ctx,
		Key:   key,
		Start: start,
		End:   end,
		Count: count,
	}
	mock.lockVRange.Lock()
	mock.calls.VRange = append(mock.calls.VRange, callInfo)
	mock.lockVRange.Unlock()
	return mock.VRangeFunc(ctx, key, start, end, count)
}

// VRangeCalls gets all the calls that were made to VRange.
// Check the length with:
//
//	len(mockedCmdable.VRangeCalls())
func (mock *MoqCmdable) VRangeCalls() []struct {
	Ctx   context.Context
	Key   string
	Start string
	End   string
	Count int64
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Start string
		End   string
		Count int64
	}
	mock.lockVRange.RLock()
	calls = mock.calls.VRange
	mock.lockVRange.RUnlock()
	return calls
}

// ResetVRangeCalls reset all the calls that were made to VRange.
func (mock *MoqCmdable) ResetVRangeCalls() {
	mock.lockVRange.Lock()
	mock.calls.VRange = nil
	mock.lockVRange.Unlock()
}

// VRem calls VRemFunc.
func (mock *MoqCmdable) VRem(ctx context.Context, key string, element string) *redis.BoolCmd {
	if mock.VRemFunc == nil {
		panic("MoqCmdable.VRemFunc: method is nil but Cmdable.VRem was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Key     string
		Element string
	}{
		Ctx:     ctx,
		Key:     key,
		Element: element,
	}
	mock.lockVRem.Lock()
	mock.calls.VRem = append(mock.calls.VRem, callInfo)
	mock.lockVRem.Unlock()
	return mock.VRemFunc(ctx, key, element)
}

// VRemCalls gets all the calls that were made to VRem.
// Check the length with:
//
//	len(mockedCmdable.VRemCalls())
func (mock *MoqCmdable) VRemCalls() []struct {
	Ctx     context.Context
	Key     string
	Element string
} {
	var calls []struct {
		Ctx     context.Context
		Key     string
		Element string
	}
	mock.lockVRem.RLock()
	calls = mock.calls.VRem
	mock.lockVRem.RUnlock()
	return calls
}

// ResetVRemCalls reset all the calls that were made to VRem.
func (mock *MoqCmdable) ResetVRemCalls() {
	mock.lockVRem.Lock()
	mock.calls.VRem = nil
	mock.lockVRem.Unlock()
}

// VSetAttr calls VSetAttrFunc.
func (mock *MoqCmdable) VSetAttr(ctx context.Context, key string, element string, attr interface{}) *redis.BoolCmd {
	if mock.VSetAttrFunc == nil {
		panic("MoqCmdable.VSetAttrFunc: method is nil but Cmdable.VSetAttr was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Key     string
		Element string
		Attr    interface{}
	}{
		Ctx:     ctx,
		Key:     key,
		Element: element,
		Attr:    attr,
	}
	mock.lockVSetAttr.Lock()
	mock.calls.VSetAttr = append(mock.calls.VSetAttr, callInfo)
	mock.lockVSetAttr.Unlock()
	return mock.VSetAttrFunc(ctx, key, element, attr)
}

// VSetAttrCalls gets all the calls that were made to VSetAttr.
// Check the length with:
//
//	len(mockedCmdable.VSetAttrCalls())
func (mock *MoqCmdable) VSetAttrCalls() []struct {
	Ctx     context.Context
	Key     string
	Element string
	Attr    interface{}
} {
	var calls []struct {
		Ctx     context.Context
		Key     string
		Element string
		Attr    interface{}
	}
	mock.lockVSetAttr.RLock()
	calls = mock.calls.VSetAttr
	mock.lockVSetAttr.RUnlock()
	return calls
}

// ResetVSetAttrCalls reset all the calls that were made to VSetAttr.
func (mock *MoqCmdable) ResetVSetAttrCalls() {
	mock.lockVSetAttr.Lock()
	mock.calls.VSetAttr = nil
	mock.lockVSetAttr.Unlock()
}

// VSim calls VSimFunc.
func (mock *MoqCmdable) VSim(ctx context.Context, key string, val redis.Vector) *redis.StringSliceCmd {
	if mock.VSimFunc == nil {
		panic("MoqCmdable.VSimFunc: method is nil but Cmdable.VSim was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
		Val redis.Vector
	}{
		Ctx: ctx,
		Key: key,
		Val: val,
	}
	mock.lockVSim.Lock()
	mock.calls.VSim = append(mock.calls.VSim, callInfo)
	mock.lockVSim.Unlock()
	return mock.VSimFunc(ctx, key, val)
}

// VSimCalls gets all the calls that were made to VSim.
// Check the length with:
//
//	len(mockedCmdable.VSimCalls())
func (mock *MoqCmdable) VSimCalls() []struct {
	Ctx context.Context
	Key string
	Val redis.Vector
} {
	var calls []struct {
		Ctx context.Context
		Key string
		Val redis.Vector
	}
	mock.lockVSim.RLock()
	calls = mock.calls.VSim
	mock.lockVSim.RUnlock()
	return calls
}

// ResetVSimCalls reset all the calls that were made to VSim.
func (mock *MoqCmdable) ResetVSimCalls() {
	mock.lockVSim.Lock()
	mock.calls.VSim = nil
	mock.lockVSim.Unlock()
}

// VSimWithArgs calls VSimWithArgsFunc.
func (mock *MoqCmdable) VSimWithArgs(ctx context.Context, key string, val redis.Vector, args *redis.VSimArgs) *redis.StringSliceCmd {
	if mock.VSimWithArgsFunc == nil {
		panic("MoqCmdable.VSimWithArgsFunc: method is nil but Cmdable.VSimWithArgs was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Key  string
		Val  redis.Vector
		Args *redis.VSimArgs
	}{
		Ctx:  ctx,
		Key:  key,
		Val:  val,
		Args: args,
	}
	mock.lockVSimWithArgs.Lock()
	mock.calls.VSimWithArgs = append(mock.calls.VSimWithArgs, callInfo)
	mock.lockVSimWithArgs.Unlock()
	return mock.VSimWithArgsFunc(ctx, key, val, args)
}

// VSimWithArgsCalls gets all the calls that were made to VSimWithArgs.
// Check the length with:
//
//	len(mockedCmdable.VSimWithArgsCalls())
func (mock *MoqCmdable) VSimWithArgsCalls() []struct {
	Ctx  context.Context
	Key  string
	Val  redis.Vector
	Args *redis.VSimArgs
} {
	var calls []struct {
		Ctx  context.Context
		Key  string
		Val  redis.Vector
		Args *redis.VSimArgs
	}
	mock.lockVSimWithArgs.RLock()
	calls = mock.calls.VSimWithArgs
	mock.lockVSimWithArgs.RUnlock()
	return calls
}

// ResetVSimWithArgsCalls reset all the calls that were made to VSimWithArgs.
func (mock *MoqCmdable) ResetVSimWithArgsCalls() {
	mock.lockVSimWithArgs.Lock()
	mock.calls.VSimWithArgs = nil
	mock.lockVSimWithArgs.Unlock()
}

// VSimWithArgsWithScores calls VSimWithArgsWithScoresFunc.
func (mock *MoqCmdable) VSimWithArgsWithScores(ctx context.Context, key string, val redis.Vector, args *redis.VSimArgs) *redis.VectorScoreSliceCmd {
	if mock.VSimWithArgsWithScoresFunc == nil {
		panic("MoqCmdable.VSimWithArgsWithScoresFunc: method is nil but Cmdable.VSimWithArgsWithScores was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Key  string
		Val  redis.Vector
		Args *redis.VSimArgs
	}{
		Ctx:  ctx,
		Key:  key,
		Val:  val,
		Args: args,
	}
	mock.lockVSimWithArgsWithScores.Lock()
	mock.calls.VSimWithArgsWithScores = append(mock.calls.VSimWithArgsWithScores, callInfo)
	mock.lockVSimWithArgsWithScores.Unlock()
	return mock.VSimWithArgsWithScoresFunc(ctx, key, val, args)
}

// VSimWithArgsWithScoresCalls gets all the calls that were made to VSimWithArgsWithScores.
// Check the length with:
//
//	len(mockedCmdable.VSimWithArgsWithScoresCalls())
func (mock *MoqCmdable) VSimWithArgsWithScoresCalls() []struct {
	Ctx  context.Context
	Key  string
	Val  redis.Vector
	Args *redis.VSimArgs
} {
	var calls []struct {
		Ctx  context.Context
		Key  string
		Val  redis.Vector
		Args *redis.VSimArgs
	}
	mock.lockVSimWithArgsWithScores.RLock()
	calls = mock.calls.VSimWithArgsWithScores
	mock.lockVSimWithArgsWithScores.RUnlock()
	return calls
}

// ResetVSimWithArgsWithScoresCalls reset all the calls that were made to VSimWithArgsWithScores.
func (mock *MoqCmdable) ResetVSimWithArgsWithScoresCalls() {
	mock.lockVSimWithArgsWithScores.Lock()
	mock.calls.VSimWithArgsWithScores = nil
	mock.lockVSimWithArgsWithScores.Unlock()
}

// VSimWithScores calls VSimWithScoresFunc.
func (mock *MoqCmdable) VSimWithScores(ctx context.Context, key string, val redis.Vector) *redis.VectorScoreSliceCmd {
	if mock.VSimWithScoresFunc == nil {
		panic("MoqCmdable.VSimWithScoresFunc: method is nil but Cmdable.VSimWithScores was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
		Val redis.Vector
	}{
		Ctx: ctx,
		Key: key,
		Val: val,
	}
	mock.lockVSimWithScores.Lock()
	mock.calls.VSimWithScores = append(mock.calls.VSimWithScores, callInfo)
	mock.lockVSimWithScores.Unlock()
	return mock.VSimWithScoresFunc(ctx, key, val)
}

// VSimWithScoresCalls gets all the calls that were made to VSimWithScores.
// Check the length with:
//
//	len(mockedCmdable.VSimWithScoresCalls())
func (mock *MoqCmdable) VSimWithScoresCalls() []struct {
	Ctx context.Context
	Key string
	Val redis.Vector
} {
	var calls []struct {
		Ctx context.Context
		Key string
		Val redis.Vector
	}
	mock.lockVSimWithScores.RLock()
	calls = mock.calls.VSimWithScores
	mock.lockVSimWithScores.RUnlock()
	return calls
}

// ResetVSimWithScoresCalls reset all the calls that were made to VSimWithScores.
func (mock *MoqCmdable) ResetVSimWithScoresCalls() {
	mock.lockVSimWithScores.Lock()
	mock.calls.VSimWithScores = nil
	mock.lockVSimWithScores.Unlock()
}

// XAck calls XAckFunc.
func (mock *MoqCmdable) XAck(ctx context.Context, stream string, group string, ids ...string) *redis.IntCmd {
	if mock.XAckFunc == nil {
		panic("MoqCmdable.XAckFunc: method is nil but Cmdable.XAck was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Stream string
		Group  string
		Ids    []string
	}{
		Ctx:    ctx,
		Stream: stream,
		Group:  group,
		Ids:    ids,
	}
	mock.lockXAck.Lock()
	mock.calls.XAck = append(mock.calls.XAck, callInfo)
	mock.lockXAck.Unlock()
	return mock.XAckFunc(ctx, stream, group, ids...)
}

// XAckCalls gets all the calls that were made to XAck.
// Check the length with:
//
//	len(mockedCmdable.XAckCalls())
func (mock *MoqCmdable) XAckCalls() []struct {
	Ctx    context.Context
	Stream string
	Group  string
	Ids    []string
} {
	var calls []struct {
		Ctx    context.Context
		Stream string
		Group  string
		Ids    []string
	}
	mock.lockXAck.RLock()
	calls = mock.calls.XAck
	mock.lockXAck.RUnlock()
	return calls
}

// ResetXAckCalls reset all the calls that were made to XAck.
func (mock *MoqCmdable) ResetXAckCalls() {
	mock.lockXAck.Lock()
	mock.calls.XAck = nil
	mock.lockXAck.Unlock()
}

// XAckDel calls XAckDelFunc.
func (mock *MoqCmdable) XAckDel(ctx context.Context, stream string, group string, mode string, ids ...string) *redis.SliceCmd {
	if mock.XAckDelFunc == nil {
		panic("MoqCmdable.XAckDelFunc: method is nil but Cmdable.XAckDel was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Stream string
		Group  string
		Mode   string
		Ids    []string
	}{
		Ctx:    ctx,
		Stream: stream,
		Group:  group,
		Mode:   mode,
		Ids:    ids,
	}
	mock.lockXAckDel.Lock()
	mock.calls.XAckDel = append(mock.calls.XAckDel, callInfo)
	mock.lockXAckDel.Unlock()
	return mock.XAckDelFunc(ctx, stream, group, mode, ids...)
}

// XAckDelCalls gets all the calls that were made to XAckDel.
// Check the length with:
//
//	len(mockedCmdable.XAckDelCalls())
func (mock *MoqCmdable) XAckDelCalls() []struct {
	Ctx    context.Context
	Stream string
	Group  string
	Mode   string
	Ids    []string
} {
	var calls []struct {
		Ctx    context.Context
		Stream string
		Group  string
		Mode   string
		Ids    []string
	}
	mock.lockXAckDel.RLock()
	calls = mock.calls.XAckDel
	mock.lockXAckDel.RUnlock()
	return calls
}

// ResetXAckDelCalls reset all the calls that were made to XAckDel.
func (mock *MoqCmdable) ResetXAckDelCalls() {
	mock.lockXAckDel.Lock()
	mock.calls.XAckDel = nil
	mock.lockXAckDel.Unlock()
}

// XAdd calls XAddFunc.
func (mock *MoqCmdable) XAdd(ctx context.Context, a *redis.XAddArgs) *redis.StringCmd {
	if mock.XAddFunc == nil {
		panic("MoqCmdable.XAddFunc: method is nil but Cmdable.XAdd was just called")
	}
	callInfo := struct {
		Ctx context.Context
		A   *redis.XAddArgs
	}{
		Ctx: ctx,
		A:   a,
	}
	mock.lockXAdd.Lock()
	mock.calls.XAdd = append(mock.calls.XAdd, callInfo)
	mock.lockXAdd.Unlock()
	return mock.XAddFunc(ctx, a)
}

// XAddCalls gets all the calls that were made to XAdd.
// Check the length with:
//
//	len(mockedCmdable.XAddCalls())
func (mock *MoqCmdable) XAddCalls() []struct {
	Ctx context.Context
	A   *redis.XAddArgs
} {
	var calls []struct {
		Ctx context.Context
		A   *redis.XAddArgs
	}
	mock.lockXAdd.RLock()
	calls = mock.calls.XAdd
	mock.lockXAdd.RUnlock()
	return calls
}

// ResetXAddCalls reset all the calls that were made to XAdd.
func (mock *MoqCmdable) ResetXAddCalls() {
	mock.lockXAdd.Lock()
	mock.calls.XAdd = nil
	mock.lockXAdd.Unlock()
}

// XAutoClaim calls XAutoClaimFunc.
func (mock *MoqCmdable) XAutoClaim(ctx context.Context, a *redis.XAutoClaimArgs) *redis.XAutoClaimCmd {
	if mock.XAutoClaimFunc == nil {
		panic("MoqCmdable.XAutoClaimFunc: method is nil but Cmdable.XAutoClaim was just called")
	}
	callInfo := struct {
		Ctx context.Context
		A   *redis.XAutoClaimArgs
	}{
		Ctx: ctx,
		A:   a,
	}
	mock.lockXAutoClaim.Lock()
	mock.calls.XAutoClaim = append(mock.calls.XAutoClaim, callInfo)
	mock.lockXAutoClaim.Unlock()
	return mock.XAutoClaimFunc(ctx, a)
}

// XAutoClaimCalls gets all the calls that were made to XAutoClaim.
// Check the length with:
//
//	len(mockedCmdable.XAutoClaimCalls())
func (mock *MoqCmdable) XAutoClaimCalls() []struct {
	Ctx context.Context
	A   *redis.XAutoClaimArgs
} {
	var calls []struct {
		Ctx context.Context
		A   *redis.XAutoClaimArgs
	}
	mock.lockXAutoClaim.RLock()
	calls = mock.calls.XAutoClaim
	mock.lockXAutoClaim.RUnlock()
	return calls
}

// ResetXAutoClaimCalls reset all the calls that were made to XAutoClaim.
func (mock *MoqCmdable) ResetXAutoClaimCalls() {
	mock.lockXAutoClaim.Lock()
	mock.calls.XAutoClaim = nil
	mock.lockXAutoClaim.Unlock()
}

// XAutoClaimJustID calls XAutoClaimJustIDFunc.
func (mock *MoqCmdable) XAutoClaimJustID(ctx context.Context, a *redis.XAutoClaimArgs) *redis.XAutoClaimJustIDCmd {
	if mock.XAutoClaimJustIDFunc == nil {
		panic("MoqCmdable.XAutoClaimJustIDFunc: method is nil but Cmdable.XAutoClaimJustID was just called")
	}
	callInfo := struct {
		Ctx context.Context
		A   *redis.XAutoClaimArgs
	}{
		Ctx: ctx,
		A:   a,
	}
	mock.lockXAutoClaimJustID.Lock()
	mock.calls.XAutoClaimJustID = append(mock.calls.XAutoClaimJustID, callInfo)
	mock.lockXAutoClaimJustID.Unlock()
	return mock.XAutoClaimJustIDFunc(ctx, a)
}

// XAutoClaimJustIDCalls gets all the calls that were made to XAutoClaimJustID.
// Check the length with:
//
//	len(mockedCmdable.XAutoClaimJustIDCalls())
func (mock *MoqCmdable) XAutoClaimJustIDCalls() []struct {
	Ctx context.Context
	A   *redis.XAutoClaimArgs
} {
	var calls []struct {
		Ctx context.Context
		A   *redis.XAutoClaimArgs
	}
	mock.lockXAutoClaimJustID.RLock()
	calls = mock.calls.XAutoClaimJustID
	mock.lockXAutoClaimJustID.RUnlock()
	return calls
}

// ResetXAutoClaimJustIDCalls reset all the calls that were made to XAutoClaimJustID.
func (mock *MoqCmdable) ResetXAutoClaimJustIDCalls() {
	mock.lockXAutoClaimJustID.Lock()
	mock.calls.XAutoClaimJustID = nil
	mock.lockXAutoClaimJustID.Unlock()
}

// XCfgSet calls XCfgSetFunc.
func (mock *MoqCmdable) XCfgSet(ctx context.Context, a *redis.XCfgSetArgs) *redis.StatusCmd {
	if mock.XCfgSetFunc == nil {
		panic("MoqCmdable.XCfgSetFunc: method is nil but Cmdable.XCfgSet was just called")
	}
	callInfo := struct {
		Ctx context.Context
		A   *redis.XCfgSetArgs
	}{
		Ctx: ctx,
		A:   a,
	}
	mock.lockXCfgSet.Lock()
	mock.calls.XCfgSet = append(mock.calls.XCfgSet, callInfo)
	mock.lockXCfgSet.Unlock()
	return mock.XCfgSetFunc(ctx, a)
}

// XCfgSetCalls gets all the calls that were made to XCfgSet.
// Check the length with:
//
//	len(mockedCmdable.XCfgSetCalls())
func (mock *MoqCmdable) XCfgSetCalls() []struct {
	Ctx context.Context
	A   *redis.XCfgSetArgs
} {
	var calls []struct {
		Ctx context.Context
		A   *redis.XCfgSetArgs
	}
	mock.lockXCfgSet.RLock()
	calls = mock.calls.XCfgSet
	mock.lockXCfgSet.RUnlock()
	return calls
}

// ResetXCfgSetCalls reset all the calls that were made to XCfgSet.
func (mock *MoqCmdable) ResetXCfgSetCalls() {
	mock.lockXCfgSet.Lock()
	mock.calls.XCfgSet = nil
	mock.lockXCfgSet.Unlock()
}

// XClaim calls XClaimFunc.
func (mock *MoqCmdable) XClaim(ctx context.Context, a *redis.XClaimArgs) *redis.XMessageSliceCmd {
	if mock.XClaimFunc == nil {
		panic("MoqCmdable.XClaimFunc: method is nil but Cmdable.XClaim was just called")
	}
	callInfo := struct {
		Ctx context.Context
		A   *redis.XClaimArgs
	}{
		Ctx: ctx,
		A:   a,
	}
	mock.lockXClaim.Lock()
	mock.calls.XClaim = append(mock.calls.XClaim, callInfo)
	mock.lockXClaim.Unlock()
	return mock.XClaimFunc(ctx, a)
}

// XClaimCalls gets all the calls that were made to XClaim.
// Check the length with:
//
//	len(mockedCmdable.XClaimCalls())
func (mock *MoqCmdable) XClaimCalls() []struct {
	Ctx context.Context
	A   *redis.XClaimArgs
} {
	var calls []struct {
		Ctx context.Context
		A   *redis.XClaimArgs
	}
	mock.lockXClaim.RLock()
	calls = mock.calls.XClaim
	mock.lockXClaim.RUnlock()
	return calls
}

// ResetXClaimCalls reset all the calls that were made to XClaim.
func (mock *MoqCmdable) ResetXClaimCalls() {
	mock.lockXClaim.Lock()
	mock.calls.XClaim = nil
	mock.lockXClaim.Unlock()
}

// XClaimJustID calls XClaimJustIDFunc.
func (mock *MoqCmdable) XClaimJustID(ctx context.Context, a *redis.XClaimArgs) *redis.StringSliceCmd {
	if mock.XClaimJustIDFunc == nil {
		panic("MoqCmdable.XClaimJustIDFunc: method is nil but Cmdable.XClaimJustID was just called")
	}
	callInfo := struct {
		Ctx context.Context
		A   *redis.XClaimArgs
	}{
		Ctx: ctx,
		A:   a,
	}
	mock.lockXClaimJustID.Lock()
	mock.calls.XClaimJustID = append(mock.calls.XClaimJustID, callInfo)
	mock.lockXClaimJustID.Unlock()
	return mock.XClaimJustIDFunc(ctx, a)
}

// XClaimJustIDCalls gets all the calls that were made to XClaimJustID.
// Check the length with:
//
//	len(mockedCmdable.XClaimJustIDCalls())
func (mock *MoqCmdable) XClaimJustIDCalls() []struct {
	Ctx context.Context
	A   *redis.XClaimArgs
} {
	var calls []struct {
		Ctx context.Context
		A   *redis.XClaimArgs
	}
	mock.lockXClaimJustID.RLock()
	calls = mock.calls.XClaimJustID
	mock.lockXClaimJustID.RUnlock()
	return calls
}

// ResetXClaimJustIDCalls reset all the calls that were made to XClaimJustID.
func (mock *MoqCmdable) ResetXClaimJustIDCalls() {
	mock.lockXClaimJustID.Lock()
	mock.calls.XClaimJustID = nil
	mock.lockXClaimJustID.Unlock()
}

// XDel calls XDelFunc.
func (mock *MoqCmdable) XDel(ctx context.Context, stream string, ids ...string) *redis.IntCmd {
	if mock.XDelFunc == nil {
		panic("MoqCmdable.XDelFunc: method is nil but Cmdable.XDel was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Stream string
		Ids    []string
	}{
		Ctx:    ctx,
		Stream: stream,
		Ids:    ids,
	}
	mock.lockXDel.Lock()
	mock.calls.XDel = append(mock.calls.XDel, callInfo)
	mock.lockXDel.Unlock()
	return mock.XDelFunc(ctx, stream, ids...)
}

// XDelCalls gets all the calls that were made to XDel.
// Check the length with:
//
//	len(mockedCmdable.XDelCalls())
func (mock *MoqCmdable) XDelCalls() []struct {
	Ctx    context.Context
	Stream string
	Ids    []string
} {
	var calls []struct {
		Ctx    context.Context
		Stream string
		Ids    []string
	}
	mock.lockXDel.RLock()
	calls = mock.calls.XDel
	mock.lockXDel.RUnlock()
	return calls
}

// ResetXDelCalls reset all the calls that were made to XDel.
func (mock *MoqCmdable) ResetXDelCalls() {
	mock.lockXDel.Lock()
	mock.calls.XDel = nil
	mock.lockXDel.Unlock()
}

// XDelEx calls XDelExFunc.
func (mock *MoqCmdable) XDelEx(ctx context.Context, stream string, mode string, ids ...string) *redis.SliceCmd {
	if mock.XDelExFunc == nil {
		panic("MoqCmdable.XDelExFunc: method is nil but Cmdable.XDelEx was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Stream string
		Mode   string
		Ids    []string
	}{
		Ctx:    ctx,
		Stream: stream,
		Mode:   mode,
		Ids:    ids,
	}
	mock.lockXDelEx.Lock()
	mock.calls.XDelEx = append(mock.calls.XDelEx, callInfo)
	mock.lockXDelEx.Unlock()
	return mock.XDelExFunc(ctx, stream, mode, ids...)
}

// XDelExCalls gets all the calls that were made to XDelEx.
// Check the length with:
//
//	len(mockedCmdable.XDelExCalls())
func (mock *MoqCmdable) XDelExCalls() []struct {
	Ctx    context.Context
	Stream string
	Mode   string
	Ids    []string
} {
	var calls []struct {
		Ctx    context.Context
		Stream string
		Mode   string
		Ids    []string
	}
	mock.lockXDelEx.RLock()
	calls = mock.calls.XDelEx
	mock.lockXDelEx.RUnlock()
	return calls
}

// ResetXDelExCalls reset all the calls that were made to XDelEx.
func (mock *MoqCmdable) ResetXDelExCalls() {
	mock.lockXDelEx.Lock()
	mock.calls.XDelEx = nil
	mock.lockXDelEx.Unlock()
}

// XGroupCreate calls XGroupCreateFunc.
func (mock *MoqCmdable) XGroupCreate(ctx context.Context, stream string, group string, start string) *redis.StatusCmd {
	if mock.XGroupCreateFunc == nil {
		panic("MoqCmdable.XGroupCreateFunc: method is nil but Cmdable.XGroupCreate was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Stream string
		Group  string
		Start  string
	}{
		Ctx:    ctx,
		Stream: stream,
		Group:  group,
		Start:  start,
	}
	mock.lockXGroupCreate.Lock()
	mock.calls.XGroupCreate = append(mock.calls.XGroupCreate, callInfo)
	mock.lockXGroupCreate.Unlock()
	return mock.XGroupCreateFunc(ctx, stream, group, start)
}

// XGroupCreateCalls gets all the calls that were made to XGroupCreate.
// Check the length with:
//
//	len(mockedCmdable.XGroupCreateCalls())
func (mock *MoqCmdable) XGroupCreateCalls() []struct {
	Ctx    context.Context
	Stream string
	Group  string
	Start  string
} {
	var calls []struct {
		Ctx    context.Context
		Stream string
		Group  string
		Start  string
	}
	mock.lockXGroupCreate.RLock()
	calls = mock.calls.XGroupCreate
	mock.lockXGroupCreate.RUnlock()
	return calls
}

// ResetXGroupCreateCalls reset all the calls that were made to XGroupCreate.
func (mock *MoqCmdable) ResetXGroupCreateCalls() {
	mock.lockXGroupCreate.Lock()
	mock.calls.XGroupCreate = nil
	mock.lockXGroupCreate.Unlock()
}

// XGroupCreateConsumer calls XGroupCreateConsumerFunc.
func (mock *MoqCmdable) XGroupCreateConsumer(ctx context.Context, stream string, group string, consumer string) *redis.IntCmd {
	if mock.XGroupCreateConsumerFunc == nil {
		panic("MoqCmdable.XGroupCreateConsumerFunc: method is nil but Cmdable.XGroupCreateConsumer was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Stream   string
		Group    string
		Consumer string
	}{
		Ctx:      ctx,
		Stream:   stream,
		Group:    group,
		Consumer: consumer,
	}
	mock.lockXGroupCreateConsumer.Lock()
	mock.calls.XGroupCreateConsumer = append(mock.calls.XGroupCreateConsumer, callInfo)
	mock.lockXGroupCreateConsumer.Unlock()
	return mock.XGroupCreateConsumerFunc(ctx, stream, group, consumer)
}

// XGroupCreateConsumerCalls gets all the calls that were made to XGroupCreateConsumer.
// Check the length with:
//
//	len(mockedCmdable.XGroupCreateConsumerCalls())
func (mock *MoqCmdable) XGroupCreateConsumerCalls() []struct {
	Ctx      context.Context
	Stream   string
	Group    string
	Consumer string
} {
	var calls []struct {
		Ctx      context.Context
		Stream   string
		Group    string
		Consumer string
	}
	mock.lockXGroupCreateConsumer.RLock()
	calls = mock.calls.XGroupCreateConsumer
	mock.lockXGroupCreateConsumer.RUnlock()
	return calls
}

// ResetXGroupCreateConsumerCalls reset all the calls that were made to XGroupCreateConsumer.
func (mock *MoqCmdable) ResetXGroupCreateConsumerCalls() {
	mock.lockXGroupCreateConsumer.Lock()
	mock.calls.XGroupCreateConsumer = nil
	mock.lockXGroupCreateConsumer.Unlock()
}

// XGroupCreateMkStream calls XGroupCreateMkStreamFunc.
func (mock *MoqCmdable) XGroupCreateMkStream(ctx context.Context, stream string, group string, start string) *redis.StatusCmd {
	if mock.XGroupCreateMkStreamFunc == nil {
		panic("MoqCmdable.XGroupCreateMkStreamFunc: method is nil but Cmdable.XGroupCreateMkStream was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Stream string
		Group  string
		Start  string
	}{
		Ctx:    ctx,
		Stream: stream,
		Group:  group,
		Start:  start,
	}
	mock.lockXGroupCreateMkStream.Lock()
	mock.calls.XGroupCreateMkStream = append(mock.calls.XGroupCreateMkStream, callInfo)
	mock.lockXGroupCreateMkStream.Unlock()
	return mock.XGroupCreateMkStreamFunc(ctx, stream, group, start)
}

// XGroupCreateMkStreamCalls gets all the calls that were made to XGroupCreateMkStream.
// Check the length with:
//
//	len(mockedCmdable.XGroupCreateMkStreamCalls())
func (mock *MoqCmdable) XGroupCreateMkStreamCalls() []struct {
	Ctx    context.Context
	Stream string
	Group  string
	Start  string
} {
	var calls []struct {
		Ctx    context.Context
		Stream string
		Group  string
		Start  string
	}
	mock.lockXGroupCreateMkStream.RLock()
	calls = mock.calls.XGroupCreateMkStream
	mock.lockXGroupCreateMkStream.RUnlock()
	return calls
}

// ResetXGroupCreateMkStreamCalls reset all the calls that were made to XGroupCreateMkStream.
func (mock *MoqCmdable) ResetXGroupCreateMkStreamCalls() {
	mock.lockXGroupCreateMkStream.Lock()
	mock.calls.XGroupCreateMkStream = nil
	mock.lockXGroupCreateMkStream.Unlock()
}

// XGroupDelConsumer calls XGroupDelConsumerFunc.
func (mock *MoqCmdable) XGroupDelConsumer(ctx context.Context, stream string, group string, consumer string) *redis.IntCmd {
	if mock.XGroupDelConsumerFunc == nil {
		panic("MoqCmdable.XGroupDelConsumerFunc: method is nil but Cmdable.XGroupDelConsumer was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Stream   string
		Group    string
		Consumer string
	}{
		Ctx:      ctx,
		Stream:   stream,
		Group:    group,
		Consumer: consumer,
	}
	mock.lockXGroupDelConsumer.Lock()
	mock.calls.XGroupDelConsumer = append(mock.calls.XGroupDelConsumer, callInfo)
	mock.lockXGroupDelConsumer.Unlock()
	return mock.XGroupDelConsumerFunc(ctx, stream, group, consumer)
}

// XGroupDelConsumerCalls gets all the calls that were made to XGroupDelConsumer.
// Check the length with:
//
//	len(mockedCmdable.XGroupDelConsumerCalls())
func (mock *MoqCmdable) XGroupDelConsumerCalls() []struct {
	Ctx      context.Context
	Stream   string
	Group    string
	Consumer string
} {
	var calls []struct {
		Ctx      context.Context
		Stream   string
		Group    string
		Consumer string
	}
	mock.lockXGroupDelConsumer.RLock()
	calls = mock.calls.XGroupDelConsumer
	mock.lockXGroupDelConsumer.RUnlock()
	return calls
}

// ResetXGroupDelConsumerCalls reset all the calls that were made to XGroupDelConsumer.
func (mock *MoqCmdable) ResetXGroupDelConsumerCalls() {
	mock.lockXGroupDelConsumer.Lock()
	mock.calls.XGroupDelConsumer = nil
	mock.lockXGroupDelConsumer.Unlock()
}

// XGroupDestroy calls XGroupDestroyFunc.
func (mock *MoqCmdable) XGroupDestroy(ctx context.Context, stream string, group string) *redis.IntCmd {
	if mock.XGroupDestroyFunc == nil {
		panic("MoqCmdable.XGroupDestroyFunc: method is nil but Cmdable.XGroupDestroy was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Stream string
		Group  string
	}{
		Ctx:    ctx,
		Stream: stream,
		Group:  group,
	}
	mock.lockXGroupDestroy.Lock()
	mock.calls.XGroupDestroy = append(mock.calls.XGroupDestroy, callInfo)
	mock.lockXGroupDestroy.Unlock()
	return mock.XGroupDestroyFunc(ctx, stream, group)
}

// XGroupDestroyCalls gets all the calls that were made to XGroupDestroy.
// Check the length with:
//
//	len(mockedCmdable.XGroupDestroyCalls())
func (mock *MoqCmdable) XGroupDestroyCalls() []struct {
	Ctx    context.Context
	Stream string
	Group  string
} {
	var calls []struct {
		Ctx    context.Context
		Stream string
		Group  string
	}
	mock.lockXGroupDestroy.RLock()
	calls = mock.calls.XGroupDestroy
	mock.lockXGroupDestroy.RUnlock()
	return calls
}

// ResetXGroupDestroyCalls reset all the calls that were made to XGroupDestroy.
func (mock *MoqCmdable) ResetXGroupDestroyCalls() {
	mock.lockXGroupDestroy.Lock()
	mock.calls.XGroupDestroy = nil
	mock.lockXGroupDestroy.Unlock()
}

// XGroupSetID calls XGroupSetIDFunc.
func (mock *MoqCmdable) XGroupSetID(ctx context.Context, stream string, group string, start string) *redis.StatusCmd {
	if mock.XGroupSetIDFunc == nil {
		panic("MoqCmdable.XGroupSetIDFunc: method is nil but Cmdable.XGroupSetID was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Stream string
		Group  string
		Start  string
	}{
		Ctx:    ctx,
		Stream: stream,
		Group:  group,
		Start:  start,
	}
	mock.lockXGroupSetID.Lock()
	mock.calls.XGroupSetID = append(mock.calls.XGroupSetID, callInfo)
	mock.lockXGroupSetID.Unlock()
	return mock.XGroupSetIDFunc(ctx, stream, group, start)
}

// XGroupSetIDCalls gets all the calls that were made to XGroupSetID.
// Check the length with:
//
//	len(mockedCmdable.XGroupSetIDCalls())
func (mock *MoqCmdable) XGroupSetIDCalls() []struct {
	Ctx    context.Context
	Stream string
	Group  string
	Start  string
} {
	var calls []struct {
		Ctx    context.Context
		Stream string
		Group  string
		Start  string
	}
	mock.lockXGroupSetID.RLock()
	calls = mock.calls.XGroupSetID
	mock.lockXGroupSetID.RUnlock()
	return calls
}

// ResetXGroupSetIDCalls reset all the calls that were made to XGroupSetID.
func (mock *MoqCmdable) ResetXGroupSetIDCalls() {
	mock.lockXGroupSetID.Lock()
	mock.calls.XGroupSetID = nil
	mock.lockXGroupSetID.Unlock()
}

// XInfoConsumers calls XInfoConsumersFunc.
func (mock *MoqCmdable) XInfoConsumers(ctx context.Context, key string, group string) *redis.XInfoConsumersCmd {
	if mock.XInfoConsumersFunc == nil {
		panic("MoqCmdable.XInfoConsumersFunc: method is nil but Cmdable.XInfoConsumers was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Group string
	}{
		Ctx:   ctx,
		Key:   key,
		Group: group,
	}
	mock.lockXInfoConsumers.Lock()
	mock.calls.XInfoConsumers = append(mock.calls.XInfoConsumers, callInfo)
	mock.lockXInfoConsumers.Unlock()
	return mock.XInfoConsumersFunc(ctx, key, group)
}

// XInfoConsumersCalls gets all the calls that were made to XInfoConsumers.
// Check the length with:
//
//	len(mockedCmdable.XInfoConsumersCalls())
func (mock *MoqCmdable) XInfoConsumersCalls() []struct {
	Ctx   context.Context
	Key   string
	Group string
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Group string
	}
	mock.lockXInfoConsumers.RLock()
	calls = mock.calls.XInfoConsumers
	mock.lockXInfoConsumers.RUnlock()
	return calls
}

// ResetXInfoConsumersCalls reset all the calls that were made to XInfoConsumers.
func (mock *MoqCmdable) ResetXInfoConsumersCalls() {
	mock.lockXInfoConsumers.Lock()
	mock.calls.XInfoConsumers = nil
	mock.lockXInfoConsumers.Unlock()
}

// XInfoGroups calls XInfoGroupsFunc.
func (mock *MoqCmdable) XInfoGroups(ctx context.Context, key string) *redis.XInfoGroupsCmd {
	if mock.XInfoGroupsFunc == nil {
		panic("MoqCmdable.XInfoGroupsFunc: method is nil but Cmdable.XInfoGroups was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockXInfoGroups.Lock()
	mock.calls.XInfoGroups = append(mock.calls.XInfoGroups, callInfo)
	mock.lockXInfoGroups.Unlock()
	return mock.XInfoGroupsFunc(ctx, key)
}

// XInfoGroupsCalls gets all the calls that were made to XInfoGroups.
// Check the length with:
//
//	len(mockedCmdable.XInfoGroupsCalls())
func (mock *MoqCmdable) XInfoGroupsCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockXInfoGroups.RLock()
	calls = mock.calls.XInfoGroups
	mock.lockXInfoGroups.RUnlock()
	return calls
}

// ResetXInfoGroupsCalls reset all the calls that were made to XInfoGroups.
func (mock *MoqCmdable) ResetXInfoGroupsCalls() {
	mock.lockXInfoGroups.Lock()
	mock.calls.XInfoGroups = nil
	mock.lockXInfoGroups.Unlock()
}

// XInfoStream calls XInfoStreamFunc.
func (mock *MoqCmdable) XInfoStream(ctx context.Context, key string) *redis.XInfoStreamCmd {
	if mock.XInfoStreamFunc == nil {
		panic("MoqCmdable.XInfoStreamFunc: method is nil but Cmdable.XInfoStream was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockXInfoStream.Lock()
	mock.calls.XInfoStream = append(mock.calls.XInfoStream, callInfo)
	mock.lockXInfoStream.Unlock()
	return mock.XInfoStreamFunc(ctx, key)
}

// XInfoStreamCalls gets all the calls that were made to XInfoStream.
// Check the length with:
//
//	len(mockedCmdable.XInfoStreamCalls())
func (mock *MoqCmdable) XInfoStreamCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockXInfoStream.RLock()
	calls = mock.calls.XInfoStream
	mock.lockXInfoStream.RUnlock()
	return calls
}

// ResetXInfoStreamCalls reset all the calls that were made to XInfoStream.
func (mock *MoqCmdable) ResetXInfoStreamCalls() {
	mock.lockXInfoStream.Lock()
	mock.calls.XInfoStream = nil
	mock.lockXInfoStream.Unlock()
}

// XInfoStreamFull calls XInfoStreamFullFunc.
func (mock *MoqCmdable) XInfoStreamFull(ctx context.Context, key string, count int) *redis.XInfoStreamFullCmd {
	if mock.XInfoStreamFullFunc == nil {
		panic("MoqCmdable.XInfoStreamFullFunc: method is nil but Cmdable.XInfoStreamFull was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Count int
	}{
		Ctx:   ctx,
		Key:   key,
		Count: count,
	}
	mock.lockXInfoStreamFull.Lock()
	mock.calls.XInfoStreamFull = append(mock.calls.XInfoStreamFull, callInfo)
	mock.lockXInfoStreamFull.Unlock()
	return mock.XInfoStreamFullFunc(ctx, key, count)
}

// XInfoStreamFullCalls gets all the calls that were made to XInfoStreamFull.
// Check the length with:
//
//	len(mockedCmdable.XInfoStreamFullCalls())
func (mock *MoqCmdable) XInfoStreamFullCalls() []struct {
	Ctx   context.Context
	Key   string
	Count int
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Count int
	}
	mock.lockXInfoStreamFull.RLock()
	calls = mock.calls.XInfoStreamFull
	mock.lockXInfoStreamFull.RUnlock()
	return calls
}

// ResetXInfoStreamFullCalls reset all the calls that were made to XInfoStreamFull.
func (mock *MoqCmdable) ResetXInfoStreamFullCalls() {
	mock.lockXInfoStreamFull.Lock()
	mock.calls.XInfoStreamFull = nil
	mock.lockXInfoStreamFull.Unlock()
}

// XLen calls XLenFunc.
func (mock *MoqCmdable) XLen(ctx context.Context, stream string) *redis.IntCmd {
	if mock.XLenFunc == nil {
		panic("MoqCmdable.XLenFunc: method is nil but Cmdable.XLen was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Stream string
	}{
		Ctx:    ctx,
		Stream: stream,
	}
	mock.lockXLen.Lock()
	mock.calls.XLen = append(mock.calls.XLen, callInfo)
	mock.lockXLen.Unlock()
	return mock.XLenFunc(ctx, stream)
}

// XLenCalls gets all the calls that were made to XLen.
// Check the length with:
//
//	len(mockedCmdable.XLenCalls())
func (mock *MoqCmdable) XLenCalls() []struct {
	Ctx    context.Context
	Stream string
} {
	var calls []struct {
		Ctx    context.Context
		Stream string
	}
	mock.lockXLen.RLock()
	calls = mock.calls.XLen
	mock.lockXLen.RUnlock()
	return calls
}

// ResetXLenCalls reset all the calls that were made to XLen.
func (mock *MoqCmdable) ResetXLenCalls() {
	mock.lockXLen.Lock()
	mock.calls.XLen = nil
	mock.lockXLen.Unlock()
}

// XPending calls XPendingFunc.
func (mock *MoqCmdable) XPending(ctx context.Context, stream string, group string) *redis.XPendingCmd {
	if mock.XPendingFunc == nil {
		panic("MoqCmdable.XPendingFunc: method is nil but Cmdable.XPending was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Stream string
		Group  string
	}{
		Ctx:    ctx,
		Stream: stream,
		Group:  group,
	}
	mock.lockXPending.Lock()
	mock.calls.XPending = append(mock.calls.XPending, callInfo)
	mock.lockXPending.Unlock()
	return mock.XPendingFunc(ctx, stream, group)
}

// XPendingCalls gets all the calls that were made to XPending.
// Check the length with:
//
//	len(mockedCmdable.XPendingCalls())
func (mock *MoqCmdable) XPendingCalls() []struct {
	Ctx    context.Context
	Stream string
	Group  string
} {
	var calls []struct {
		Ctx    context.Context
		Stream string
		Group  string
	}
	mock.lockXPending.RLock()
	calls = mock.calls.XPending
	mock.lockXPending.RUnlock()
	return calls
}

// ResetXPendingCalls reset all the calls that were made to XPending.
func (mock *MoqCmdable) ResetXPendingCalls() {
	mock.lockXPending.Lock()
	mock.calls.XPending = nil
	mock.lockXPending.Unlock()
}

// XPendingExt calls XPendingExtFunc.
func (mock *MoqCmdable) XPendingExt(ctx context.Context, a *redis.XPendingExtArgs) *redis.XPendingExtCmd {
	if mock.XPendingExtFunc == nil {
		panic("MoqCmdable.XPendingExtFunc: method is nil but Cmdable.XPendingExt was just called")
	}
	callInfo := struct {
		Ctx context.Context
		A   *redis.XPendingExtArgs
	}{
		Ctx: ctx,
		A:   a,
	}
	mock.lockXPendingExt.Lock()
	mock.calls.XPendingExt = append(mock.calls.XPendingExt, callInfo)
	mock.lockXPendingExt.Unlock()
	return mock.XPendingExtFunc(ctx, a)
}

// XPendingExtCalls gets all the calls that were made to XPendingExt.
// Check the length with:
//
//	len(mockedCmdable.XPendingExtCalls())
func (mock *MoqCmdable) XPendingExtCalls() []struct {
	Ctx context.Context
	A   *redis.XPendingExtArgs
} {
	var calls []struct {
		Ctx context.Context
		A   *redis.XPendingExtArgs
	}
	mock.lockXPendingExt.RLock()
	calls = mock.calls.XPendingExt
	mock.lockXPendingExt.RUnlock()
	return calls
}

// ResetXPendingExtCalls reset all the calls that were made to XPendingExt.
func (mock *MoqCmdable) ResetXPendingExtCalls() {
	mock.lockXPendingExt.Lock()
	mock.calls.XPendingExt = nil
	mock.lockXPendingExt.Unlock()
}

// XRange calls XRangeFunc.
func (mock *MoqCmdable) XRange(ctx context.Context, stream string, start string, stop string) *redis.XMessageSliceCmd {
	if mock.XRangeFunc == nil {
		panic("MoqCmdable.XRangeFunc: method is nil but Cmdable.XRange was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Stream string
		Start  string
		Stop   string
	}{
		Ctx:    ctx,
		Stream: stream,
		Start:  start,
		Stop:   stop,
	}
	mock.lockXRange.Lock()
	mock.calls.XRange = append(mock.calls.XRange, callInfo)
	mock.lockXRange.Unlock()
	return mock.XRangeFunc(ctx, stream, start, stop)
}

// XRangeCalls gets all the calls that were made to XRange.
// Check the length with:
//
//	len(mockedCmdable.XRangeCalls())
func (mock *MoqCmdable) XRangeCalls() []struct {
	Ctx    context.Context
	Stream string
	Start  string
	Stop   string
} {
	var calls []struct {
		Ctx    context.Context
		Stream string
		Start  string
		Stop   string
	}
	mock.lockXRange.RLock()
	calls = mock.calls.XRange
	mock.lockXRange.RUnlock()
	return calls
}

// ResetXRangeCalls reset all the calls that were made to XRange.
func (mock *MoqCmdable) ResetXRangeCalls() {
	mock.lockXRange.Lock()
	mock.calls.XRange = nil
	mock.lockXRange.Unlock()
}

// XRangeN calls XRangeNFunc.
func (mock *MoqCmdable) XRangeN(ctx context.Context, stream string, start string, stop string, count int64) *redis.XMessageSliceCmd {
	if mock.XRangeNFunc == nil {
		panic("MoqCmdable.XRangeNFunc: method is nil but Cmdable.XRangeN was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Stream string
		Start  string
		Stop   string
		Count  int64
	}{
		Ctx:    ctx,
		Stream: stream,
		Start:  start,
		Stop:   stop,
		Count:  count,
	}
	mock.lockXRangeN.Lock()
	mock.calls.XRangeN = append(mock.calls.XRangeN, callInfo)
	mock.lockXRangeN.Unlock()
	return mock.XRangeNFunc(ctx, stream, start, stop, count)
}

// XRangeNCalls gets all the calls that were made to XRangeN.
// Check the length with:
//
//	len(mockedCmdable.XRangeNCalls())
func (mock *MoqCmdable) XRangeNCalls() []struct {
	Ctx    context.Context
	Stream string
	Start  string
	Stop   string
	Count  int64
} {
	var calls []struct {
		Ctx    context.Context
		Stream string
		Start  string
		Stop   string
		Count  int64
	}
	mock.lockXRangeN.RLock()
	calls = mock.calls.XRangeN
	mock.lockXRangeN.RUnlock()
	return calls
}

// ResetXRangeNCalls reset all the calls that were made to XRangeN.
func (mock *MoqCmdable) ResetXRangeNCalls() {
	mock.lockXRangeN.Lock()
	mock.calls.XRangeN = nil
	mock.lockXRangeN.Unlock()
}

// XRead calls XReadFunc.
func (mock *MoqCmdable) XRead(ctx context.Context, a *redis.XReadArgs) *redis.XStreamSliceCmd {
	if mock.XReadFunc == nil {
		panic("MoqCmdable.XReadFunc: method is nil but Cmdable.XRead was just called")
	}
	callInfo := struct {
		Ctx context.Context
		A   *redis.XReadArgs
	}{
		Ctx: ctx,
		A:   a,
	}
	mock.lockXRead.Lock()
	mock.calls.XRead = append(mock.calls.XRead, callInfo)
	mock.lockXRead.Unlock()
	return mock.XReadFunc(ctx, a)
}

// XReadCalls gets all the calls that were made to XRead.
// Check the length with:
//
//	len(mockedCmdable.XReadCalls())
func (mock *MoqCmdable) XReadCalls() []struct {
	Ctx context.Context
	A   *redis.XReadArgs
} {
	var calls []struct {
		Ctx context.Context
		A   *redis.XReadArgs
	}
	mock.lockXRead.RLock()
	calls = mock.calls.XRead
	mock.lockXRead.RUnlock()
	return calls
}

// ResetXReadCalls reset all the calls that were made to XRead.
func (mock *MoqCmdable) ResetXReadCalls() {
	mock.lockXRead.Lock()
	mock.calls.XRead = nil
	mock.lockXRead.Unlock()
}

// XReadGroup calls XReadGroupFunc.
func (mock *MoqCmdable) XReadGroup(ctx context.Context, a *redis.XReadGroupArgs) *redis.XStreamSliceCmd {
	if mock.XReadGroupFunc == nil {
		panic("MoqCmdable.XReadGroupFunc: method is nil but Cmdable.XReadGroup was just called")
	}
	callInfo := struct {
		Ctx context.Context
		A   *redis.XReadGroupArgs
	}{
		Ctx: ctx,
		A:   a,
	}
	mock.lockXReadGroup.Lock()
	mock.calls.XReadGroup = append(mock.calls.XReadGroup, callInfo)
	mock.lockXReadGroup.Unlock()
	return mock.XReadGroupFunc(ctx, a)
}

// XReadGroupCalls gets all the calls that were made to XReadGroup.
// Check the length with:
//
//	len(mockedCmdable.XReadGroupCalls())
func (mock *MoqCmdable) XReadGroupCalls() []struct {
	Ctx context.Context
	A   *redis.XReadGroupArgs
} {
	var calls []struct {
		Ctx context.Context
		A   *redis.XReadGroupArgs
	}
	mock.lockXReadGroup.RLock()
	calls = mock.calls.XReadGroup
	mock.lockXReadGroup.RUnlock()
	return calls
}

// ResetXReadGroupCalls reset all the calls that were made to XReadGroup.
func (mock *MoqCmdable) ResetXReadGroupCalls() {
	mock.lockXReadGroup.Lock()
	mock.calls.XReadGroup = nil
	mock.lockXReadGroup.Unlock()
}

// XReadStreams calls XReadStreamsFunc.
func (mock *MoqCmdable) XReadStreams(ctx context.Context, streams ...string) *redis.XStreamSliceCmd {
	if mock.XReadStreamsFunc == nil {
		panic("MoqCmdable.XReadStreamsFunc: method is nil but Cmdable.XReadStreams was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Streams []string
	}{
		Ctx:     ctx,
		Streams: streams,
	}
	mock.lockXReadStreams.Lock()
	mock.calls.XReadStreams = append(mock.calls.XReadStreams, callInfo)
	mock.lockXReadStreams.Unlock()
	return mock.XReadStreamsFunc(ctx, streams...)
}

// XReadStreamsCalls gets all the calls that were made to XReadStreams.
// Check the length with:
//
//	len(mockedCmdable.XReadStreamsCalls())
func (mock *MoqCmdable) XReadStreamsCalls() []struct {
	Ctx     context.Context
	Streams []string
} {
	var calls []struct {
		Ctx     context.Context
		Streams []string
	}
	mock.lockXReadStreams.RLock()
	calls = mock.calls.XReadStreams
	mock.lockXReadStreams.RUnlock()
	return calls
}

// ResetXReadStreamsCalls reset all the calls that were made to XReadStreams.
func (mock *MoqCmdable) ResetXReadStreamsCalls() {
	mock.lockXReadStreams.Lock()
	mock.calls.XReadStreams = nil
	mock.lockXReadStreams.Unlock()
}

// XRevRange calls XRevRangeFunc.
func (mock *MoqCmdable) XRevRange(ctx context.Context, stream string, start string, stop string) *redis.XMessageSliceCmd {
	if mock.XRevRangeFunc == nil {
		panic("MoqCmdable.XRevRangeFunc: method is nil but Cmdable.XRevRange was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Stream string
		Start  string
		Stop   string
	}{
		Ctx:    ctx,
		Stream: stream,
		Start:  start,
		Stop:   stop,
	}
	mock.lockXRevRange.Lock()
	mock.calls.XRevRange = append(mock.calls.XRevRange, callInfo)
	mock.lockXRevRange.Unlock()
	return mock.XRevRangeFunc(ctx, stream, start, stop)
}

// XRevRangeCalls gets all the calls that were made to XRevRange.
// Check the length with:
//
//	len(mockedCmdable.XRevRangeCalls())
func (mock *MoqCmdable) XRevRangeCalls() []struct {
	Ctx    context.Context
	Stream string
	Start  string
	Stop   string
} {
	var calls []struct {
		Ctx    context.Context
		Stream string
		Start  string
		Stop   string
	}
	mock.lockXRevRange.RLock()
	calls = mock.calls.XRevRange
	mock.lockXRevRange.RUnlock()
	return calls
}

// ResetXRevRangeCalls reset all the calls that were made to XRevRange.
func (mock *MoqCmdable) ResetXRevRangeCalls() {
	mock.lockXRevRange.Lock()
	mock.calls.XRevRange = nil
	mock.lockXRevRange.Unlock()
}

// XRevRangeN calls XRevRangeNFunc.
func (mock *MoqCmdable) XRevRangeN(ctx context.Context, stream string, start string, stop string, count int64) *redis.XMessageSliceCmd {
	if mock.XRevRangeNFunc == nil {
		panic("MoqCmdable.XRevRangeNFunc: method is nil but Cmdable.XRevRangeN was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Stream string
		Start  string
		Stop   string
		Count  int64
	}{
		Ctx:    ctx,
		Stream: stream,
		Start:  start,
		Stop:   stop,
		Count:  count,
	}
	mock.lockXRevRangeN.Lock()
	mock.calls.XRevRangeN = append(mock.calls.XRevRangeN, callInfo)
	mock.lockXRevRangeN.Unlock()
	return mock.XRevRangeNFunc(ctx, stream, start, stop, count)
}

// XRevRangeNCalls gets all the calls that were made to XRevRangeN.
// Check the length with:
//
//	len(mockedCmdable.XRevRangeNCalls())
func (mock *MoqCmdable) XRevRangeNCalls() []struct {
	Ctx    context.Context
	Stream string
	Start  string
	Stop   string
	Count  int64
} {
	var calls []struct {
		Ctx    context.Context
		Stream string
		Start  string
		Stop   string
		Count  int64
	}
	mock.lockXRevRangeN.RLock()
	calls = mock.calls.XRevRangeN
	mock.lockXRevRangeN.RUnlock()
	return calls
}

// ResetXRevRangeNCalls reset all the calls that were made to XRevRangeN.
func (mock *MoqCmdable) ResetXRevRangeNCalls() {
	mock.lockXRevRangeN.Lock()
	mock.calls.XRevRangeN = nil
	mock.lockXRevRangeN.Unlock()
}

// XTrimMaxLen calls XTrimMaxLenFunc.
func (mock *MoqCmdable) XTrimMaxLen(ctx context.Context, key string, maxLen int64) *redis.IntCmd {
	if mock.XTrimMaxLenFunc == nil {
		panic("MoqCmdable.XTrimMaxLenFunc: method is nil but Cmdable.XTrimMaxLen was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		MaxLen int64
	}{
		Ctx:    ctx,
		Key:    key,
		MaxLen: maxLen,
	}
	mock.lockXTrimMaxLen.Lock()
	mock.calls.XTrimMaxLen = append(mock.calls.XTrimMaxLen, callInfo)
	mock.lockXTrimMaxLen.Unlock()
	return mock.XTrimMaxLenFunc(ctx, key, maxLen)
}

// XTrimMaxLenCalls gets all the calls that were made to XTrimMaxLen.
// Check the length with:
//
//	len(mockedCmdable.XTrimMaxLenCalls())
func (mock *MoqCmdable) XTrimMaxLenCalls() []struct {
	Ctx    context.Context
	Key    string
	MaxLen int64
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		MaxLen int64
	}
	mock.lockXTrimMaxLen.RLock()
	calls = mock.calls.XTrimMaxLen
	mock.lockXTrimMaxLen.RUnlock()
	return calls
}

// ResetXTrimMaxLenCalls reset all the calls that were made to XTrimMaxLen.
func (mock *MoqCmdable) ResetXTrimMaxLenCalls() {
	mock.lockXTrimMaxLen.Lock()
	mock.calls.XTrimMaxLen = nil
	mock.lockXTrimMaxLen.Unlock()
}

// XTrimMaxLenApprox calls XTrimMaxLenApproxFunc.
func (mock *MoqCmdable) XTrimMaxLenApprox(ctx context.Context, key string, maxLen int64, limit int64) *redis.IntCmd {
	if mock.XTrimMaxLenApproxFunc == nil {
		panic("MoqCmdable.XTrimMaxLenApproxFunc: method is nil but Cmdable.XTrimMaxLenApprox was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		MaxLen int64
		Limit  int64
	}{
		Ctx:    ctx,
		Key:    key,
		MaxLen: maxLen,
		Limit:  limit,
	}
	mock.lockXTrimMaxLenApprox.Lock()
	mock.calls.XTrimMaxLenApprox = append(mock.calls.XTrimMaxLenApprox, callInfo)
	mock.lockXTrimMaxLenApprox.Unlock()
	return mock.XTrimMaxLenApproxFunc(ctx, key, maxLen, limit)
}

// XTrimMaxLenApproxCalls gets all the calls that were made to XTrimMaxLenApprox.
// Check the length with:
//
//	len(mockedCmdable.XTrimMaxLenApproxCalls())
func (mock *MoqCmdable) XTrimMaxLenApproxCalls() []struct {
	Ctx    context.Context
	Key    string
	MaxLen int64
	Limit  int64
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		MaxLen int64
		Limit  int64
	}
	mock.lockXTrimMaxLenApprox.RLock()
	calls = mock.calls.XTrimMaxLenApprox
	mock.lockXTrimMaxLenApprox.RUnlock()
	return calls
}

// ResetXTrimMaxLenApproxCalls reset all the calls that were made to XTrimMaxLenApprox.
func (mock *MoqCmdable) ResetXTrimMaxLenApproxCalls() {
	mock.lockXTrimMaxLenApprox.Lock()
	mock.calls.XTrimMaxLenApprox = nil
	mock.lockXTrimMaxLenApprox.Unlock()
}

// XTrimMaxLenApproxMode calls XTrimMaxLenApproxModeFunc.
func (mock *MoqCmdable) XTrimMaxLenApproxMode(ctx context.Context, key string, maxLen int64, limit int64, mode string) *redis.IntCmd {
	if mock.XTrimMaxLenApproxModeFunc == nil {
		panic("MoqCmdable.XTrimMaxLenApproxModeFunc: method is nil but Cmdable.XTrimMaxLenApproxMode was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		MaxLen int64
		Limit  int64
		Mode   string
	}{
		Ctx:    ctx,
		Key:    key,
		MaxLen: maxLen,
		Limit:  limit,
		Mode:   mode,
	}
	mock.lockXTrimMaxLenApproxMode.Lock()
	mock.calls.XTrimMaxLenApproxMode = append(mock.calls.XTrimMaxLenApproxMode, callInfo)
	mock.lockXTrimMaxLenApproxMode.Unlock()
	return mock.XTrimMaxLenApproxModeFunc(ctx, key, maxLen, limit, mode)
}

// XTrimMaxLenApproxModeCalls gets all the calls that were made to XTrimMaxLenApproxMode.
// Check the length with:
//
//	len(mockedCmdable.XTrimMaxLenApproxModeCalls())
func (mock *MoqCmdable) XTrimMaxLenApproxModeCalls() []struct {
	Ctx    context.Context
	Key    string
	MaxLen int64
	Limit  int64
	Mode   string
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		MaxLen int64
		Limit  int64
		Mode   string
	}
	mock.lockXTrimMaxLenApproxMode.RLock()
	calls = mock.calls.XTrimMaxLenApproxMode
	mock.lockXTrimMaxLenApproxMode.RUnlock()
	return calls
}

// ResetXTrimMaxLenApproxModeCalls reset all the calls that were made to XTrimMaxLenApproxMode.
func (mock *MoqCmdable) ResetXTrimMaxLenApproxModeCalls() {
	mock.lockXTrimMaxLenApproxMode.Lock()
	mock.calls.XTrimMaxLenApproxMode = nil
	mock.lockXTrimMaxLenApproxMode.Unlock()
}

// XTrimMaxLenMode calls XTrimMaxLenModeFunc.
func (mock *MoqCmdable) XTrimMaxLenMode(ctx context.Context, key string, maxLen int64, mode string) *redis.IntCmd {
	if mock.XTrimMaxLenModeFunc == nil {
		panic("MoqCmdable.XTrimMaxLenModeFunc: method is nil but Cmdable.XTrimMaxLenMode was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		MaxLen int64
		Mode   string
	}{
		Ctx:    ctx,
		Key:    key,
		MaxLen: maxLen,
		Mode:   mode,
	}
	mock.lockXTrimMaxLenMode.Lock()
	mock.calls.XTrimMaxLenMode = append(mock.calls.XTrimMaxLenMode, callInfo)
	mock.lockXTrimMaxLenMode.Unlock()
	return mock.XTrimMaxLenModeFunc(ctx, key, maxLen, mode)
}

// XTrimMaxLenModeCalls gets all the calls that were made to XTrimMaxLenMode.
// Check the length with:
//
//	len(mockedCmdable.XTrimMaxLenModeCalls())
func (mock *MoqCmdable) XTrimMaxLenModeCalls() []struct {
	Ctx    context.Context
	Key    string
	MaxLen int64
	Mode   string
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		MaxLen int64
		Mode   string
	}
	mock.lockXTrimMaxLenMode.RLock()
	calls = mock.calls.XTrimMaxLenMode
	mock.lockXTrimMaxLenMode.RUnlock()
	return calls
}

// ResetXTrimMaxLenModeCalls reset all the calls that were made to XTrimMaxLenMode.
func (mock *MoqCmdable) ResetXTrimMaxLenModeCalls() {
	mock.lockXTrimMaxLenMode.Lock()
	mock.calls.XTrimMaxLenMode = nil
	mock.lockXTrimMaxLenMode.Unlock()
}

// XTrimMinID calls XTrimMinIDFunc.
func (mock *MoqCmdable) XTrimMinID(ctx context.Context, key string, minID string) *redis.IntCmd {
	if mock.XTrimMinIDFunc == nil {
		panic("MoqCmdable.XTrimMinIDFunc: method is nil but Cmdable.XTrimMinID was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		MinID string
	}{
		Ctx:   ctx,
		Key:   key,
		MinID: minID,
	}
	mock.lockXTrimMinID.Lock()
	mock.calls.XTrimMinID = append(mock.calls.XTrimMinID, callInfo)
	mock.lockXTrimMinID.Unlock()
	return mock.XTrimMinIDFunc(ctx, key, minID)
}

// XTrimMinIDCalls gets all the calls that were made to XTrimMinID.
// Check the length with:
//
//	len(mockedCmdable.XTrimMinIDCalls())
func (mock *MoqCmdable) XTrimMinIDCalls() []struct {
	Ctx   context.Context
	Key   string
	MinID string
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		MinID string
	}
	mock.lockXTrimMinID.RLock()
	calls = mock.calls.XTrimMinID
	mock.lockXTrimMinID.RUnlock()
	return calls
}

// ResetXTrimMinIDCalls reset all the calls that were made to XTrimMinID.
func (mock *MoqCmdable) ResetXTrimMinIDCalls() {
	mock.lockXTrimMinID.Lock()
	mock.calls.XTrimMinID = nil
	mock.lockXTrimMinID.Unlock()
}

// XTrimMinIDApprox calls XTrimMinIDApproxFunc.
func (mock *MoqCmdable) XTrimMinIDApprox(ctx context.Context, key string, minID string, limit int64) *redis.IntCmd {
	if mock.XTrimMinIDApproxFunc == nil {
		panic("MoqCmdable.XTrimMinIDApproxFunc: method is nil but Cmdable.XTrimMinIDApprox was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		MinID string
		Limit int64
	}{
		Ctx:   ctx,
		Key:   key,
		MinID: minID,
		Limit: limit,
	}
	mock.lockXTrimMinIDApprox.Lock()
	mock.calls.XTrimMinIDApprox = append(mock.calls.XTrimMinIDApprox, callInfo)
	mock.lockXTrimMinIDApprox.Unlock()
	return mock.XTrimMinIDApproxFunc(ctx, key, minID, limit)
}

// XTrimMinIDApproxCalls gets all the calls that were made to XTrimMinIDApprox.
// Check the length with:
//
//	len(mockedCmdable.XTrimMinIDApproxCalls())
func (mock *MoqCmdable) XTrimMinIDApproxCalls() []struct {
	Ctx   context.Context
	Key   string
	MinID string
	Limit int64
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		MinID string
		Limit int64
	}
	mock.lockXTrimMinIDApprox.RLock()
	calls = mock.calls.XTrimMinIDApprox
	mock.lockXTrimMinIDApprox.RUnlock()
	return calls
}

// ResetXTrimMinIDApproxCalls reset all the calls that were made to XTrimMinIDApprox.
func (mock *MoqCmdable) ResetXTrimMinIDApproxCalls() {
	mock.lockXTrimMinIDApprox.Lock()
	mock.calls.XTrimMinIDApprox = nil
	mock.lockXTrimMinIDApprox.Unlock()
}

// XTrimMinIDApproxMode calls XTrimMinIDApproxModeFunc.
func (mock *MoqCmdable) XTrimMinIDApproxMode(ctx context.Context, key string, minID string, limit int64, mode string) *redis.IntCmd {
	if mock.XTrimMinIDApproxModeFunc == nil {
		panic("MoqCmdable.XTrimMinIDApproxModeFunc: method is nil but Cmdable.XTrimMinIDApproxMode was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		MinID string
		Limit int64
		Mode  string
	}{
		Ctx:   ctx,
		Key:   key,
		MinID: minID,
		Limit: limit,
		Mode:  mode,
	}
	mock.lockXTrimMinIDApproxMode.Lock()
	mock.calls.XTrimMinIDApproxMode = append(mock.calls.XTrimMinIDApproxMode, callInfo)
	mock.lockXTrimMinIDApproxMode.Unlock()
	return mock.XTrimMinIDApproxModeFunc(ctx, key, minID, limit, mode)
}

// XTrimMinIDApproxModeCalls gets all the calls that were made to XTrimMinIDApproxMode.
// Check the length with:
//
//	len(mockedCmdable.XTrimMinIDApproxModeCalls())
func (mock *MoqCmdable) XTrimMinIDApproxModeCalls() []struct {
	Ctx   context.Context
	Key   string
	MinID string
	Limit int64
	Mode  string
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		MinID string
		Limit int64
		Mode  string
	}
	mock.lockXTrimMinIDApproxMode.RLock()
	calls = mock.calls.XTrimMinIDApproxMode
	mock.lockXTrimMinIDApproxMode.RUnlock()
	return calls
}

// ResetXTrimMinIDApproxModeCalls reset all the calls that were made to XTrimMinIDApproxMode.
func (mock *MoqCmdable) ResetXTrimMinIDApproxModeCalls() {
	mock.lockXTrimMinIDApproxMode.Lock()
	mock.calls.XTrimMinIDApproxMode = nil
	mock.lockXTrimMinIDApproxMode.Unlock()
}

// XTrimMinIDMode calls XTrimMinIDModeFunc.
func (mock *MoqCmdable) XTrimMinIDMode(ctx context.Context, key string, minID string, mode string) *redis.IntCmd {
	if mock.XTrimMinIDModeFunc == nil {
		panic("MoqCmdable.XTrimMinIDModeFunc: method is nil but Cmdable.XTrimMinIDMode was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		MinID string
		Mode  string
	}{
		Ctx:   ctx,
		Key:   key,
		MinID: minID,
		Mode:  mode,
	}
	mock.lockXTrimMinIDMode.Lock()
	mock.calls.XTrimMinIDMode = append(mock.calls.XTrimMinIDMode, callInfo)
	mock.lockXTrimMinIDMode.Unlock()
	return mock.XTrimMinIDModeFunc(ctx, key, minID, mode)
}

// XTrimMinIDModeCalls gets all the calls that were made to XTrimMinIDMode.
// Check the length with:
//
//	len(mockedCmdable.XTrimMinIDModeCalls())
func (mock *MoqCmdable) XTrimMinIDModeCalls() []struct {
	Ctx   context.Context
	Key   string
	MinID string
	Mode  string
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		MinID string
		Mode  string
	}
	mock.lockXTrimMinIDMode.RLock()
	calls = mock.calls.XTrimMinIDMode
	mock.lockXTrimMinIDMode.RUnlock()
	return calls
}

// ResetXTrimMinIDModeCalls reset all the calls that were made to XTrimMinIDMode.
func (mock *MoqCmdable) ResetXTrimMinIDModeCalls() {
	mock.lockXTrimMinIDMode.Lock()
	mock.calls.XTrimMinIDMode = nil
	mock.lockXTrimMinIDMode.Unlock()
}

// ZAdd calls ZAddFunc.
func (mock *MoqCmdable) ZAdd(ctx context.Context, key string, members ...redis.Z) *redis.IntCmd {
	if mock.ZAddFunc == nil {
		panic("MoqCmdable.ZAddFunc: method is nil but Cmdable.ZAdd was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Key     string
		Members []redis.Z
	}{
		Ctx:     ctx,
		Key:     key,
		Members: members,
	}
	mock.lockZAdd.Lock()
	mock.calls.ZAdd = append(mock.calls.ZAdd, callInfo)
	mock.lockZAdd.Unlock()
	return mock.ZAddFunc(ctx, key, members...)
}

// ZAddCalls gets all the calls that were made to ZAdd.
// Check the length with:
//
//	len(mockedCmdable.ZAddCalls())
func (mock *MoqCmdable) ZAddCalls() []struct {
	Ctx     context.Context
	Key     string
	Members []redis.Z
} {
	var calls []struct {
		Ctx     context.Context
		Key     string
		Members []redis.Z
	}
	mock.lockZAdd.RLock()
	calls = mock.calls.ZAdd
	mock.lockZAdd.RUnlock()
	return calls
}

// ResetZAddCalls reset all the calls that were made to ZAdd.
func (mock *MoqCmdable) ResetZAddCalls() {
	mock.lockZAdd.Lock()
	mock.calls.ZAdd = nil
	mock.lockZAdd.Unlock()
}

// ZAddArgs calls ZAddArgsFunc.
func (mock *MoqCmdable) ZAddArgs(ctx context.Context, key string, args redis.ZAddArgs) *redis.IntCmd {
	if mock.ZAddArgsFunc == nil {
		panic("MoqCmdable.ZAddArgsFunc: method is nil but Cmdable.ZAddArgs was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Key  string
		Args redis.ZAddArgs
	}{
		Ctx:  ctx,
		Key:  key,
		Args: args,
	}
	mock.lockZAddArgs.Lock()
	mock.calls.ZAddArgs = append(mock.calls.ZAddArgs, callInfo)
	mock.lockZAddArgs.Unlock()
	return mock.ZAddArgsFunc(ctx, key, args)
}

// ZAddArgsCalls gets all the calls that were made to ZAddArgs.
// Check the length with:
//
//	len(mockedCmdable.ZAddArgsCalls())
func (mock *MoqCmdable) ZAddArgsCalls() []struct {
	Ctx  context.Context
	Key  string
	Args redis.ZAddArgs
} {
	var calls []struct {
		Ctx  context.Context
		Key  string
		Args redis.ZAddArgs
	}
	mock.lockZAddArgs.RLock()
	calls = mock.calls.ZAddArgs
	mock.lockZAddArgs.RUnlock()
	return calls
}

// ResetZAddArgsCalls reset all the calls that were made to ZAddArgs.
func (mock *MoqCmdable) ResetZAddArgsCalls() {
	mock.lockZAddArgs.Lock()
	mock.calls.ZAddArgs = nil
	mock.lockZAddArgs.Unlock()
}

// ZAddArgsIncr calls ZAddArgsIncrFunc.
func (mock *MoqCmdable) ZAddArgsIncr(ctx context.Context, key string, args redis.ZAddArgs) *redis.FloatCmd {
	if mock.ZAddArgsIncrFunc == nil {
		panic("MoqCmdable.ZAddArgsIncrFunc: method is nil but Cmdable.ZAddArgsIncr was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Key  string
		Args redis.ZAddArgs
	}{
		Ctx:  ctx,
		Key:  key,
		Args: args,
	}
	mock.lockZAddArgsIncr.Lock()
	mock.calls.ZAddArgsIncr = append(mock.calls.ZAddArgsIncr, callInfo)
	mock.lockZAddArgsIncr.Unlock()
	return mock.ZAddArgsIncrFunc(ctx, key, args)
}

// ZAddArgsIncrCalls gets all the calls that were made to ZAddArgsIncr.
// Check the length with:
//
//	len(mockedCmdable.ZAddArgsIncrCalls())
func (mock *MoqCmdable) ZAddArgsIncrCalls() []struct {
	Ctx  context.Context
	Key  string
	Args redis.ZAddArgs
} {
	var calls []struct {
		Ctx  context.Context
		Key  string
		Args redis.ZAddArgs
	}
	mock.lockZAddArgsIncr.RLock()
	calls = mock.calls.ZAddArgsIncr
	mock.lockZAddArgsIncr.RUnlock()
	return calls
}

// ResetZAddArgsIncrCalls reset all the calls that were made to ZAddArgsIncr.
func (mock *MoqCmdable) ResetZAddArgsIncrCalls() {
	mock.lockZAddArgsIncr.Lock()
	mock.calls.ZAddArgsIncr = nil
	mock.lockZAddArgsIncr.Unlock()
}

// ZAddGT calls ZAddGTFunc.
func (mock *MoqCmdable) ZAddGT(ctx context.Context, key string, members ...redis.Z) *redis.IntCmd {
	if mock.ZAddGTFunc == nil {
		panic("MoqCmdable.ZAddGTFunc: method is nil but Cmdable.ZAddGT was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Key     string
		Members []redis.Z
	}{
		Ctx:     ctx,
		Key:     key,
		Members: members,
	}
	mock.lockZAddGT.Lock()
	mock.calls.ZAddGT = append(mock.calls.ZAddGT, callInfo)
	mock.lockZAddGT.Unlock()
	return mock.ZAddGTFunc(ctx, key, members...)
}

// ZAddGTCalls gets all the calls that were made to ZAddGT.
// Check the length with:
//
//	len(mockedCmdable.ZAddGTCalls())
func (mock *MoqCmdable) ZAddGTCalls() []struct {
	Ctx     context.Context
	Key     string
	Members []redis.Z
} {
	var calls []struct {
		Ctx     context.Context
		Key     string
		Members []redis.Z
	}
	mock.lockZAddGT.RLock()
	calls = mock.calls.ZAddGT
	mock.lockZAddGT.RUnlock()
	return calls
}

// ResetZAddGTCalls reset all the calls that were made to ZAddGT.
func (mock *MoqCmdable) ResetZAddGTCalls() {
	mock.lockZAddGT.Lock()
	mock.calls.ZAddGT = nil
	mock.lockZAddGT.Unlock()
}

// ZAddLT calls ZAddLTFunc.
func (mock *MoqCmdable) ZAddLT(ctx context.Context, key string, members ...redis.Z) *redis.IntCmd {
	if mock.ZAddLTFunc == nil {
		panic("MoqCmdable.ZAddLTFunc: method is nil but Cmdable.ZAddLT was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Key     string
		Members []redis.Z
	}{
		Ctx:     ctx,
		Key:     key,
		Members: members,
	}
	mock.lockZAddLT.Lock()
	mock.calls.ZAddLT = append(mock.calls.ZAddLT, callInfo)
	mock.lockZAddLT.Unlock()
	return mock.ZAddLTFunc(ctx, key, members...)
}

// ZAddLTCalls gets all the calls that were made to ZAddLT.
// Check the length with:
//
//	len(mockedCmdable.ZAddLTCalls())
func (mock *MoqCmdable) ZAddLTCalls() []struct {
	Ctx     context.Context
	Key     string
	Members []redis.Z
} {
	var calls []struct {
		Ctx     context.Context
		Key     string
		Members []redis.Z
	}
	mock.lockZAddLT.RLock()
	calls = mock.calls.ZAddLT
	mock.lockZAddLT.RUnlock()
	return calls
}

// ResetZAddLTCalls reset all the calls that were made to ZAddLT.
func (mock *MoqCmdable) ResetZAddLTCalls() {
	mock.lockZAddLT.Lock()
	mock.calls.ZAddLT = nil
	mock.lockZAddLT.Unlock()
}

// ZAddNX calls ZAddNXFunc.
func (mock *MoqCmdable) ZAddNX(ctx context.Context, key string, members ...redis.Z) *redis.IntCmd {
	if mock.ZAddNXFunc == nil {
		panic("MoqCmdable.ZAddNXFunc: method is nil but Cmdable.ZAddNX was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Key     string
		Members []redis.Z
	}{
		Ctx:     ctx,
		Key:     key,
		Members: members,
	}
	mock.lockZAddNX.Lock()
	mock.calls.ZAddNX = append(mock.calls.ZAddNX, callInfo)
	mock.lockZAddNX.Unlock()
	return mock.ZAddNXFunc(ctx, key, members...)
}

// ZAddNXCalls gets all the calls that were made to ZAddNX.
// Check the length with:
//
//	len(mockedCmdable.ZAddNXCalls())
func (mock *MoqCmdable) ZAddNXCalls() []struct {
	Ctx     context.Context
	Key     string
	Members []redis.Z
} {
	var calls []struct {
		Ctx     context.Context
		Key     string
		Members []redis.Z
	}
	mock.lockZAddNX.RLock()
	calls = mock.calls.ZAddNX
	mock.lockZAddNX.RUnlock()
	return calls
}

// ResetZAddNXCalls reset all the calls that were made to ZAddNX.
func (mock *MoqCmdable) ResetZAddNXCalls() {
	mock.lockZAddNX.Lock()
	mock.calls.ZAddNX = nil
	mock.lockZAddNX.Unlock()
}

// ZAddXX calls ZAddXXFunc.
func (mock *MoqCmdable) ZAddXX(ctx context.Context, key string, members ...redis.Z) *redis.IntCmd {
	if mock.ZAddXXFunc == nil {
		panic("MoqCmdable.ZAddXXFunc: method is nil but Cmdable.ZAddXX was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Key     string
		Members []redis.Z
	}{
		Ctx:     ctx,
		Key:     key,
		Members: members,
	}
	mock.lockZAddXX.Lock()
	mock.calls.ZAddXX = append(mock.calls.ZAddXX, callInfo)
	mock.lockZAddXX.Unlock()
	return mock.ZAddXXFunc(ctx, key, members...)
}

// ZAddXXCalls gets all the calls that were made to ZAddXX.
// Check the length with:
//
//	len(mockedCmdable.ZAddXXCalls())
func (mock *MoqCmdable) ZAddXXCalls() []struct {
	Ctx     context.Context
	Key     string
	Members []redis.Z
} {
	var calls []struct {
		Ctx     context.Context
		Key     string
		Members []redis.Z
	}
	mock.lockZAddXX.RLock()
	calls = mock.calls.ZAddXX
	mock.lockZAddXX.RUnlock()
	return calls
}

// ResetZAddXXCalls reset all the calls that were made to ZAddXX.
func (mock *MoqCmdable) ResetZAddXXCalls() {
	mock.lockZAddXX.Lock()
	mock.calls.ZAddXX = nil
	mock.lockZAddXX.Unlock()
}

// ZCard calls ZCardFunc.
func (mock *MoqCmdable) ZCard(ctx context.Context, key string) *redis.IntCmd {
	if mock.ZCardFunc == nil {
		panic("MoqCmdable.ZCardFunc: method is nil but Cmdable.ZCard was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockZCard.Lock()
	mock.calls.ZCard = append(mock.calls.ZCard, callInfo)
	mock.lockZCard.Unlock()
	return mock.ZCardFunc(ctx, key)
}

// ZCardCalls gets all the calls that were made to ZCard.
// Check the length with:
//
//	len(mockedCmdable.ZCardCalls())
func (mock *MoqCmdable) ZCardCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockZCard.RLock()
	calls = mock.calls.ZCard
	mock.lockZCard.RUnlock()
	return calls
}

// ResetZCardCalls reset all the calls that were made to ZCard.
func (mock *MoqCmdable) ResetZCardCalls() {
	mock.lockZCard.Lock()
	mock.calls.ZCard = nil
	mock.lockZCard.Unlock()
}

// ZCount calls ZCountFunc.
func (mock *MoqCmdable) ZCount(ctx context.Context, key string, min string, max string) *redis.IntCmd {
	if mock.ZCountFunc == nil {
		panic("MoqCmdable.ZCountFunc: method is nil but Cmdable.ZCount was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
		Min string
		Max string
	}{
		Ctx: ctx,
		Key: key,
		Min: min,
		Max: max,
	}
	mock.lockZCount.Lock()
	mock.calls.ZCount = append(mock.calls.ZCount, callInfo)
	mock.lockZCount.Unlock()
	return mock.ZCountFunc(ctx, key, min, max)
}

// ZCountCalls gets all the calls that were made to ZCount.
// Check the length with:
//
//	len(mockedCmdable.ZCountCalls())
func (mock *MoqCmdable) ZCountCalls() []struct {
	Ctx context.Context
	Key string
	Min string
	Max string
} {
	var calls []struct {
		Ctx context.Context
		Key string
		Min string
		Max string
	}
	mock.lockZCount.RLock()
	calls = mock.calls.ZCount
	mock.lockZCount.RUnlock()
	return calls
}

// ResetZCountCalls reset all the calls that were made to ZCount.
func (mock *MoqCmdable) ResetZCountCalls() {
	mock.lockZCount.Lock()
	mock.calls.ZCount = nil
	mock.lockZCount.Unlock()
}

// ZDiff calls ZDiffFunc.
func (mock *MoqCmdable) ZDiff(ctx context.Context, keys ...string) *redis.StringSliceCmd {
	if mock.ZDiffFunc == nil {
		panic("MoqCmdable.ZDiffFunc: method is nil but Cmdable.ZDiff was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Keys []string
	}{
		Ctx:  ctx,
		Keys: keys,
	}
	mock.lockZDiff.Lock()
	mock.calls.ZDiff = append(mock.calls.ZDiff, callInfo)
	mock.lockZDiff.Unlock()
	return mock.ZDiffFunc(ctx, keys...)
}

// ZDiffCalls gets all the calls that were made to ZDiff.
// Check the length with:
//
//	len(mockedCmdable.ZDiffCalls())
func (mock *MoqCmdable) ZDiffCalls() []struct {
	Ctx  context.Context
	Keys []string
} {
	var calls []struct {
		Ctx  context.Context
		Keys []string
	}
	mock.lockZDiff.RLock()
	calls = mock.calls.ZDiff
	mock.lockZDiff.RUnlock()
	return calls
}

// ResetZDiffCalls reset all the calls that were made to ZDiff.
func (mock *MoqCmdable) ResetZDiffCalls() {
	mock.lockZDiff.Lock()
	mock.calls.ZDiff = nil
	mock.lockZDiff.Unlock()
}

// ZDiffStore calls ZDiffStoreFunc.
func (mock *MoqCmdable) ZDiffStore(ctx context.Context, destination string, keys ...string) *redis.IntCmd {
	if mock.ZDiffStoreFunc == nil {
		panic("MoqCmdable.ZDiffStoreFunc: method is nil but Cmdable.ZDiffStore was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		Destination string
		Keys        []string
	}{
		Ctx:         ctx,
		Destination: destination,
		Keys:        keys,
	}
	mock.lockZDiffStore.Lock()
	mock.calls.ZDiffStore = append(mock.calls.ZDiffStore, callInfo)
	mock.lockZDiffStore.Unlock()
	return mock.ZDiffStoreFunc(ctx, destination, keys...)
}

// ZDiffStoreCalls gets all the calls that were made to ZDiffStore.
// Check the length with:
//
//	len(mockedCmdable.ZDiffStoreCalls())
func (mock *MoqCmdable) ZDiffStoreCalls() []struct {
	Ctx         context.Context
	Destination string
	Keys        []string
} {
	var calls []struct {
		Ctx         context.Context
		Destination string
		Keys        []string
	}
	mock.lockZDiffStore.RLock()
	calls = mock.calls.ZDiffStore
	mock.lockZDiffStore.RUnlock()
	return calls
}

// ResetZDiffStoreCalls reset all the calls that were made to ZDiffStore.
func (mock *MoqCmdable) ResetZDiffStoreCalls() {
	mock.lockZDiffStore.Lock()
	mock.calls.ZDiffStore = nil
	mock.lockZDiffStore.Unlock()
}

// ZDiffWithScores calls ZDiffWithScoresFunc.
func (mock *MoqCmdable) ZDiffWithScores(ctx context.Context, keys ...string) *redis.ZSliceCmd {
	if mock.ZDiffWithScoresFunc == nil {
		panic("MoqCmdable.ZDiffWithScoresFunc: method is nil but Cmdable.ZDiffWithScores was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Keys []string
	}{
		Ctx:  ctx,
		Keys: keys,
	}
	mock.lockZDiffWithScores.Lock()
	mock.calls.ZDiffWithScores = append(mock.calls.ZDiffWithScores, callInfo)
	mock.lockZDiffWithScores.Unlock()
	return mock.ZDiffWithScoresFunc(ctx, keys...)
}

// ZDiffWithScoresCalls gets all the calls that were made to ZDiffWithScores.
// Check the length with:
//
//	len(mockedCmdable.ZDiffWithScoresCalls())
func (mock *MoqCmdable) ZDiffWithScoresCalls() []struct {
	Ctx  context.Context
	Keys []string
} {
	var calls []struct {
		Ctx  context.Context
		Keys []string
	}
	mock.lockZDiffWithScores.RLock()
	calls = mock.calls.ZDiffWithScores
	mock.lockZDiffWithScores.RUnlock()
	return calls
}

// ResetZDiffWithScoresCalls reset all the calls that were made to ZDiffWithScores.
func (mock *MoqCmdable) ResetZDiffWithScoresCalls() {
	mock.lockZDiffWithScores.Lock()
	mock.calls.ZDiffWithScores = nil
	mock.lockZDiffWithScores.Unlock()
}

// ZIncrBy calls ZIncrByFunc.
func (mock *MoqCmdable) ZIncrBy(ctx context.Context, key string, increment float64, member string) *redis.FloatCmd {
	if mock.ZIncrByFunc == nil {
		panic("MoqCmdable.ZIncrByFunc: method is nil but Cmdable.ZIncrBy was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Key       string
		Increment float64
		Member    string
	}{
		Ctx:       ctx,
		Key:       key,
		Increment: increment,
		Member:    member,
	}
	mock.lockZIncrBy.Lock()
	mock.calls.ZIncrBy = append(mock.calls.ZIncrBy, callInfo)
	mock.lockZIncrBy.Unlock()
	return mock.ZIncrByFunc(ctx, key, increment, member)
}

// ZIncrByCalls gets all the calls that were made to ZIncrBy.
// Check the length with:
//
//	len(mockedCmdable.ZIncrByCalls())
func (mock *MoqCmdable) ZIncrByCalls() []struct {
	Ctx       context.Context
	Key       string
	Increment float64
	Member    string
} {
	var calls []struct {
		Ctx       context.Context
		Key       string
		Increment float64
		Member    string
	}
	mock.lockZIncrBy.RLock()
	calls = mock.calls.ZIncrBy
	mock.lockZIncrBy.RUnlock()
	return calls
}

// ResetZIncrByCalls reset all the calls that were made to ZIncrBy.
func (mock *MoqCmdable) ResetZIncrByCalls() {
	mock.lockZIncrBy.Lock()
	mock.calls.ZIncrBy = nil
	mock.lockZIncrBy.Unlock()
}

// ZInter calls ZInterFunc.
func (mock *MoqCmdable) ZInter(ctx context.Context, store *redis.ZStore) *redis.StringSliceCmd {
	if mock.ZInterFunc == nil {
		panic("MoqCmdable.ZInterFunc: method is nil but Cmdable.ZInter was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Store *redis.ZStore
	}{
		Ctx:   ctx,
		Store: store,
	}
	mock.lockZInter.Lock()
	mock.calls.ZInter = append(mock.calls.ZInter, callInfo)
	mock.lockZInter.Unlock()
	return mock.ZInterFunc(ctx, store)
}

// ZInterCalls gets all the calls that were made to ZInter.
// Check the length with:
//
//	len(mockedCmdable.ZInterCalls())
func (mock *MoqCmdable) ZInterCalls() []struct {
	Ctx   context.Context
	Store *redis.ZStore
} {
	var calls []struct {
		Ctx   context.Context
		Store *redis.ZStore
	}
	mock.lockZInter.RLock()
	calls = mock.calls.ZInter
	mock.lockZInter.RUnlock()
	return calls
}

// ResetZInterCalls reset all the calls that were made to ZInter.
func (mock *MoqCmdable) ResetZInterCalls() {
	mock.lockZInter.Lock()
	mock.calls.ZInter = nil
	mock.lockZInter.Unlock()
}

// ZInterCard calls ZInterCardFunc.
func (mock *MoqCmdable) ZInterCard(ctx context.Context, limit int64, keys ...string) *redis.IntCmd {
	if mock.ZInterCardFunc == nil {
		panic("MoqCmdable.ZInterCardFunc: method is nil but Cmdable.ZInterCard was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Limit int64
		Keys  []string
	}{
		Ctx:   ctx,
		Limit: limit,
		Keys:  keys,
	}
	mock.lockZInterCard.Lock()
	mock.calls.ZInterCard = append(mock.calls.ZInterCard, callInfo)
	mock.lockZInterCard.Unlock()
	return mock.ZInterCardFunc(ctx, limit, keys...)
}

// ZInterCardCalls gets all the calls that were made to ZInterCard.
// Check the length with:
//
//	len(mockedCmdable.ZInterCardCalls())
func (mock *MoqCmdable) ZInterCardCalls() []struct {
	Ctx   context.Context
	Limit int64
	Keys  []string
} {
	var calls []struct {
		Ctx   context.Context
		Limit int64
		Keys  []string
	}
	mock.lockZInterCard.RLock()
	calls = mock.calls.ZInterCard
	mock.lockZInterCard.RUnlock()
	return calls
}

// ResetZInterCardCalls reset all the calls that were made to ZInterCard.
func (mock *MoqCmdable) ResetZInterCardCalls() {
	mock.lockZInterCard.Lock()
	mock.calls.ZInterCard = nil
	mock.lockZInterCard.Unlock()
}

// ZInterStore calls ZInterStoreFunc.
func (mock *MoqCmdable) ZInterStore(ctx context.Context, destination string, store *redis.ZStore) *redis.IntCmd {
	if mock.ZInterStoreFunc == nil {
		panic("MoqCmdable.ZInterStoreFunc: method is nil but Cmdable.ZInterStore was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		Destination string
		Store       *redis.ZStore
	}{
		Ctx:         ctx,
		Destination: destination,
		Store:       store,
	}
	mock.lockZInterStore.Lock()
	mock.calls.ZInterStore = append(mock.calls.ZInterStore, callInfo)
	mock.lockZInterStore.Unlock()
	return mock.ZInterStoreFunc(ctx, destination, store)
}

// ZInterStoreCalls gets all the calls that were made to ZInterStore.
// Check the length with:
//
//	len(mockedCmdable.ZInterStoreCalls())
func (mock *MoqCmdable) ZInterStoreCalls() []struct {
	Ctx         context.Context
	Destination string
	Store       *redis.ZStore
} {
	var calls []struct {
		Ctx         context.Context
		Destination string
		Store       *redis.ZStore
	}
	mock.lockZInterStore.RLock()
	calls = mock.calls.ZInterStore
	mock.lockZInterStore.RUnlock()
	return calls
}

// ResetZInterStoreCalls reset all the calls that were made to ZInterStore.
func (mock *MoqCmdable) ResetZInterStoreCalls() {
	mock.lockZInterStore.Lock()
	mock.calls.ZInterStore = nil
	mock.lockZInterStore.Unlock()
}

// ZInterWithScores calls ZInterWithScoresFunc.
func (mock *MoqCmdable) ZInterWithScores(ctx context.Context, store *redis.ZStore) *redis.ZSliceCmd {
	if mock.ZInterWithScoresFunc == nil {
		panic("MoqCmdable.ZInterWithScoresFunc: method is nil but Cmdable.ZInterWithScores was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Store *redis.ZStore
	}{
		Ctx:   ctx,
		Store: store,
	}
	mock.lockZInterWithScores.Lock()
	mock.calls.ZInterWithScores = append(mock.calls.ZInterWithScores, callInfo)
	mock.lockZInterWithScores.Unlock()
	return mock.ZInterWithScoresFunc(ctx, store)
}

// ZInterWithScoresCalls gets all the calls that were made to ZInterWithScores.
// Check the length with:
//
//	len(mockedCmdable.ZInterWithScoresCalls())
func (mock *MoqCmdable) ZInterWithScoresCalls() []struct {
	Ctx   context.Context
	Store *redis.ZStore
} {
	var calls []struct {
		Ctx   context.Context
		Store *redis.ZStore
	}
	mock.lockZInterWithScores.RLock()
	calls = mock.calls.ZInterWithScores
	mock.lockZInterWithScores.RUnlock()
	return calls
}

// ResetZInterWithScoresCalls reset all the calls that were made to ZInterWithScores.
func (mock *MoqCmdable) ResetZInterWithScoresCalls() {
	mock.lockZInterWithScores.Lock()
	mock.calls.ZInterWithScores = nil
	mock.lockZInterWithScores.Unlock()
}

// ZLexCount calls ZLexCountFunc.
func (mock *MoqCmdable) ZLexCount(ctx context.Context, key string, min string, max string) *redis.IntCmd {
	if mock.ZLexCountFunc == nil {
		panic("MoqCmdable.ZLexCountFunc: method is nil but Cmdable.ZLexCount was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
		Min string
		Max string
	}{
		Ctx: ctx,
		Key: key,
		Min: min,
		Max: max,
	}
	mock.lockZLexCount.Lock()
	mock.calls.ZLexCount = append(mock.calls.ZLexCount, callInfo)
	mock.lockZLexCount.Unlock()
	return mock.ZLexCountFunc(ctx, key, min, max)
}

// ZLexCountCalls gets all the calls that were made to ZLexCount.
// Check the length with:
//
//	len(mockedCmdable.ZLexCountCalls())
func (mock *MoqCmdable) ZLexCountCalls() []struct {
	Ctx context.Context
	Key string
	Min string
	Max string
} {
	var calls []struct {
		Ctx context.Context
		Key string
		Min string
		Max string
	}
	mock.lockZLexCount.RLock()
	calls = mock.calls.ZLexCount
	mock.lockZLexCount.RUnlock()
	return calls
}

// ResetZLexCountCalls reset all the calls that were made to ZLexCount.
func (mock *MoqCmdable) ResetZLexCountCalls() {
	mock.lockZLexCount.Lock()
	mock.calls.ZLexCount = nil
	mock.lockZLexCount.Unlock()
}

// ZMPop calls ZMPopFunc.
func (mock *MoqCmdable) ZMPop(ctx context.Context, order string, count int64, keys ...string) *redis.ZSliceWithKeyCmd {
	if mock.ZMPopFunc == nil {
		panic("MoqCmdable.ZMPopFunc: method is nil but Cmdable.ZMPop was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Order string
		Count int64
		Keys  []string
	}{
		Ctx:   ctx,
		Order: order,
		Count: count,
		Keys:  keys,
	}
	mock.lockZMPop.Lock()
	mock.calls.ZMPop = append(mock.calls.ZMPop, callInfo)
	mock.lockZMPop.Unlock()
	return mock.ZMPopFunc(ctx, order, count, keys...)
}

// ZMPopCalls gets all the calls that were made to ZMPop.
// Check the length with:
//
//	len(mockedCmdable.ZMPopCalls())
func (mock *MoqCmdable) ZMPopCalls() []struct {
	Ctx   context.Context
	Order string
	Count int64
	Keys  []string
} {
	var calls []struct {
		Ctx   context.Context
		Order string
		Count int64
		Keys  []string
	}
	mock.lockZMPop.RLock()
	calls = mock.calls.ZMPop
	mock.lockZMPop.RUnlock()
	return calls
}

// ResetZMPopCalls reset all the calls that were made to ZMPop.
func (mock *MoqCmdable) ResetZMPopCalls() {
	mock.lockZMPop.Lock()
	mock.calls.ZMPop = nil
	mock.lockZMPop.Unlock()
}

// ZMScore calls ZMScoreFunc.
func (mock *MoqCmdable) ZMScore(ctx context.Context, key string, members ...string) *redis.FloatSliceCmd {
	if mock.ZMScoreFunc == nil {
		panic("MoqCmdable.ZMScoreFunc: method is nil but Cmdable.ZMScore was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Key     string
		Members []string
	}{
		Ctx:     ctx,
		Key:     key,
		Members: members,
	}
	mock.lockZMScore.Lock()
	mock.calls.ZMScore = append(mock.calls.ZMScore, callInfo)
	mock.lockZMScore.Unlock()
	return mock.ZMScoreFunc(ctx, key, members...)
}

// ZMScoreCalls gets all the calls that were made to ZMScore.
// Check the length with:
//
//	len(mockedCmdable.ZMScoreCalls())
func (mock *MoqCmdable) ZMScoreCalls() []struct {
	Ctx     context.Context
	Key     string
	Members []string
} {
	var calls []struct {
		Ctx     context.Context
		Key     string
		Members []string
	}
	mock.lockZMScore.RLock()
	calls = mock.calls.ZMScore
	mock.lockZMScore.RUnlock()
	return calls
}

// ResetZMScoreCalls reset all the calls that were made to ZMScore.
func (mock *MoqCmdable) ResetZMScoreCalls() {
	mock.lockZMScore.Lock()
	mock.calls.ZMScore = nil
	mock.lockZMScore.Unlock()
}

// ZPopMax calls ZPopMaxFunc.
func (mock *MoqCmdable) ZPopMax(ctx context.Context, key string, count ...int64) *redis.ZSliceCmd {
	if mock.ZPopMaxFunc == nil {
		panic("MoqCmdable.ZPopMaxFunc: method is nil but Cmdable.ZPopMax was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Count []int64
	}{
		Ctx:   ctx,
		Key:   key,
		Count: count,
	}
	mock.lockZPopMax.Lock()
	mock.calls.ZPopMax = append(mock.calls.ZPopMax, callInfo)
	mock.lockZPopMax.Unlock()
	return mock.ZPopMaxFunc(ctx, key, count...)
}

// ZPopMaxCalls gets all the calls that were made to ZPopMax.
// Check the length with:
//
//	len(mockedCmdable.ZPopMaxCalls())
func (mock *MoqCmdable) ZPopMaxCalls() []struct {
	Ctx   context.Context
	Key   string
	Count []int64
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Count []int64
	}
	mock.lockZPopMax.RLock()
	calls = mock.calls.ZPopMax
	mock.lockZPopMax.RUnlock()
	return calls
}

// ResetZPopMaxCalls reset all the calls that were made to ZPopMax.
func (mock *MoqCmdable) ResetZPopMaxCalls() {
	mock.lockZPopMax.Lock()
	mock.calls.ZPopMax = nil
	mock.lockZPopMax.Unlock()
}

// ZPopMin calls ZPopMinFunc.
func (mock *MoqCmdable) ZPopMin(ctx context.Context, key string, count ...int64) *redis.ZSliceCmd {
	if mock.ZPopMinFunc == nil {
		panic("MoqCmdable.ZPopMinFunc: method is nil but Cmdable.ZPopMin was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Count []int64
	}{
		Ctx:   ctx,
		Key:   key,
		Count: count,
	}
	mock.lockZPopMin.Lock()
	mock.calls.ZPopMin = append(mock.calls.ZPopMin, callInfo)
	mock.lockZPopMin.Unlock()
	return mock.ZPopMinFunc(ctx, key, count...)
}

// ZPopMinCalls gets all the calls that were made to ZPopMin.
// Check the length with:
//
//	len(mockedCmdable.ZPopMinCalls())
func (mock *MoqCmdable) ZPopMinCalls() []struct {
	Ctx   context.Context
	Key   string
	Count []int64
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Count []int64
	}
	mock.lockZPopMin.RLock()
	calls = mock.calls.ZPopMin
	mock.lockZPopMin.RUnlock()
	return calls
}

// ResetZPopMinCalls reset all the calls that were made to ZPopMin.
func (mock *MoqCmdable) ResetZPopMinCalls() {
	mock.lockZPopMin.Lock()
	mock.calls.ZPopMin = nil
	mock.lockZPopMin.Unlock()
}

// ZRandMember calls ZRandMemberFunc.
func (mock *MoqCmdable) ZRandMember(ctx context.Context, key string, count int) *redis.StringSliceCmd {
	if mock.ZRandMemberFunc == nil {
		panic("MoqCmdable.ZRandMemberFunc: method is nil but Cmdable.ZRandMember was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Count int
	}{
		Ctx:   ctx,
		Key:   key,
		Count: count,
	}
	mock.lockZRandMember.Lock()
	mock.calls.ZRandMember = append(mock.calls.ZRandMember, callInfo)
	mock.lockZRandMember.Unlock()
	return mock.ZRandMemberFunc(ctx, key, count)
}

// ZRandMemberCalls gets all the calls that were made to ZRandMember.
// Check the length with:
//
//	len(mockedCmdable.ZRandMemberCalls())
func (mock *MoqCmdable) ZRandMemberCalls() []struct {
	Ctx   context.Context
	Key   string
	Count int
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Count int
	}
	mock.lockZRandMember.RLock()
	calls = mock.calls.ZRandMember
	mock.lockZRandMember.RUnlock()
	return calls
}

// ResetZRandMemberCalls reset all the calls that were made to ZRandMember.
func (mock *MoqCmdable) ResetZRandMemberCalls() {
	mock.lockZRandMember.Lock()
	mock.calls.ZRandMember = nil
	mock.lockZRandMember.Unlock()
}

// ZRandMemberWithScores calls ZRandMemberWithScoresFunc.
func (mock *MoqCmdable) ZRandMemberWithScores(ctx context.Context, key string, count int) *redis.ZSliceCmd {
	if mock.ZRandMemberWithScoresFunc == nil {
		panic("MoqCmdable.ZRandMemberWithScoresFunc: method is nil but Cmdable.ZRandMemberWithScores was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Count int
	}{
		Ctx:   ctx,
		Key:   key,
		Count: count,
	}
	mock.lockZRandMemberWithScores.Lock()
	mock.calls.ZRandMemberWithScores = append(mock.calls.ZRandMemberWithScores, callInfo)
	mock.lockZRandMemberWithScores.Unlock()
	return mock.ZRandMemberWithScoresFunc(ctx, key, count)
}

// ZRandMemberWithScoresCalls gets all the calls that were made to ZRandMemberWithScores.
// Check the length with:
//
//	len(mockedCmdable.ZRandMemberWithScoresCalls())
func (mock *MoqCmdable) ZRandMemberWithScoresCalls() []struct {
	Ctx   context.Context
	Key   string
	Count int
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Count int
	}
	mock.lockZRandMemberWithScores.RLock()
	calls = mock.calls.ZRandMemberWithScores
	mock.lockZRandMemberWithScores.RUnlock()
	return calls
}

// ResetZRandMemberWithScoresCalls reset all the calls that were made to ZRandMemberWithScores.
func (mock *MoqCmdable) ResetZRandMemberWithScoresCalls() {
	mock.lockZRandMemberWithScores.Lock()
	mock.calls.ZRandMemberWithScores = nil
	mock.lockZRandMemberWithScores.Unlock()
}

// ZRange calls ZRangeFunc.
func (mock *MoqCmdable) ZRange(ctx context.Context, key string, start int64, stop int64) *redis.StringSliceCmd {
	if mock.ZRangeFunc == nil {
		panic("MoqCmdable.ZRangeFunc: method is nil but Cmdable.ZRange was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Start int64
		Stop  int64
	}{
		Ctx:   ctx,
		Key:   key,
		Start: start,
		Stop:  stop,
	}
	mock.lockZRange.Lock()
	mock.calls.ZRange = append(mock.calls.ZRange, callInfo)
	mock.lockZRange.Unlock()
	return mock.ZRangeFunc(ctx, key, start, stop)
}

// ZRangeCalls gets all the calls that were made to ZRange.
// Check the length with:
//
//	len(mockedCmdable.ZRangeCalls())
func (mock *MoqCmdable) ZRangeCalls() []struct {
	Ctx   context.Context
	Key   string
	Start int64
	Stop  int64
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Start int64
		Stop  int64
	}
	mock.lockZRange.RLock()
	calls = mock.calls.ZRange
	mock.lockZRange.RUnlock()
	return calls
}

// ResetZRangeCalls reset all the calls that were made to ZRange.
func (mock *MoqCmdable) ResetZRangeCalls() {
	mock.lockZRange.Lock()
	mock.calls.ZRange = nil
	mock.lockZRange.Unlock()
}

// ZRangeArgs calls ZRangeArgsFunc.
func (mock *MoqCmdable) ZRangeArgs(ctx context.Context, z redis.ZRangeArgs) *redis.StringSliceCmd {
	if mock.ZRangeArgsFunc == nil {
		panic("MoqCmdable.ZRangeArgsFunc: method is nil but Cmdable.ZRangeArgs was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Z   redis.ZRangeArgs
	}{
		Ctx: ctx,
		Z:   z,
	}
	mock.lockZRangeArgs.Lock()
	mock.calls.ZRangeArgs = append(mock.calls.ZRangeArgs, callInfo)
	mock.lockZRangeArgs.Unlock()
	return mock.ZRangeArgsFunc(ctx, z)
}

// ZRangeArgsCalls gets all the calls that were made to ZRangeArgs.
// Check the length with:
//
//	len(mockedCmdable.ZRangeArgsCalls())
func (mock *MoqCmdable) ZRangeArgsCalls() []struct {
	Ctx context.Context
	Z   redis.ZRangeArgs
} {
	var calls []struct {
		Ctx context.Context
		Z   redis.ZRangeArgs
	}
	mock.lockZRangeArgs.RLock()
	calls = mock.calls.ZRangeArgs
	mock.lockZRangeArgs.RUnlock()
	return calls
}

// ResetZRangeArgsCalls reset all the calls that were made to ZRangeArgs.
func (mock *MoqCmdable) ResetZRangeArgsCalls() {
	mock.lockZRangeArgs.Lock()
	mock.calls.ZRangeArgs = nil
	mock.lockZRangeArgs.Unlock()
}

// ZRangeArgsWithScores calls ZRangeArgsWithScoresFunc.
func (mock *MoqCmdable) ZRangeArgsWithScores(ctx context.Context, z redis.ZRangeArgs) *redis.ZSliceCmd {
	if mock.ZRangeArgsWithScoresFunc == nil {
		panic("MoqCmdable.ZRangeArgsWithScoresFunc: method is nil but Cmdable.ZRangeArgsWithScores was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Z   redis.ZRangeArgs
	}{
		Ctx: ctx,
		Z:   z,
	}
	mock.lockZRangeArgsWithScores.Lock()
	mock.calls.ZRangeArgsWithScores = append(mock.calls.ZRangeArgsWithScores, callInfo)
	mock.lockZRangeArgsWithScores.Unlock()
	return mock.ZRangeArgsWithScoresFunc(ctx, z)
}

// ZRangeArgsWithScoresCalls gets all the calls that were made to ZRangeArgsWithScores.
// Check the length with:
//
//	len(mockedCmdable.ZRangeArgsWithScoresCalls())
func (mock *MoqCmdable) ZRangeArgsWithScoresCalls() []struct {
	Ctx context.Context
	Z   redis.ZRangeArgs
} {
	var calls []struct {
		Ctx context.Context
		Z   redis.ZRangeArgs
	}
	mock.lockZRangeArgsWithScores.RLock()
	calls = mock.calls.ZRangeArgsWithScores
	mock.lockZRangeArgsWithScores.RUnlock()
	return calls
}

// ResetZRangeArgsWithScoresCalls reset all the calls that were made to ZRangeArgsWithScores.
func (mock *MoqCmdable) ResetZRangeArgsWithScoresCalls() {
	mock.lockZRangeArgsWithScores.Lock()
	mock.calls.ZRangeArgsWithScores = nil
	mock.lockZRangeArgsWithScores.Unlock()
}

// ZRangeByLex calls ZRangeByLexFunc.
func (mock *MoqCmdable) ZRangeByLex(ctx context.Context, key string, opt *redis.ZRangeBy) *redis.StringSliceCmd {
	if mock.ZRangeByLexFunc == nil {
		panic("MoqCmdable.ZRangeByLexFunc: method is nil but Cmdable.ZRangeByLex was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
		Opt *redis.ZRangeBy
	}{
		Ctx: ctx,
		Key: key,
		Opt: opt,
	}
	mock.lockZRangeByLex.Lock()
	mock.calls.ZRangeByLex = append(mock.calls.ZRangeByLex, callInfo)
	mock.lockZRangeByLex.Unlock()
	return mock.ZRangeByLexFunc(ctx, key, opt)
}

// ZRangeByLexCalls gets all the calls that were made to ZRangeByLex.
// Check the length with:
//
//	len(mockedCmdable.ZRangeByLexCalls())
func (mock *MoqCmdable) ZRangeByLexCalls() []struct {
	Ctx context.Context
	Key string
	Opt *redis.ZRangeBy
} {
	var calls []struct {
		Ctx context.Context
		Key string
		Opt *redis.ZRangeBy
	}
	mock.lockZRangeByLex.RLock()
	calls = mock.calls.ZRangeByLex
	mock.lockZRangeByLex.RUnlock()
	return calls
}

// ResetZRangeByLexCalls reset all the calls that were made to ZRangeByLex.
func (mock *MoqCmdable) ResetZRangeByLexCalls() {
	mock.lockZRangeByLex.Lock()
	mock.calls.ZRangeByLex = nil
	mock.lockZRangeByLex.Unlock()
}

// ZRangeByScore calls ZRangeByScoreFunc.
func (mock *MoqCmdable) ZRangeByScore(ctx context.Context, key string, opt *redis.ZRangeBy) *redis.StringSliceCmd {
	if mock.ZRangeByScoreFunc == nil {
		panic("MoqCmdable.ZRangeByScoreFunc: method is nil but Cmdable.ZRangeByScore was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
		Opt *redis.ZRangeBy
	}{
		Ctx: ctx,
		Key: key,
		Opt: opt,
	}
	mock.lockZRangeByScore.Lock()
	mock.calls.ZRangeByScore = append(mock.calls.ZRangeByScore, callInfo)
	mock.lockZRangeByScore.Unlock()
	return mock.ZRangeByScoreFunc(ctx, key, opt)
}

// ZRangeByScoreCalls gets all the calls that were made to ZRangeByScore.
// Check the length with:
//
//	len(mockedCmdable.ZRangeByScoreCalls())
func (mock *MoqCmdable) ZRangeByScoreCalls() []struct {
	Ctx context.Context
	Key string
	Opt *redis.ZRangeBy
} {
	var calls []struct {
		Ctx context.Context
		Key string
		Opt *redis.ZRangeBy
	}
	mock.lockZRangeByScore.RLock()
	calls = mock.calls.ZRangeByScore
	mock.lockZRangeByScore.RUnlock()
	return calls
}

// ResetZRangeByScoreCalls reset all the calls that were made to ZRangeByScore.
func (mock *MoqCmdable) ResetZRangeByScoreCalls() {
	mock.lockZRangeByScore.Lock()
	mock.calls.ZRangeByScore = nil
	mock.lockZRangeByScore.Unlock()
}

// ZRangeByScoreWithScores calls ZRangeByScoreWithScoresFunc.
func (mock *MoqCmdable) ZRangeByScoreWithScores(ctx context.Context, key string, opt *redis.ZRangeBy) *redis.ZSliceCmd {
	if mock.ZRangeByScoreWithScoresFunc == nil {
		panic("MoqCmdable.ZRangeByScoreWithScoresFunc: method is nil but Cmdable.ZRangeByScoreWithScores was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
		Opt *redis.ZRangeBy
	}{
		Ctx: ctx,
		Key: key,
		Opt: opt,
	}
	mock.lockZRangeByScoreWithScores.Lock()
	mock.calls.ZRangeByScoreWithScores = append(mock.calls.ZRangeByScoreWithScores, callInfo)
	mock.lockZRangeByScoreWithScores.Unlock()
	return mock.ZRangeByScoreWithScoresFunc(ctx, key, opt)
}

// ZRangeByScoreWithScoresCalls gets all the calls that were made to ZRangeByScoreWithScores.
// Check the length with:
//
//	len(mockedCmdable.ZRangeByScoreWithScoresCalls())
func (mock *MoqCmdable) ZRangeByScoreWithScoresCalls() []struct {
	Ctx context.Context
	Key string
	Opt *redis.ZRangeBy
} {
	var calls []struct {
		Ctx context.Context
		Key string
		Opt *redis.ZRangeBy
	}
	mock.lockZRangeByScoreWithScores.RLock()
	calls = mock.calls.ZRangeByScoreWithScores
	mock.lockZRangeByScoreWithScores.RUnlock()
	return calls
}

// ResetZRangeByScoreWithScoresCalls reset all the calls that were made to ZRangeByScoreWithScores.
func (mock *MoqCmdable) ResetZRangeByScoreWithScoresCalls() {
	mock.lockZRangeByScoreWithScores.Lock()
	mock.calls.ZRangeByScoreWithScores = nil
	mock.lockZRangeByScoreWithScores.Unlock()
}

// ZRangeStore calls ZRangeStoreFunc.
func (mock *MoqCmdable) ZRangeStore(ctx context.Context, dst string, z redis.ZRangeArgs) *redis.IntCmd {
	if mock.ZRangeStoreFunc == nil {
		panic("MoqCmdable.ZRangeStoreFunc: method is nil but Cmdable.ZRangeStore was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Dst string
		Z   redis.ZRangeArgs
	}{
		Ctx: ctx,
		Dst: dst,
		Z:   z,
	}
	mock.lockZRangeStore.Lock()
	mock.calls.ZRangeStore = append(mock.calls.ZRangeStore, callInfo)
	mock.lockZRangeStore.Unlock()
	return mock.ZRangeStoreFunc(ctx, dst, z)
}

// ZRangeStoreCalls gets all the calls that were made to ZRangeStore.
// Check the length with:
//
//	len(mockedCmdable.ZRangeStoreCalls())
func (mock *MoqCmdable) ZRangeStoreCalls() []struct {
	Ctx context.Context
	Dst string
	Z   redis.ZRangeArgs
} {
	var calls []struct {
		Ctx context.Context
		Dst string
		Z   redis.ZRangeArgs
	}
	mock.lockZRangeStore.RLock()
	calls = mock.calls.ZRangeStore
	mock.lockZRangeStore.RUnlock()
	return calls
}

// ResetZRangeStoreCalls reset all the calls that were made to ZRangeStore.
func (mock *MoqCmdable) ResetZRangeStoreCalls() {
	mock.lockZRangeStore.Lock()
	mock.calls.ZRangeStore = nil
	mock.lockZRangeStore.Unlock()
}

// ZRangeWithScores calls ZRangeWithScoresFunc.
func (mock *MoqCmdable) ZRangeWithScores(ctx context.Context, key string, start int64, stop int64) *redis.ZSliceCmd {
	if mock.ZRangeWithScoresFunc == nil {
		panic("MoqCmdable.ZRangeWithScoresFunc: method is nil but Cmdable.ZRangeWithScores was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Start int64
		Stop  int64
	}{
		Ctx:   ctx,
		Key:   key,
		Start: start,
		Stop:  stop,
	}
	mock.lockZRangeWithScores.Lock()
	mock.calls.ZRangeWithScores = append(mock.calls.ZRangeWithScores, callInfo)
	mock.lockZRangeWithScores.Unlock()
	return mock.ZRangeWithScoresFunc(ctx, key, start, stop)
}

// ZRangeWithScoresCalls gets all the calls that were made to ZRangeWithScores.
// Check the length with:
//
//	len(mockedCmdable.ZRangeWithScoresCalls())
func (mock *MoqCmdable) ZRangeWithScoresCalls() []struct {
	Ctx   context.Context
	Key   string
	Start int64
	Stop  int64
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Start int64
		Stop  int64
	}
	mock.lockZRangeWithScores.RLock()
	calls = mock.calls.ZRangeWithScores
	mock.lockZRangeWithScores.RUnlock()
	return calls
}

// ResetZRangeWithScoresCalls reset all the calls that were made to ZRangeWithScores.
func (mock *MoqCmdable) ResetZRangeWithScoresCalls() {
	mock.lockZRangeWithScores.Lock()
	mock.calls.ZRangeWithScores = nil
	mock.lockZRangeWithScores.Unlock()
}

// ZRank calls ZRankFunc.
func (mock *MoqCmdable) ZRank(ctx context.Context, key string, member string) *redis.IntCmd {
	if mock.ZRankFunc == nil {
		panic("MoqCmdable.ZRankFunc: method is nil but Cmdable.ZRank was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		Member string
	}{
		Ctx:    ctx,
		Key:    key,
		Member: member,
	}
	mock.lockZRank.Lock()
	mock.calls.ZRank = append(mock.calls.ZRank, callInfo)
	mock.lockZRank.Unlock()
	return mock.ZRankFunc(ctx, key, member)
}

// ZRankCalls gets all the calls that were made to ZRank.
// Check the length with:
//
//	len(mockedCmdable.ZRankCalls())
func (mock *MoqCmdable) ZRankCalls() []struct {
	Ctx    context.Context
	Key    string
	Member string
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		Member string
	}
	mock.lockZRank.RLock()
	calls = mock.calls.ZRank
	mock.lockZRank.RUnlock()
	return calls
}

// ResetZRankCalls reset all the calls that were made to ZRank.
func (mock *MoqCmdable) ResetZRankCalls() {
	mock.lockZRank.Lock()
	mock.calls.ZRank = nil
	mock.lockZRank.Unlock()
}

// ZRankWithScore calls ZRankWithScoreFunc.
func (mock *MoqCmdable) ZRankWithScore(ctx context.Context, key string, member string) *redis.RankWithScoreCmd {
	if mock.ZRankWithScoreFunc == nil {
		panic("MoqCmdable.ZRankWithScoreFunc: method is nil but Cmdable.ZRankWithScore was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		Member string
	}{
		Ctx:    ctx,
		Key:    key,
		Member: member,
	}
	mock.lockZRankWithScore.Lock()
	mock.calls.ZRankWithScore = append(mock.calls.ZRankWithScore, callInfo)
	mock.lockZRankWithScore.Unlock()
	return mock.ZRankWithScoreFunc(ctx, key, member)
}

// ZRankWithScoreCalls gets all the calls that were made to ZRankWithScore.
// Check the length with:
//
//	len(mockedCmdable.ZRankWithScoreCalls())
func (mock *MoqCmdable) ZRankWithScoreCalls() []struct {
	Ctx    context.Context
	Key    string
	Member string
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		Member string
	}
	mock.lockZRankWithScore.RLock()
	calls = mock.calls.ZRankWithScore
	mock.lockZRankWithScore.RUnlock()
	return calls
}

// ResetZRankWithScoreCalls reset all the calls that were made to ZRankWithScore.
func (mock *MoqCmdable) ResetZRankWithScoreCalls() {
	mock.lockZRankWithScore.Lock()
	mock.calls.ZRankWithScore = nil
	mock.lockZRankWithScore.Unlock()
}

// ZRem calls ZRemFunc.
func (mock *MoqCmdable) ZRem(ctx context.Context, key string, members ...interface{}) *redis.IntCmd {
	if mock.ZRemFunc == nil {
		panic("MoqCmdable.ZRemFunc: method is nil but Cmdable.ZRem was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Key     string
		Members []interface{}
	}{
		Ctx:     ctx,
		Key:     key,
		Members: members,
	}
	mock.lockZRem.Lock()
	mock.calls.ZRem = append(mock.calls.ZRem, callInfo)
	mock.lockZRem.Unlock()
	return mock.ZRemFunc(ctx, key, members...)
}

// ZRemCalls gets all the calls that were made to ZRem.
// Check the length with:
//
//	len(mockedCmdable.ZRemCalls())
func (mock *MoqCmdable) ZRemCalls() []struct {
	Ctx     context.Context
	Key     string
	Members []interface{}
} {
	var calls []struct {
		Ctx     context.Context
		Key     string
		Members []interface{}
	}
	mock.lockZRem.RLock()
	calls = mock.calls.ZRem
	mock.lockZRem.RUnlock()
	return calls
}

// ResetZRemCalls reset all the calls that were made to ZRem.
func (mock *MoqCmdable) ResetZRemCalls() {
	mock.lockZRem.Lock()
	mock.calls.ZRem = nil
	mock.lockZRem.Unlock()
}

// ZRemRangeByLex calls ZRemRangeByLexFunc.
func (mock *MoqCmdable) ZRemRangeByLex(ctx context.Context, key string, min string, max string) *redis.IntCmd {
	if mock.ZRemRangeByLexFunc == nil {
		panic("MoqCmdable.ZRemRangeByLexFunc: method is nil but Cmdable.ZRemRangeByLex was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
		Min string
		Max string
	}{
		Ctx: ctx,
		Key: key,
		Min: min,
		Max: max,
	}
	mock.lockZRemRangeByLex.Lock()
	mock.calls.ZRemRangeByLex = append(mock.calls.ZRemRangeByLex, callInfo)
	mock.lockZRemRangeByLex.Unlock()
	return mock.ZRemRangeByLexFunc(ctx, key, min, max)
}

// ZRemRangeByLexCalls gets all the calls that were made to ZRemRangeByLex.
// Check the length with:
//
//	len(mockedCmdable.ZRemRangeByLexCalls())
func (mock *MoqCmdable) ZRemRangeByLexCalls() []struct {
	Ctx context.Context
	Key string
	Min string
	Max string
} {
	var calls []struct {
		Ctx context.Context
		Key string
		Min string
		Max string
	}
	mock.lockZRemRangeByLex.RLock()
	calls = mock.calls.ZRemRangeByLex
	mock.lockZRemRangeByLex.RUnlock()
	return calls
}

// ResetZRemRangeByLexCalls reset all the calls that were made to ZRemRangeByLex.
func (mock *MoqCmdable) ResetZRemRangeByLexCalls() {
	mock.lockZRemRangeByLex.Lock()
	mock.calls.ZRemRangeByLex = nil
	mock.lockZRemRangeByLex.Unlock()
}

// ZRemRangeByRank calls ZRemRangeByRankFunc.
func (mock *MoqCmdable) ZRemRangeByRank(ctx context.Context, key string, start int64, stop int64) *redis.IntCmd {
	if mock.ZRemRangeByRankFunc == nil {
		panic("MoqCmdable.ZRemRangeByRankFunc: method is nil but Cmdable.ZRemRangeByRank was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Start int64
		Stop  int64
	}{
		Ctx:   ctx,
		Key:   key,
		Start: start,
		Stop:  stop,
	}
	mock.lockZRemRangeByRank.Lock()
	mock.calls.ZRemRangeByRank = append(mock.calls.ZRemRangeByRank, callInfo)
	mock.lockZRemRangeByRank.Unlock()
	return mock.ZRemRangeByRankFunc(ctx, key, start, stop)
}

// ZRemRangeByRankCalls gets all the calls that were made to ZRemRangeByRank.
// Check the length with:
//
//	len(mockedCmdable.ZRemRangeByRankCalls())
func (mock *MoqCmdable) ZRemRangeByRankCalls() []struct {
	Ctx   context.Context
	Key   string
	Start int64
	Stop  int64
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Start int64
		Stop  int64
	}
	mock.lockZRemRangeByRank.RLock()
	calls = mock.calls.ZRemRangeByRank
	mock.lockZRemRangeByRank.RUnlock()
	return calls
}

// ResetZRemRangeByRankCalls reset all the calls that were made to ZRemRangeByRank.
func (mock *MoqCmdable) ResetZRemRangeByRankCalls() {
	mock.lockZRemRangeByRank.Lock()
	mock.calls.ZRemRangeByRank = nil
	mock.lockZRemRangeByRank.Unlock()
}

// ZRemRangeByScore calls ZRemRangeByScoreFunc.
func (mock *MoqCmdable) ZRemRangeByScore(ctx context.Context, key string, min string, max string) *redis.IntCmd {
	if mock.ZRemRangeByScoreFunc == nil {
		panic("MoqCmdable.ZRemRangeByScoreFunc: method is nil but Cmdable.ZRemRangeByScore was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
		Min string
		Max string
	}{
		Ctx: ctx,
		Key: key,
		Min: min,
		Max: max,
	}
	mock.lockZRemRangeByScore.Lock()
	mock.calls.ZRemRangeByScore = append(mock.calls.ZRemRangeByScore, callInfo)
	mock.lockZRemRangeByScore.Unlock()
	return mock.ZRemRangeByScoreFunc(ctx, key, min, max)
}

// ZRemRangeByScoreCalls gets all the calls that were made to ZRemRangeByScore.
// Check the length with:
//
//	len(mockedCmdable.ZRemRangeByScoreCalls())
func (mock *MoqCmdable) ZRemRangeByScoreCalls() []struct {
	Ctx context.Context
	Key string
	Min string
	Max string
} {
	var calls []struct {
		Ctx context.Context
		Key string
		Min string
		Max string
	}
	mock.lockZRemRangeByScore.RLock()
	calls = mock.calls.ZRemRangeByScore
	mock.lockZRemRangeByScore.RUnlock()
	return calls
}

// ResetZRemRangeByScoreCalls reset all the calls that were made to ZRemRangeByScore.
func (mock *MoqCmdable) ResetZRemRangeByScoreCalls() {
	mock.lockZRemRangeByScore.Lock()
	mock.calls.ZRemRangeByScore = nil
	mock.lockZRemRangeByScore.Unlock()
}

// ZRevRange calls ZRevRangeFunc.
func (mock *MoqCmdable) ZRevRange(ctx context.Context, key string, start int64, stop int64) *redis.StringSliceCmd {
	if mock.ZRevRangeFunc == nil {
		panic("MoqCmdable.ZRevRangeFunc: method is nil but Cmdable.ZRevRange was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Start int64
		Stop  int64
	}{
		Ctx:   ctx,
		Key:   key,
		Start: start,
		Stop:  stop,
	}
	mock.lockZRevRange.Lock()
	mock.calls.ZRevRange = append(mock.calls.ZRevRange, callInfo)
	mock.lockZRevRange.Unlock()
	return mock.ZRevRangeFunc(ctx, key, start, stop)
}

// ZRevRangeCalls gets all the calls that were made to ZRevRange.
// Check the length with:
//
//	len(mockedCmdable.ZRevRangeCalls())
func (mock *MoqCmdable) ZRevRangeCalls() []struct {
	Ctx   context.Context
	Key   string
	Start int64
	Stop  int64
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Start int64
		Stop  int64
	}
	mock.lockZRevRange.RLock()
	calls = mock.calls.ZRevRange
	mock.lockZRevRange.RUnlock()
	return calls
}

// ResetZRevRangeCalls reset all the calls that were made to ZRevRange.
func (mock *MoqCmdable) ResetZRevRangeCalls() {
	mock.lockZRevRange.Lock()
	mock.calls.ZRevRange = nil
	mock.lockZRevRange.Unlock()
}

// ZRevRangeByLex calls ZRevRangeByLexFunc.
func (mock *MoqCmdable) ZRevRangeByLex(ctx context.Context, key string, opt *redis.ZRangeBy) *redis.StringSliceCmd {
	if mock.ZRevRangeByLexFunc == nil {
		panic("MoqCmdable.ZRevRangeByLexFunc: method is nil but Cmdable.ZRevRangeByLex was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
		Opt *redis.ZRangeBy
	}{
		Ctx: ctx,
		Key: key,
		Opt: opt,
	}
	mock.lockZRevRangeByLex.Lock()
	mock.calls.ZRevRangeByLex = append(mock.calls.ZRevRangeByLex, callInfo)
	mock.lockZRevRangeByLex.Unlock()
	return mock.ZRevRangeByLexFunc(ctx, key, opt)
}

// ZRevRangeByLexCalls gets all the calls that were made to ZRevRangeByLex.
// Check the length with:
//
//	len(mockedCmdable.ZRevRangeByLexCalls())
func (mock *MoqCmdable) ZRevRangeByLexCalls() []struct {
	Ctx context.Context
	Key string
	Opt *redis.ZRangeBy
} {
	var calls []struct {
		Ctx context.Context
		Key string
		Opt *redis.ZRangeBy
	}
	mock.lockZRevRangeByLex.RLock()
	calls = mock.calls.ZRevRangeByLex
	mock.lockZRevRangeByLex.RUnlock()
	return calls
}

// ResetZRevRangeByLexCalls reset all the calls that were made to ZRevRangeByLex.
func (mock *MoqCmdable) ResetZRevRangeByLexCalls() {
	mock.lockZRevRangeByLex.Lock()
	mock.calls.ZRevRangeByLex = nil
	mock.lockZRevRangeByLex.Unlock()
}

// ZRevRangeByScore calls ZRevRangeByScoreFunc.
func (mock *MoqCmdable) ZRevRangeByScore(ctx context.Context, key string, opt *redis.ZRangeBy) *redis.StringSliceCmd {
	if mock.ZRevRangeByScoreFunc == nil {
		panic("MoqCmdable.ZRevRangeByScoreFunc: method is nil but Cmdable.ZRevRangeByScore was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
		Opt *redis.ZRangeBy
	}{
		Ctx: ctx,
		Key: key,
		Opt: opt,
	}
	mock.lockZRevRangeByScore.Lock()
	mock.calls.ZRevRangeByScore = append(mock.calls.ZRevRangeByScore, callInfo)
	mock.lockZRevRangeByScore.Unlock()
	return mock.ZRevRangeByScoreFunc(ctx, key, opt)
}

// ZRevRangeByScoreCalls gets all the calls that were made to ZRevRangeByScore.
// Check the length with:
//
//	len(mockedCmdable.ZRevRangeByScoreCalls())
func (mock *MoqCmdable) ZRevRangeByScoreCalls() []struct {
	Ctx context.Context
	Key string
	Opt *redis.ZRangeBy
} {
	var calls []struct {
		Ctx context.Context
		Key string
		Opt *redis.ZRangeBy
	}
	mock.lockZRevRangeByScore.RLock()
	calls = mock.calls.ZRevRangeByScore
	mock.lockZRevRangeByScore.RUnlock()
	return calls
}

// ResetZRevRangeByScoreCalls reset all the calls that were made to ZRevRangeByScore.
func (mock *MoqCmdable) ResetZRevRangeByScoreCalls() {
	mock.lockZRevRangeByScore.Lock()
	mock.calls.ZRevRangeByScore = nil
	mock.lockZRevRangeByScore.Unlock()
}

// ZRevRangeByScoreWithScores calls ZRevRangeByScoreWithScoresFunc.
func (mock *MoqCmdable) ZRevRangeByScoreWithScores(ctx context.Context, key string, opt *redis.ZRangeBy) *redis.ZSliceCmd {
	if mock.ZRevRangeByScoreWithScoresFunc == nil {
		panic("MoqCmdable.ZRevRangeByScoreWithScoresFunc: method is nil but Cmdable.ZRevRangeByScoreWithScores was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
		Opt *redis.ZRangeBy
	}{
		Ctx: ctx,
		Key: key,
		Opt: opt,
	}
	mock.lockZRevRangeByScoreWithScores.Lock()
	mock.calls.ZRevRangeByScoreWithScores = append(mock.calls.ZRevRangeByScoreWithScores, callInfo)
	mock.lockZRevRangeByScoreWithScores.Unlock()
	return mock.ZRevRangeByScoreWithScoresFunc(ctx, key, opt)
}

// ZRevRangeByScoreWithScoresCalls gets all the calls that were made to ZRevRangeByScoreWithScores.
// Check the length with:
//
//	len(mockedCmdable.ZRevRangeByScoreWithScoresCalls())
func (mock *MoqCmdable) ZRevRangeByScoreWithScoresCalls() []struct {
	Ctx context.Context
	Key string
	Opt *redis.ZRangeBy
} {
	var calls []struct {
		Ctx context.Context
		Key string
		Opt *redis.ZRangeBy
	}
	mock.lockZRevRangeByScoreWithScores.RLock()
	calls = mock.calls.ZRevRangeByScoreWithScores
	mock.lockZRevRangeByScoreWithScores.RUnlock()
	return calls
}

// ResetZRevRangeByScoreWithScoresCalls reset all the calls that were made to ZRevRangeByScoreWithScores.
func (mock *MoqCmdable) ResetZRevRangeByScoreWithScoresCalls() {
	mock.lockZRevRangeByScoreWithScores.Lock()
	mock.calls.ZRevRangeByScoreWithScores = nil
	mock.lockZRevRangeByScoreWithScores.Unlock()
}

// ZRevRangeWithScores calls ZRevRangeWithScoresFunc.
func (mock *MoqCmdable) ZRevRangeWithScores(ctx context.Context, key string, start int64, stop int64) *redis.ZSliceCmd {
	if mock.ZRevRangeWithScoresFunc == nil {
		panic("MoqCmdable.ZRevRangeWithScoresFunc: method is nil but Cmdable.ZRevRangeWithScores was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Start int64
		Stop  int64
	}{
		Ctx:   ctx,
		Key:   key,
		Start: start,
		Stop:  stop,
	}
	mock.lockZRevRangeWithScores.Lock()
	mock.calls.ZRevRangeWithScores = append(mock.calls.ZRevRangeWithScores, callInfo)
	mock.lockZRevRangeWithScores.Unlock()
	return mock.ZRevRangeWithScoresFunc(ctx, key, start, stop)
}

// ZRevRangeWithScoresCalls gets all the calls that were made to ZRevRangeWithScores.
// Check the length with:
//
//	len(mockedCmdable.ZRevRangeWithScoresCalls())
func (mock *MoqCmdable) ZRevRangeWithScoresCalls() []struct {
	Ctx   context.Context
	Key   string
	Start int64
	Stop  int64
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Start int64
		Stop  int64
	}
	mock.lockZRevRangeWithScores.RLock()
	calls = mock.calls.ZRevRangeWithScores
	mock.lockZRevRangeWithScores.RUnlock()
	return calls
}

// ResetZRevRangeWithScoresCalls reset all the calls that were made to ZRevRangeWithScores.
func (mock *MoqCmdable) ResetZRevRangeWithScoresCalls() {
	mock.lockZRevRangeWithScores.Lock()
	mock.calls.ZRevRangeWithScores = nil
	mock.lockZRevRangeWithScores.Unlock()
}

// ZRevRank calls ZRevRankFunc.
func (mock *MoqCmdable) ZRevRank(ctx context.Context, key string, member string) *redis.IntCmd {
	if mock.ZRevRankFunc == nil {
		panic("MoqCmdable.ZRevRankFunc: method is nil but Cmdable.ZRevRank was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		Member string
	}{
		Ctx:    ctx,
		Key:    key,
		Member: member,
	}
	mock.lockZRevRank.Lock()
	mock.calls.ZRevRank = append(mock.calls.ZRevRank, callInfo)
	mock.lockZRevRank.Unlock()
	return mock.ZRevRankFunc(ctx, key, member)
}

// ZRevRankCalls gets all the calls that were made to ZRevRank.
// Check the length with:
//
//	len(mockedCmdable.ZRevRankCalls())
func (mock *MoqCmdable) ZRevRankCalls() []struct {
	Ctx    context.Context
	Key    string
	Member string
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		Member string
	}
	mock.lockZRevRank.RLock()
	calls = mock.calls.ZRevRank
	mock.lockZRevRank.RUnlock()
	return calls
}

// ResetZRevRankCalls reset all the calls that were made to ZRevRank.
func (mock *MoqCmdable) ResetZRevRankCalls() {
	mock.lockZRevRank.Lock()
	mock.calls.ZRevRank = nil
	mock.lockZRevRank.Unlock()
}

// ZRevRankWithScore calls ZRevRankWithScoreFunc.
func (mock *MoqCmdable) ZRevRankWithScore(ctx context.Context, key string, member string) *redis.RankWithScoreCmd {
	if mock.ZRevRankWithScoreFunc == nil {
		panic("MoqCmdable.ZRevRankWithScoreFunc: method is nil but Cmdable.ZRevRankWithScore was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		Member string
	}{
		Ctx:    ctx,
		Key:    key,
		Member: member,
	}
	mock.lockZRevRankWithScore.Lock()
	mock.calls.ZRevRankWithScore = append(mock.calls.ZRevRankWithScore, callInfo)
	mock.lockZRevRankWithScore.Unlock()
	return mock.ZRevRankWithScoreFunc(ctx, key, member)
}

// ZRevRankWithScoreCalls gets all the calls that were made to ZRevRankWithScore.
// Check the length with:
//
//	len(mockedCmdable.ZRevRankWithScoreCalls())
func (mock *MoqCmdable) ZRevRankWithScoreCalls() []struct {
	Ctx    context.Context
	Key    string
	Member string
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		Member string
	}
	mock.lockZRevRankWithScore.RLock()
	calls = mock.calls.ZRevRankWithScore
	mock.lockZRevRankWithScore.RUnlock()
	return calls
}

// ResetZRevRankWithScoreCalls reset all the calls that were made to ZRevRankWithScore.
func (mock *MoqCmdable) ResetZRevRankWithScoreCalls() {
	mock.lockZRevRankWithScore.Lock()
	mock.calls.ZRevRankWithScore = nil
	mock.lockZRevRankWithScore.Unlock()
}

// ZScan calls ZScanFunc.
func (mock *MoqCmdable) ZScan(ctx context.Context, key string, cursor uint64, match string, count int64) *redis.ScanCmd {
	if mock.ZScanFunc == nil {
		panic("MoqCmdable.ZScanFunc: method is nil but Cmdable.ZScan was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		Cursor uint64
		Match  string
		Count  int64
	}{
		Ctx:    ctx,
		Key:    key,
		Cursor: cursor,
		Match:  match,
		Count:  count,
	}
	mock.lockZScan.Lock()
	mock.calls.ZScan = append(mock.calls.ZScan, callInfo)
	mock.lockZScan.Unlock()
	return mock.ZScanFunc(ctx, key, cursor, match, count)
}

// ZScanCalls gets all the calls that were made to ZScan.
// Check the length with:
//
//	len(mockedCmdable.ZScanCalls())
func (mock *MoqCmdable) ZScanCalls() []struct {
	Ctx    context.Context
	Key    string
	Cursor uint64
	Match  string
	Count  int64
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		Cursor uint64
		Match  string
		Count  int64
	}
	mock.lockZScan.RLock()
	calls = mock.calls.ZScan
	mock.lockZScan.RUnlock()
	return calls
}

// ResetZScanCalls reset all the calls that were made to ZScan.
func (mock *MoqCmdable) ResetZScanCalls() {
	mock.lockZScan.Lock()
	mock.calls.ZScan = nil
	mock.lockZScan.Unlock()
}

// ZScore calls ZScoreFunc.
func (mock *MoqCmdable) ZScore(ctx context.Context, key string, member string) *redis.FloatCmd {
	if mock.ZScoreFunc == nil {
		panic("MoqCmdable.ZScoreFunc: method is nil but Cmdable.ZScore was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		Member string
	}{
		Ctx:    ctx,
		Key:    key,
		Member: member,
	}
	mock.lockZScore.Lock()
	mock.calls.ZScore = append(mock.calls.ZScore, callInfo)
	mock.lockZScore.Unlock()
	return mock.ZScoreFunc(ctx, key, member)
}

// ZScoreCalls gets all the calls that were made to ZScore.
// Check the length with:
//
//	len(mockedCmdable.ZScoreCalls())
func (mock *MoqCmdable) ZScoreCalls() []struct {
	Ctx    context.Context
	Key    string
	Member string
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		Member string
	}
	mock.lockZScore.RLock()
	calls = mock.calls.ZScore
	mock.lockZScore.RUnlock()
	return calls
}

// ResetZScoreCalls reset all the calls that were made to ZScore.
func (mock *MoqCmdable) ResetZScoreCalls() {
	mock.lockZScore.Lock()
	mock.calls.ZScore = nil
	mock.lockZScore.Unlock()
}

// ZUnion calls ZUnionFunc.
func (mock *MoqCmdable) ZUnion(ctx context.Context, store redis.ZStore) *redis.StringSliceCmd {
	if mock.ZUnionFunc == nil {
		panic("MoqCmdable.ZUnionFunc: method is nil but Cmdable.ZUnion was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Store redis.ZStore
	}{
		Ctx:   ctx,
		Store: store,
	}
	mock.lockZUnion.Lock()
	mock.calls.ZUnion = append(mock.calls.ZUnion, callInfo)
	mock.lockZUnion.Unlock()
	return mock.ZUnionFunc(ctx, store)
}

// ZUnionCalls gets all the calls that were made to ZUnion.
// Check the length with:
//
//	len(mockedCmdable.ZUnionCalls())
func (mock *MoqCmdable) ZUnionCalls() []struct {
	Ctx   context.Context
	Store redis.ZStore
} {
	var calls []struct {
		Ctx   context.Context
		Store redis.ZStore
	}
	mock.lockZUnion.RLock()
	calls = mock.calls.ZUnion
	mock.lockZUnion.RUnlock()
	return calls
}

// ResetZUnionCalls reset all the calls that were made to ZUnion.
func (mock *MoqCmdable) ResetZUnionCalls() {
	mock.lockZUnion.Lock()
	mock.calls.ZUnion = nil
	mock.lockZUnion.Unlock()
}

// ZUnionStore calls ZUnionStoreFunc.
func (mock *MoqCmdable) ZUnionStore(ctx context.Context, dest string, store *redis.ZStore) *redis.IntCmd {
	if mock.ZUnionStoreFunc == nil {
		panic("MoqCmdable.ZUnionStoreFunc: method is nil but Cmdable.ZUnionStore was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Dest  string
		Store *redis.ZStore
	}{
		Ctx:   ctx,
		Dest:  dest,
		Store: store,
	}
	mock.lockZUnionStore.Lock()
	mock.calls.ZUnionStore = append(mock.calls.ZUnionStore, callInfo)
	mock.lockZUnionStore.Unlock()
	return mock.ZUnionStoreFunc(ctx, dest, store)
}

// ZUnionStoreCalls gets all the calls that were made to ZUnionStore.
// Check the length with:
//
//	len(mockedCmdable.ZUnionStoreCalls())
func (mock *MoqCmdable) ZUnionStoreCalls() []struct {
	Ctx   context.Context
	Dest  string
	Store *redis.ZStore
} {
	var calls []struct {
		Ctx   context.Context
		Dest  string
		Store *redis.ZStore
	}
	mock.lockZUnionStore.RLock()
	calls = mock.calls.ZUnionStore
	mock.lockZUnionStore.RUnlock()
	return calls
}

// ResetZUnionStoreCalls reset all the calls that were made to ZUnionStore.
func (mock *MoqCmdable) ResetZUnionStoreCalls() {
	mock.lockZUnionStore.Lock()
	mock.calls.ZUnionStore = nil
	mock.lockZUnionStore.Unlock()
}

// ZUnionWithScores calls ZUnionWithScoresFunc.
func (mock *MoqCmdable) ZUnionWithScores(ctx context.Context, store redis.ZStore) *redis.ZSliceCmd {
	if mock.ZUnionWithScoresFunc == nil {
		panic("MoqCmdable.ZUnionWithScoresFunc: method is nil but Cmdable.ZUnionWithScores was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Store redis.ZStore
	}{
		Ctx:   ctx,
		Store: store,
	}
	mock.lockZUnionWithScores.Lock()
	mock.calls.ZUnionWithScores = append(mock.calls.ZUnionWithScores, callInfo)
	mock.lockZUnionWithScores.Unlock()
	return mock.ZUnionWithScoresFunc(ctx, store)
}

// ZUnionWithScoresCalls gets all the calls that were made to ZUnionWithScores.
// Check the length with:
//
//	len(mockedCmdable.ZUnionWithScoresCalls())
func (mock *MoqCmdable) ZUnionWithScoresCalls() []struct {
	Ctx   context.Context
	Store redis.ZStore
} {
	var calls []struct {
		Ctx   context.Context
		Store redis.ZStore
	}
	mock.lockZUnionWithScores.RLock()
	calls = mock.calls.ZUnionWithScores
	mock.lockZUnionWithScores.RUnlock()
	return calls
}

// ResetZUnionWithScoresCalls reset all the calls that were made to ZUnionWithScores.
func (mock *MoqCmdable) ResetZUnionWithScoresCalls() {
	mock.lockZUnionWithScores.Lock()
	mock.calls.ZUnionWithScores = nil
	mock.lockZUnionWithScores.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *MoqCmdable) ResetCalls() {
	mock.lockACLCat.Lock()
	mock.calls.ACLCat = nil
	mock.lockACLCat.Unlock()

	mock.lockACLCatArgs.Lock()
	mock.calls.ACLCatArgs = nil
	mock.lockACLCatArgs.Unlock()

	mock.lockACLDelUser.Lock()
	mock.calls.ACLDelUser = nil
	mock.lockACLDelUser.Unlock()

	mock.lockACLDryRun.Lock()
	mock.calls.ACLDryRun = nil
	mock.lockACLDryRun.Unlock()

	mock.lockACLGenPass.Lock()
	mock.calls.ACLGenPass = nil
	mock.lockACLGenPass.Unlock()

	mock.lockACLList.Lock()
	mock.calls.ACLList = nil
	mock.lockACLList.Unlock()

	mock.lockACLLog.Lock()
	mock.calls.ACLLog = nil
	mock.lockACLLog.Unlock()

	mock.lockACLLogReset.Lock()
	mock.calls.ACLLogReset = nil
	mock.lockACLLogReset.Unlock()

	mock.lockACLSetUser.Lock()
	mock.calls.ACLSetUser = nil
	mock.lockACLSetUser.Unlock()

	mock.lockACLUsers.Lock()
	mock.calls.ACLUsers = nil
	mock.lockACLUsers.Unlock()

	mock.lockACLWhoAmI.Lock()
	mock.calls.ACLWhoAmI = nil
	mock.lockACLWhoAmI.Unlock()

	mock.lockAppend.Lock()
	mock.calls.Append = nil
	mock.lockAppend.Unlock()

	mock.lockBFAdd.Lock()
	mock.calls.BFAdd = nil
	mock.lockBFAdd.Unlock()

	mock.lockBFCard.Lock()
	mock.calls.BFCard = nil
	mock.lockBFCard.Unlock()

	mock.lockBFExists.Lock()
	mock.calls.BFExists = nil
	mock.lockBFExists.Unlock()

	mock.lockBFInfo.Lock()
	mock.calls.BFInfo = nil
	mock.lockBFInfo.Unlock()

	mock.lockBFInfoArg.Lock()
	mock.calls.BFInfoArg = nil
	mock.lockBFInfoArg.Unlock()

	mock.lockBFInfoCapacity.Lock()
	mock.calls.BFInfoCapacity = nil
	mock.lockBFInfoCapacity.Unlock()

	mock.lockBFInfoExpansion.Lock()
	mock.calls.BFInfoExpansion = nil
	mock.lockBFInfoExpansion.Unlock()

	mock.lockBFInfoFilters.Lock()
	mock.calls.BFInfoFilters = nil
	mock.lockBFInfoFilters.Unlock()

	mock.lockBFInfoItems.Lock()
	mock.calls.BFInfoItems = nil
	mock.lockBFInfoItems.Unlock()

	mock.lockBFInfoSize.Lock()
	mock.calls.BFInfoSize = nil
	mock.lockBFInfoSize.Unlock()

	mock.lockBFInsert.Lock()
	mock.calls.BFInsert = nil
	mock.lockBFInsert.Unlock()

	mock.lockBFLoadChunk.Lock()
	mock.calls.BFLoadChunk = nil
	mock.lockBFLoadChunk.Unlock()

	mock.lockBFMAdd.Lock()
	mock.calls.BFMAdd = nil
	mock.lockBFMAdd.Unlock()

	mock.lockBFMExists.Lock()
	mock.calls.BFMExists = nil
	mock.lockBFMExists.Unlock()

	mock.lockBFReserve.Lock()
	mock.calls.BFReserve = nil
	mock.lockBFReserve.Unlock()

	mock.lockBFReserveExpansion.Lock()
	mock.calls.BFReserveExpansion = nil
	mock.lockBFReserveExpansion.Unlock()

	mock.lockBFReserveNonScaling.Lock()
	mock.calls.BFReserveNonScaling = nil
	mock.lockBFReserveNonScaling.Unlock()

	mock.lockBFReserveWithArgs.Lock()
	mock.calls.BFReserveWithArgs = nil
	mock.lockBFReserveWithArgs.Unlock()

	mock.lockBFScanDump.Lock()
	mock.calls.BFScanDump = nil
	mock.lockBFScanDump.Unlock()

	mock.lockBLMPop.Lock()
	mock.calls.BLMPop = nil
	mock.lockBLMPop.Unlock()

	mock.lockBLMove.Lock()
	mock.calls.BLMove = nil
	mock.lockBLMove.Unlock()

	mock.lockBLPop.Lock()
	mock.calls.BLPop = nil
	mock.lockBLPop.Unlock()

	mock.lockBRPop.Lock()
	mock.calls.BRPop = nil
	mock.lockBRPop.Unlock()

	mock.lockBRPopLPush.Lock()
	mock.calls.BRPopLPush = nil
	mock.lockBRPopLPush.Unlock()

	mock.lockBZMPop.Lock()
	mock.calls.BZMPop = nil
	mock.lockBZMPop.Unlock()

	mock.lockBZPopMax.Lock()
	mock.calls.BZPopMax = nil
	mock.lockBZPopMax.Unlock()

	mock.lockBZPopMin.Lock()
	mock.calls.BZPopMin = nil
	mock.lockBZPopMin.Unlock()

	mock.lockBgRewriteAOF.Lock()
	mock.calls.BgRewriteAOF = nil
	mock.lockBgRewriteAOF.Unlock()

	mock.lockBgSave.Lock()
	mock.calls.BgSave = nil
	mock.lockBgSave.Unlock()

	mock.lockBitCount.Lock()
	mock.calls.BitCount = nil
	mock.lockBitCount.Unlock()

	mock.lockBitField.Lock()
	mock.calls.BitField = nil
	mock.lockBitField.Unlock()

	mock.lockBitFieldRO.Lock()
	mock.calls.BitFieldRO = nil
	mock.lockBitFieldRO.Unlock()

	mock.lockBitOpAnd.Lock()
	mock.calls.BitOpAnd = nil
	mock.lockBitOpAnd.Unlock()

	mock.lockBitOpAndOr.Lock()
	mock.calls.BitOpAndOr = nil
	mock.lockBitOpAndOr.Unlock()

	mock.lockBitOpDiff.Lock()
	mock.calls.BitOpDiff = nil
	mock.lockBitOpDiff.Unlock()

	mock.lockBitOpDiff1.Lock()
	mock.calls.BitOpDiff1 = nil
	mock.lockBitOpDiff1.Unlock()

	mock.lockBitOpNot.Lock()
	mock.calls.BitOpNot = nil
	mock.lockBitOpNot.Unlock()

	mock.lockBitOpOne.Lock()
	mock.calls.BitOpOne = nil
	mock.lockBitOpOne.Unlock()

	mock.lockBitOpOr.Lock()
	mock.calls.BitOpOr = nil
	mock.lockBitOpOr.Unlock()

	mock.lockBitOpXor.Lock()
	mock.calls.BitOpXor = nil
	mock.lockBitOpXor.Unlock()

	mock.lockBitPos.Lock()
	mock.calls.BitPos = nil
	mock.lockBitPos.Unlock()

	mock.lockBitPosSpan.Lock()
	mock.calls.BitPosSpan = nil
	mock.lockBitPosSpan.Unlock()

	mock.lockCFAdd.Lock()
	mock.calls.CFAdd = nil
	mock.lockCFAdd.Unlock()

	mock.lockCFAddNX.Lock()
	mock.calls.CFAddNX = nil
	mock.lockCFAddNX.Unlock()

	mock.lockCFCount.Lock()
	mock.calls.CFCount = nil
	mock.lockCFCount.Unlock()

	mock.lockCFDel.Lock()
	mock.calls.CFDel = nil
	mock.lockCFDel.Unlock()

	mock.lockCFExists.Lock()
	mock.calls.CFExists = nil
	mock.lockCFExists.Unlock()

	mock.lockCFInfo.Lock()
	mock.calls.CFInfo = nil
	mock.lockCFInfo.Unlock()

	mock.lockCFInsert.Lock()
	mock.calls.CFInsert = nil
	mock.lockCFInsert.Unlock()

	mock.lockCFInsertNX.Lock()
	mock.calls.CFInsertNX = nil
	mock.lockCFInsertNX.Unlock()

	mock.lockCFLoadChunk.Lock()
	mock.calls.CFLoadChunk = nil
	mock.lockCFLoadChunk.Unlock()

	mock.lockCFMExists.Lock()
	mock.calls.CFMExists = nil
	mock.lockCFMExists.Unlock()

	mock.lockCFReserve.Lock()
	mock.calls.CFReserve = nil
	mock.lockCFReserve.Unlock()

	mock.lockCFReserveBucketSize.Lock()
	mock.calls.CFReserveBucketSize = nil
	mock.lockCFReserveBucketSize.Unlock()

	mock.lockCFReserveExpansion.Lock()
	mock.calls.CFReserveExpansion = nil
	mock.lockCFReserveExpansion.Unlock()

	mock.lockCFReserveMaxIterations.Lock()
	mock.calls.CFReserveMaxIterations = nil
	mock.lockCFReserveMaxIterations.Unlock()

	mock.lockCFReserveWithArgs.Lock()
	mock.calls.CFReserveWithArgs = nil
	mock.lockCFReserveWithArgs.Unlock()

	mock.lockCFScanDump.Lock()
	mock.calls.CFScanDump = nil
	mock.lockCFScanDump.Unlock()

	mock.lockCMSIncrBy.Lock()
	mock.calls.CMSIncrBy = nil
	mock.lockCMSIncrBy.Unlock()

	mock.lockCMSInfo.Lock()
	mock.calls.CMSInfo = nil
	mock.lockCMSInfo.Unlock()

	mock.lockCMSInitByDim.Lock()
	mock.calls.CMSInitByDim = nil
	mock.lockCMSInitByDim.Unlock()

	mock.lockCMSInitByProb.Lock()
	mock.calls.CMSInitByProb = nil
	mock.lockCMSInitByProb.Unlock()

	mock.lockCMSMerge.Lock()
	mock.calls.CMSMerge = nil
	mock.lockCMSMerge.Unlock()

	mock.lockCMSMergeWithWeight.Lock()
	mock.calls.CMSMergeWithWeight = nil
	mock.lockCMSMergeWithWeight.Unlock()

	mock.lockCMSQuery.Lock()
	mock.calls.CMSQuery = nil
	mock.lockCMSQuery.Unlock()

	mock.lockClientGetName.Lock()
	mock.calls.ClientGetName = nil
	mock.lockClientGetName.Unlock()

	mock.lockClientID.Lock()
	mock.calls.ClientID = nil
	mock.lockClientID.Unlock()

	mock.lockClientInfo.Lock()
	mock.calls.ClientInfo = nil
	mock.lockClientInfo.Unlock()

	mock.lockClientKill.Lock()
	mock.calls.ClientKill = nil
	mock.lockClientKill.Unlock()

	mock.lockClientKillByFilter.Lock()
	mock.calls.ClientKillByFilter = nil
	mock.lockClientKillByFilter.Unlock()

	mock.lockClientList.Lock()
	mock.calls.ClientList = nil
	mock.lockClientList.Unlock()

	mock.lockClientMaintNotifications.Lock()
	mock.calls.ClientMaintNotifications = nil
	mock.lockClientMaintNotifications.Unlock()

	mock.lockClientPause.Lock()
	mock.calls.ClientPause = nil
	mock.lockClientPause.Unlock()

	mock.lockClientUnblock.Lock()
	mock.calls.ClientUnblock = nil
	mock.lockClientUnblock.Unlock()

	mock.lockClientUnblockWithError.Lock()
	mock.calls.ClientUnblockWithError = nil
	mock.lockClientUnblockWithError.Unlock()

	mock.lockClientUnpause.Lock()
	mock.calls.ClientUnpause = nil
	mock.lockClientUnpause.Unlock()

	mock.lockClusterAddSlots.Lock()
	mock.calls.ClusterAddSlots = nil
	mock.lockClusterAddSlots.Unlock()

	mock.lockClusterAddSlotsRange.Lock()
	mock.calls.ClusterAddSlotsRange = nil
	mock.lockClusterAddSlotsRange.Unlock()

	mock.lockClusterCountFailureReports.Lock()
	mock.calls.ClusterCountFailureReports = nil
	mock.lockClusterCountFailureReports.Unlock()

	mock.lockClusterCountKeysInSlot.Lock()
	mock.calls.ClusterCountKeysInSlot = nil
	mock.lockClusterCountKeysInSlot.Unlock()

	mock.lockClusterDelSlots.Lock()
	mock.calls.ClusterDelSlots = nil
	mock.lockClusterDelSlots.Unlock()

	mock.lockClusterDelSlotsRange.Lock()
	mock.calls.ClusterDelSlotsRange = nil
	mock.lockClusterDelSlotsRange.Unlock()

	mock.lockClusterFailover.Lock()
	mock.calls.ClusterFailover = nil
	mock.lockClusterFailover.Unlock()

	mock.lockClusterForget.Lock()
	mock.calls.ClusterForget = nil
	mock.lockClusterForget.Unlock()

	mock.lockClusterGetKeysInSlot.Lock()
	mock.calls.ClusterGetKeysInSlot = nil
	mock.lockClusterGetKeysInSlot.Unlock()

	mock.lockClusterInfo.Lock()
	mock.calls.ClusterInfo = nil
	mock.lockClusterInfo.Unlock()

	mock.lockClusterKeySlot.Lock()
	mock.calls.ClusterKeySlot = nil
	mock.lockClusterKeySlot.Unlock()

	mock.lockClusterLinks.Lock()
	mock.calls.ClusterLinks = nil
	mock.lockClusterLinks.Unlock()

	mock.lockClusterMeet.Lock()
	mock.calls.ClusterMeet = nil
	mock.lockClusterMeet.Unlock()

	mock.lockClusterMyID.Lock()
	mock.calls.ClusterMyID = nil
	mock.lockClusterMyID.Unlock()

	mock.lockClusterMyShardID.Lock()
	mock.calls.ClusterMyShardID = nil
	mock.lockClusterMyShardID.Unlock()

	mock.lockClusterNodes.Lock()
	mock.calls.ClusterNodes = nil
	mock.lockClusterNodes.Unlock()

	mock.lockClusterReplicate.Lock()
	mock.calls.ClusterReplicate = nil
	mock.lockClusterReplicate.Unlock()

	mock.lockClusterResetHard.Lock()
	mock.calls.ClusterResetHard = nil
	mock.lockClusterResetHard.Unlock()

	mock.lockClusterResetSoft.Lock()
	mock.calls.ClusterResetSoft = nil
	mock.lockClusterResetSoft.Unlock()

	mock.lockClusterSaveConfig.Lock()
	mock.calls.ClusterSaveConfig = nil
	mock.lockClusterSaveConfig.Unlock()

	mock.lockClusterShards.Lock()
	mock.calls.ClusterShards = nil
	mock.lockClusterShards.Unlock()

	mock.lockClusterSlaves.Lock()
	mock.calls.ClusterSlaves = nil
	mock.lockClusterSlaves.Unlock()

	mock.lockClusterSlots.Lock()
	mock.calls.ClusterSlots = nil
	mock.lockClusterSlots.Unlock()

	mock.lockCommand.Lock()
	mock.calls.Command = nil
	mock.lockCommand.Unlock()

	mock.lockCommandGetKeys.Lock()
	mock.calls.CommandGetKeys = nil
	mock.lockCommandGetKeys.Unlock()

	mock.lockCommandGetKeysAndFlags.Lock()
	mock.calls.CommandGetKeysAndFlags = nil
	mock.lockCommandGetKeysAndFlags.Unlock()

	mock.lockCommandList.Lock()
	mock.calls.CommandList = nil
	mock.lockCommandList.Unlock()

	mock.lockConfigGet.Lock()
	mock.calls.ConfigGet = nil
	mock.lockConfigGet.Unlock()

	mock.lockConfigResetStat.Lock()
	mock.calls.ConfigResetStat = nil
	mock.lockConfigResetStat.Unlock()

	mock.lockConfigRewrite.Lock()
	mock.calls.ConfigRewrite = nil
	mock.lockConfigRewrite.Unlock()

	mock.lockConfigSet.Lock()
	mock.calls.ConfigSet = nil
	mock.lockConfigSet.Unlock()

	mock.lockCopy.Lock()
	mock.calls.Copy = nil
	mock.lockCopy.Unlock()

	mock.lockDBSize.Lock()
	mock.calls.DBSize = nil
	mock.lockDBSize.Unlock()

	mock.lockDebugObject.Lock()
	mock.calls.DebugObject = nil
	mock.lockDebugObject.Unlock()

	mock.lockDecr.Lock()
	mock.calls.Decr = nil
	mock.lockDecr.Unlock()

	mock.lockDecrBy.Lock()
	mock.calls.DecrBy = nil
	mock.lockDecrBy.Unlock()

	mock.lockDel.Lock()
	mock.calls.Del = nil
	mock.lockDel.Unlock()

	mock.lockDelExArgs.Lock()
	mock.calls.DelExArgs = nil
	mock.lockDelExArgs.Unlock()

	mock.lockDigest.Lock()
	mock.calls.Digest = nil
	mock.lockDigest.Unlock()

	mock.lockDump.Lock()
	mock.calls.Dump = nil
	mock.lockDump.Unlock()

	mock.lockEcho.Lock()
	mock.calls.Echo = nil
	mock.lockEcho.Unlock()

	mock.lockEval.Lock()
	mock.calls.Eval = nil
	mock.lockEval.Unlock()

	mock.lockEvalRO.Lock()
	mock.calls.EvalRO = nil
	mock.lockEvalRO.Unlock()

	mock.lockEvalSha.Lock()
	mock.calls.EvalSha = nil
	mock.lockEvalSha.Unlock()

	mock.lockEvalShaRO.Lock()
	mock.calls.EvalShaRO = nil
	mock.lockEvalShaRO.Unlock()

	mock.lockExists.Lock()
	mock.calls.Exists = nil
	mock.lockExists.Unlock()

	mock.lockExpire.Lock()
	mock.calls.Expire = nil
	mock.lockExpire.Unlock()

	mock.lockExpireAt.Lock()
	mock.calls.ExpireAt = nil
	mock.lockExpireAt.Unlock()

	mock.lockExpireGT.Lock()
	mock.calls.ExpireGT = nil
	mock.lockExpireGT.Unlock()

	mock.lockExpireLT.Lock()
	mock.calls.ExpireLT = nil
	mock.lockExpireLT.Unlock()

	mock.lockExpireNX.Lock()
	mock.calls.ExpireNX = nil
	mock.lockExpireNX.Unlock()

	mock.lockExpireTime.Lock()
	mock.calls.ExpireTime = nil
	mock.lockExpireTime.Unlock()

	mock.lockExpireXX.Lock()
	mock.calls.ExpireXX = nil
	mock.lockExpireXX.Unlock()

	mock.lockFCall.Lock()
	mock.calls.FCall = nil
	mock.lockFCall.Unlock()

	mock.lockFCallRO.Lock()
	mock.calls.FCallRO = nil
	mock.lockFCallRO.Unlock()

	mock.lockFCallRo.Lock()
	mock.calls.FCallRo = nil
	mock.lockFCallRo.Unlock()

	mock.lockFTAggregate.Lock()
	mock.calls.FTAggregate = nil
	mock.lockFTAggregate.Unlock()

	mock.lockFTAggregateWithArgs.Lock()
	mock.calls.FTAggregateWithArgs = nil
	mock.lockFTAggregateWithArgs.Unlock()

	mock.lockFTAliasAdd.Lock()
	mock.calls.FTAliasAdd = nil
	mock.lockFTAliasAdd.Unlock()

	mock.lockFTAliasDel.Lock()
	mock.calls.FTAliasDel = nil
	mock.lockFTAliasDel.Unlock()

	mock.lockFTAliasUpdate.Lock()
	mock.calls.FTAliasUpdate = nil
	mock.lockFTAliasUpdate.Unlock()

	mock.lockFTAlter.Lock()
	mock.calls.FTAlter = nil
	mock.lockFTAlter.Unlock()

	mock.lockFTConfigGet.Lock()
	mock.calls.FTConfigGet = nil
	mock.lockFTConfigGet.Unlock()

	mock.lockFTConfigSet.Lock()
	mock.calls.FTConfigSet = nil
	mock.lockFTConfigSet.Unlock()

	mock.lockFTCreate.Lock()
	mock.calls.FTCreate = nil
	mock.lockFTCreate.Unlock()

	mock.lockFTCursorDel.Lock()
	mock.calls.FTCursorDel = nil
	mock.lockFTCursorDel.Unlock()

	mock.lockFTCursorRead.Lock()
	mock.calls.FTCursorRead = nil
	mock.lockFTCursorRead.Unlock()

	mock.lockFTDictAdd.Lock()
	mock.calls.FTDictAdd = nil
	mock.lockFTDictAdd.Unlock()

	mock.lockFTDictDel.Lock()
	mock.calls.FTDictDel = nil
	mock.lockFTDictDel.Unlock()

	mock.lockFTDictDump.Lock()
	mock.calls.FTDictDump = nil
	mock.lockFTDictDump.Unlock()

	mock.lockFTDropIndex.Lock()
	mock.calls.FTDropIndex = nil
	mock.lockFTDropIndex.Unlock()

	mock.lockFTDropIndexWithArgs.Lock()
	mock.calls.FTDropIndexWithArgs = nil
	mock.lockFTDropIndexWithArgs.Unlock()

	mock.lockFTExplain.Lock()
	mock.calls.FTExplain = nil
	mock.lockFTExplain.Unlock()

	mock.lockFTExplainWithArgs.Lock()
	mock.calls.FTExplainWithArgs = nil
	mock.lockFTExplainWithArgs.Unlock()

	mock.lockFTHybrid.Lock()
	mock.calls.FTHybrid = nil
	mock.lockFTHybrid.Unlock()

	mock.lockFTHybridWithArgs.Lock()
	mock.calls.FTHybridWithArgs = nil
	mock.lockFTHybridWithArgs.Unlock()

	mock.lockFTInfo.Lock()
	mock.calls.FTInfo = nil
	mock.lockFTInfo.Unlock()

	mock.lockFTSearch.Lock()
	mock.calls.FTSearch = nil
	mock.lockFTSearch.Unlock()

	mock.lockFTSearchWithArgs.Lock()
	mock.calls.FTSearchWithArgs = nil
	mock.lockFTSearchWithArgs.Unlock()

	mock.lockFTSpellCheck.Lock()
	mock.calls.FTSpellCheck = nil
	mock.lockFTSpellCheck.Unlock()

	mock.lockFTSpellCheckWithArgs.Lock()
	mock.calls.FTSpellCheckWithArgs = nil
	mock.lockFTSpellCheckWithArgs.Unlock()

	mock.lockFTSynDump.Lock()
	mock.calls.FTSynDump = nil
	mock.lockFTSynDump.Unlock()

	mock.lockFTSynUpdate.Lock()
	mock.calls.FTSynUpdate = nil
	mock.lockFTSynUpdate.Unlock()

	mock.lockFTSynUpdateWithArgs.Lock()
	mock.calls.FTSynUpdateWithArgs = nil
	mock.lockFTSynUpdateWithArgs.Unlock()

	mock.lockFTTagVals.Lock()
	mock.calls.FTTagVals = nil
	mock.lockFTTagVals.Unlock()

	mock.lockFT_List.Lock()
	mock.calls.FT_List = nil
	mock.lockFT_List.Unlock()

	mock.lockFlushAll.Lock()
	mock.calls.FlushAll = nil
	mock.lockFlushAll.Unlock()

	mock.lockFlushAllAsync.Lock()
	mock.calls.FlushAllAsync = nil
	mock.lockFlushAllAsync.Unlock()

	mock.lockFlushDB.Lock()
	mock.calls.FlushDB = nil
	mock.lockFlushDB.Unlock()

	mock.lockFlushDBAsync.Lock()
	mock.calls.FlushDBAsync = nil
	mock.lockFlushDBAsync.Unlock()

	mock.lockFunctionDelete.Lock()
	mock.calls.FunctionDelete = nil
	mock.lockFunctionDelete.Unlock()

	mock.lockFunctionDump.Lock()
	mock.calls.FunctionDump = nil
	mock.lockFunctionDump.Unlock()

	mock.lockFunctionFlush.Lock()
	mock.calls.FunctionFlush = nil
	mock.lockFunctionFlush.Unlock()

	mock.lockFunctionFlushAsync.Lock()
	mock.calls.FunctionFlushAsync = nil
	mock.lockFunctionFlushAsync.Unlock()

	mock.lockFunctionKill.Lock()
	mock.calls.FunctionKill = nil
	mock.lockFunctionKill.Unlock()

	mock.lockFunctionList.Lock()
	mock.calls.FunctionList = nil
	mock.lockFunctionList.Unlock()

	mock.lockFunctionLoad.Lock()
	mock.calls.FunctionLoad = nil
	mock.lockFunctionLoad.Unlock()

	mock.lockFunctionLoadReplace.Lock()
	mock.calls.FunctionLoadReplace = nil
	mock.lockFunctionLoadReplace.Unlock()

	mock.lockFunctionRestore.Lock()
	mock.calls.FunctionRestore = nil
	mock.lockFunctionRestore.Unlock()

	mock.lockFunctionStats.Lock()
	mock.calls.FunctionStats = nil
	mock.lockFunctionStats.Unlock()

	mock.lockGeoAdd.Lock()
	mock.calls.GeoAdd = nil
	mock.lockGeoAdd.Unlock()

	mock.lockGeoDist.Lock()
	mock.calls.GeoDist = nil
	mock.lockGeoDist.Unlock()

	mock.lockGeoHash.Lock()
	mock.calls.GeoHash = nil
	mock.lockGeoHash.Unlock()

	mock.lockGeoPos.Lock()
	mock.calls.GeoPos = nil
	mock.lockGeoPos.Unlock()

	mock.lockGeoRadius.Lock()
	mock.calls.GeoRadius = nil
	mock.lockGeoRadius.Unlock()

	mock.lockGeoRadiusByMember.Lock()
	mock.calls.GeoRadiusByMember = nil
	mock.lockGeoRadiusByMember.Unlock()

	mock.lockGeoRadiusByMemberStore.Lock()
	mock.calls.GeoRadiusByMemberStore = nil
	mock.lockGeoRadiusByMemberStore.Unlock()

	mock.lockGeoRadiusStore.Lock()
	mock.calls.GeoRadiusStore = nil
	mock.lockGeoRadiusStore.Unlock()

	mock.lockGeoSearch.Lock()
	mock.calls.GeoSearch = nil
	mock.lockGeoSearch.Unlock()

	mock.lockGeoSearchLocation.Lock()
	mock.calls.GeoSearchLocation = nil
	mock.lockGeoSearchLocation.Unlock()

	mock.lockGeoSearchStore.Lock()
	mock.calls.GeoSearchStore = nil
	mock.lockGeoSearchStore.Unlock()

	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()

	mock.lockGetBit.Lock()
	mock.calls.GetBit = nil
	mock.lockGetBit.Unlock()

	mock.lockGetDel.Lock()
	mock.calls.GetDel = nil
	mock.lockGetDel.Unlock()

	mock.lockGetEx.Lock()
	mock.calls.GetEx = nil
	mock.lockGetEx.Unlock()

	mock.lockGetRange.Lock()
	mock.calls.GetRange = nil
	mock.lockGetRange.Unlock()

	mock.lockGetSet.Lock()
	mock.calls.GetSet = nil
	mock.lockGetSet.Unlock()

	mock.lockHDel.Lock()
	mock.calls.HDel = nil
	mock.lockHDel.Unlock()

	mock.lockHExists.Lock()
	mock.calls.HExists = nil
	mock.lockHExists.Unlock()

	mock.lockHExpire.Lock()
	mock.calls.HExpire = nil
	mock.lockHExpire.Unlock()

	mock.lockHExpireAt.Lock()
	mock.calls.HExpireAt = nil
	mock.lockHExpireAt.Unlock()

	mock.lockHExpireAtWithArgs.Lock()
	mock.calls.HExpireAtWithArgs = nil
	mock.lockHExpireAtWithArgs.Unlock()

	mock.lockHExpireTime.Lock()
	mock.calls.HExpireTime = nil
	mock.lockHExpireTime.Unlock()

	mock.lockHExpireWithArgs.Lock()
	mock.calls.HExpireWithArgs = nil
	mock.lockHExpireWithArgs.Unlock()

	mock.lockHGet.Lock()
	mock.calls.HGet = nil
	mock.lockHGet.Unlock()

	mock.lockHGetAll.Lock()
	mock.calls.HGetAll = nil
	mock.lockHGetAll.Unlock()

	mock.lockHGetDel.Lock()
	mock.calls.HGetDel = nil
	mock.lockHGetDel.Unlock()

	mock.lockHGetEX.Lock()
	mock.calls.HGetEX = nil
	mock.lockHGetEX.Unlock()

	mock.lockHGetEXWithArgs.Lock()
	mock.calls.HGetEXWithArgs = nil
	mock.lockHGetEXWithArgs.Unlock()

	mock.lockHIncrBy.Lock()
	mock.calls.HIncrBy = nil
	mock.lockHIncrBy.Unlock()

	mock.lockHIncrByFloat.Lock()
	mock.calls.HIncrByFloat = nil
	mock.lockHIncrByFloat.Unlock()

	mock.lockHKeys.Lock()
	mock.calls.HKeys = nil
	mock.lockHKeys.Unlock()

	mock.lockHLen.Lock()
	mock.calls.HLen = nil
	mock.lockHLen.Unlock()

	mock.lockHMGet.Lock()
	mock.calls.HMGet = nil
	mock.lockHMGet.Unlock()

	mock.lockHMSet.Lock()
	mock.calls.HMSet = nil
	mock.lockHMSet.Unlock()

	mock.lockHPExpire.Lock()
	mock.calls.HPExpire = nil
	mock.lockHPExpire.Unlock()

	mock.lockHPExpireAt.Lock()
	mock.calls.HPExpireAt = nil
	mock.lockHPExpireAt.Unlock()

	mock.lockHPExpireAtWithArgs.Lock()
	mock.calls.HPExpireAtWithArgs = nil
	mock.lockHPExpireAtWithArgs.Unlock()

	mock.lockHPExpireTime.Lock()
	mock.calls.HPExpireTime = nil
	mock.lockHPExpireTime.Unlock()

	mock.lockHPExpireWithArgs.Lock()
	mock.calls.HPExpireWithArgs = nil
	mock.lockHPExpireWithArgs.Unlock()

	mock.lockHPTTL.Lock()
	mock.calls.HPTTL = nil
	mock.lockHPTTL.Unlock()

	mock.lockHPersist.Lock()
	mock.calls.HPersist = nil
	mock.lockHPersist.Unlock()

	mock.lockHRandField.Lock()
	mock.calls.HRandField = nil
	mock.lockHRandField.Unlock()

	mock.lockHRandFieldWithValues.Lock()
	mock.calls.HRandFieldWithValues = nil
	mock.lockHRandFieldWithValues.Unlock()

	mock.lockHScan.Lock()
	mock.calls.HScan = nil
	mock.lockHScan.Unlock()

	mock.lockHScanNoValues.Lock()
	mock.calls.HScanNoValues = nil
	mock.lockHScanNoValues.Unlock()

	mock.lockHSet.Lock()
	mock.calls.HSet = nil
	mock.lockHSet.Unlock()

	mock.lockHSetEX.Lock()
	mock.calls.HSetEX = nil
	mock.lockHSetEX.Unlock()

	mock.lockHSetEXWithArgs.Lock()
	mock.calls.HSetEXWithArgs = nil
	mock.lockHSetEXWithArgs.Unlock()

	mock.lockHSetNX.Lock()
	mock.calls.HSetNX = nil
	mock.lockHSetNX.Unlock()

	mock.lockHStrLen.Lock()
	mock.calls.HStrLen = nil
	mock.lockHStrLen.Unlock()

	mock.lockHTTL.Lock()
	mock.calls.HTTL = nil
	mock.lockHTTL.Unlock()

	mock.lockHVals.Lock()
	mock.calls.HVals = nil
	mock.lockHVals.Unlock()

	mock.lockIncr.Lock()
	mock.calls.Incr = nil
	mock.lockIncr.Unlock()

	mock.lockIncrBy.Lock()
	mock.calls.IncrBy = nil
	mock.lockIncrBy.Unlock()

	mock.lockIncrByFloat.Lock()
	mock.calls.IncrByFloat = nil
	mock.lockIncrByFloat.Unlock()

	mock.lockInfo.Lock()
	mock.calls.Info = nil
	mock.lockInfo.Unlock()

	mock.lockJSONArrAppend.Lock()
	mock.calls.JSONArrAppend = nil
	mock.lockJSONArrAppend.Unlock()

	mock.lockJSONArrIndex.Lock()
	mock.calls.JSONArrIndex = nil
	mock.lockJSONArrIndex.Unlock()

	mock.lockJSONArrIndexWithArgs.Lock()
	mock.calls.JSONArrIndexWithArgs = nil
	mock.lockJSONArrIndexWithArgs.Unlock()

	mock.lockJSONArrInsert.Lock()
	mock.calls.JSONArrInsert = nil
	mock.lockJSONArrInsert.Unlock()

	mock.lockJSONArrLen.Lock()
	mock.calls.JSONArrLen = nil
	mock.lockJSONArrLen.Unlock()

	mock.lockJSONArrPop.Lock()
	mock.calls.JSONArrPop = nil
	mock.lockJSONArrPop.Unlock()

	mock.lockJSONArrTrim.Lock()
	mock.calls.JSONArrTrim = nil
	mock.lockJSONArrTrim.Unlock()

	mock.lockJSONArrTrimWithArgs.Lock()
	mock.calls.JSONArrTrimWithArgs = nil
	mock.lockJSONArrTrimWithArgs.Unlock()

	mock.lockJSONClear.Lock()
	mock.calls.JSONClear = nil
	mock.lockJSONClear.Unlock()

	mock.lockJSONDebugMemory.Lock()
	mock.calls.JSONDebugMemory = nil
	mock.lockJSONDebugMemory.Unlock()

	mock.lockJSONDel.Lock()
	mock.calls.JSONDel = nil
	mock.lockJSONDel.Unlock()

	mock.lockJSONForget.Lock()
	mock.calls.JSONForget = nil
	mock.lockJSONForget.Unlock()

	mock.lockJSONGet.Lock()
	mock.calls.JSONGet = nil
	mock.lockJSONGet.Unlock()

	mock.lockJSONGetWithArgs.Lock()
	mock.calls.JSONGetWithArgs = nil
	mock.lockJSONGetWithArgs.Unlock()

	mock.lockJSONMGet.Lock()
	mock.calls.JSONMGet = nil
	mock.lockJSONMGet.Unlock()

	mock.lockJSONMSet.Lock()
	mock.calls.JSONMSet = nil
	mock.lockJSONMSet.Unlock()

	mock.lockJSONMSetArgs.Lock()
	mock.calls.JSONMSetArgs = nil
	mock.lockJSONMSetArgs.Unlock()

	mock.lockJSONMerge.Lock()
	mock.calls.JSONMerge = nil
	mock.lockJSONMerge.Unlock()

	mock.lockJSONNumIncrBy.Lock()
	mock.calls.JSONNumIncrBy = nil
	mock.lockJSONNumIncrBy.Unlock()

	mock.lockJSONObjKeys.Lock()
	mock.calls.JSONObjKeys = nil
	mock.lockJSONObjKeys.Unlock()

	mock.lockJSONObjLen.Lock()
	mock.calls.JSONObjLen = nil
	mock.lockJSONObjLen.Unlock()

	mock.lockJSONSet.Lock()
	mock.calls.JSONSet = nil
	mock.lockJSONSet.Unlock()

	mock.lockJSONSetMode.Lock()
	mock.calls.JSONSetMode = nil
	mock.lockJSONSetMode.Unlock()

	mock.lockJSONStrAppend.Lock()
	mock.calls.JSONStrAppend = nil
	mock.lockJSONStrAppend.Unlock()

	mock.lockJSONStrLen.Lock()
	mock.calls.JSONStrLen = nil
	mock.lockJSONStrLen.Unlock()

	mock.lockJSONToggle.Lock()
	mock.calls.JSONToggle = nil
	mock.lockJSONToggle.Unlock()

	mock.lockJSONType.Lock()
	mock.calls.JSONType = nil
	mock.lockJSONType.Unlock()

	mock.lockKeys.Lock()
	mock.calls.Keys = nil
	mock.lockKeys.Unlock()

	mock.lockLCS.Lock()
	mock.calls.LCS = nil
	mock.lockLCS.Unlock()

	mock.lockLIndex.Lock()
	mock.calls.LIndex = nil
	mock.lockLIndex.Unlock()

	mock.lockLInsert.Lock()
	mock.calls.LInsert = nil
	mock.lockLInsert.Unlock()

	mock.lockLInsertAfter.Lock()
	mock.calls.LInsertAfter = nil
	mock.lockLInsertAfter.Unlock()

	mock.lockLInsertBefore.Lock()
	mock.calls.LInsertBefore = nil
	mock.lockLInsertBefore.Unlock()

	mock.lockLLen.Lock()
	mock.calls.LLen = nil
	mock.lockLLen.Unlock()

	mock.lockLMPop.Lock()
	mock.calls.LMPop = nil
	mock.lockLMPop.Unlock()

	mock.lockLMove.Lock()
	mock.calls.LMove = nil
	mock.lockLMove.Unlock()

	mock.lockLPop.Lock()
	mock.calls.LPop = nil
	mock.lockLPop.Unlock()

	mock.lockLPopCount.Lock()
	mock.calls.LPopCount = nil
	mock.lockLPopCount.Unlock()

	mock.lockLPos.Lock()
	mock.calls.LPos = nil
	mock.lockLPos.Unlock()

	mock.lockLPosCount.Lock()
	mock.calls.LPosCount = nil
	mock.lockLPosCount.Unlock()

	mock.lockLPush.Lock()
	mock.calls.LPush = nil
	mock.lockLPush.Unlock()

	mock.lockLPushX.Lock()
	mock.calls.LPushX = nil
	mock.lockLPushX.Unlock()

	mock.lockLRange.Lock()
	mock.calls.LRange = nil
	mock.lockLRange.Unlock()

	mock.lockLRem.Lock()
	mock.calls.LRem = nil
	mock.lockLRem.Unlock()

	mock.lockLSet.Lock()
	mock.calls.LSet = nil
	mock.lockLSet.Unlock()

	mock.lockLTrim.Lock()
	mock.calls.LTrim = nil
	mock.lockLTrim.Unlock()

	mock.lockLastSave.Lock()
	mock.calls.LastSave = nil
	mock.lockLastSave.Unlock()

	mock.lockLatency.Lock()
	mock.calls.Latency = nil
	mock.lockLatency.Unlock()

	mock.lockLatencyReset.Lock()
	mock.calls.LatencyReset = nil
	mock.lockLatencyReset.Unlock()

	mock.lockMGet.Lock()
	mock.calls.MGet = nil
	mock.lockMGet.Unlock()

	mock.lockMSet.Lock()
	mock.calls.MSet = nil
	mock.lockMSet.Unlock()

	mock.lockMSetEX.Lock()
	mock.calls.MSetEX = nil
	mock.lockMSetEX.Unlock()

	mock.lockMSetNX.Lock()
	mock.calls.MSetNX = nil
	mock.lockMSetNX.Unlock()

	mock.lockMemoryUsage.Lock()
	mock.calls.MemoryUsage = nil
	mock.lockMemoryUsage.Unlock()

	mock.lockMigrate.Lock()
	mock.calls.Migrate = nil
	mock.lockMigrate.Unlock()

	mock.lockModuleLoadex.Lock()
	mock.calls.ModuleLoadex = nil
	mock.lockModuleLoadex.Unlock()

	mock.lockMove.Lock()
	mock.calls.Move = nil
	mock.lockMove.Unlock()

	mock.lockObjectEncoding.Lock()
	mock.calls.ObjectEncoding = nil
	mock.lockObjectEncoding.Unlock()

	mock.lockObjectFreq.Lock()
	mock.calls.ObjectFreq = nil
	mock.lockObjectFreq.Unlock()

	mock.lockObjectIdleTime.Lock()
	mock.calls.ObjectIdleTime = nil
	mock.lockObjectIdleTime.Unlock()

	mock.lockObjectRefCount.Lock()
	mock.calls.ObjectRefCount = nil
	mock.lockObjectRefCount.Unlock()

	mock.lockPExpire.Lock()
	mock.calls.PExpire = nil
	mock.lockPExpire.Unlock()

	mock.lockPExpireAt.Lock()
	mock.calls.PExpireAt = nil
	mock.lockPExpireAt.Unlock()

	mock.lockPExpireTime.Lock()
	mock.calls.PExpireTime = nil
	mock.lockPExpireTime.Unlock()

	mock.lockPFAdd.Lock()
	mock.calls.PFAdd = nil
	mock.lockPFAdd.Unlock()

	mock.lockPFCount.Lock()
	mock.calls.PFCount = nil
	mock.lockPFCount.Unlock()

	mock.lockPFMerge.Lock()
	mock.calls.PFMerge = nil
	mock.lockPFMerge.Unlock()

	mock.lockPTTL.Lock()
	mock.calls.PTTL = nil
	mock.lockPTTL.Unlock()

	mock.lockPersist.Lock()
	mock.calls.Persist = nil
	mock.lockPersist.Unlock()

	mock.lockPing.Lock()
	mock.calls.Ping = nil
	mock.lockPing.Unlock()

	mock.lockPipeline.Lock()
	mock.calls.Pipeline = nil
	mock.lockPipeline.Unlock()

	mock.lockPipelined.Lock()
	mock.calls.Pipelined = nil
	mock.lockPipelined.Unlock()

	mock.lockPubSubChannels.Lock()
	mock.calls.PubSubChannels = nil
	mock.lockPubSubChannels.Unlock()

	mock.lockPubSubNumPat.Lock()
	mock.calls.PubSubNumPat = nil
	mock.lockPubSubNumPat.Unlock()

	mock.lockPubSubNumSub.Lock()
	mock.calls.PubSubNumSub = nil
	mock.lockPubSubNumSub.Unlock()

	mock.lockPubSubShardChannels.Lock()
	mock.calls.PubSubShardChannels = nil
	mock.lockPubSubShardChannels.Unlock()

	mock.lockPubSubShardNumSub.Lock()
	mock.calls.PubSubShardNumSub = nil
	mock.lockPubSubShardNumSub.Unlock()

	mock.lockPublish.Lock()
	mock.calls.Publish = nil
	mock.lockPublish.Unlock()

	mock.lockQuit.Lock()
	mock.calls.Quit = nil
	mock.lockQuit.Unlock()

	mock.lockRPop.Lock()
	mock.calls.RPop = nil
	mock.lockRPop.Unlock()

	mock.lockRPopCount.Lock()
	mock.calls.RPopCount = nil
	mock.lockRPopCount.Unlock()

	mock.lockRPopLPush.Lock()
	mock.calls.RPopLPush = nil
	mock.lockRPopLPush.Unlock()

	mock.lockRPush.Lock()
	mock.calls.RPush = nil
	mock.lockRPush.Unlock()

	mock.lockRPushX.Lock()
	mock.calls.RPushX = nil
	mock.lockRPushX.Unlock()

	mock.lockRandomKey.Lock()
	mock.calls.RandomKey = nil
	mock.lockRandomKey.Unlock()

	mock.lockReadOnly.Lock()
	mock.calls.ReadOnly = nil
	mock.lockReadOnly.Unlock()

	mock.lockReadWrite.Lock()
	mock.calls.ReadWrite = nil
	mock.lockReadWrite.Unlock()

	mock.lockRename.Lock()
	mock.calls.Rename = nil
	mock.lockRename.Unlock()

	mock.lockRenameNX.Lock()
	mock.calls.RenameNX = nil
	mock.lockRenameNX.Unlock()

	mock.lockRestore.Lock()
	mock.calls.Restore = nil
	mock.lockRestore.Unlock()

	mock.lockRestoreReplace.Lock()
	mock.calls.RestoreReplace = nil
	mock.lockRestoreReplace.Unlock()

	mock.lockSAdd.Lock()
	mock.calls.SAdd = nil
	mock.lockSAdd.Unlock()

	mock.lockSCard.Lock()
	mock.calls.SCard = nil
	mock.lockSCard.Unlock()

	mock.lockSDiff.Lock()
	mock.calls.SDiff = nil
	mock.lockSDiff.Unlock()

	mock.lockSDiffStore.Lock()
	mock.calls.SDiffStore = nil
	mock.lockSDiffStore.Unlock()

	mock.lockSInter.Lock()
	mock.calls.SInter = nil
	mock.lockSInter.Unlock()

	mock.lockSInterCard.Lock()
	mock.calls.SInterCard = nil
	mock.lockSInterCard.Unlock()

	mock.lockSInterStore.Lock()
	mock.calls.SInterStore = nil
	mock.lockSInterStore.Unlock()

	mock.lockSIsMember.Lock()
	mock.calls.SIsMember = nil
	mock.lockSIsMember.Unlock()

	mock.lockSMIsMember.Lock()
	mock.calls.SMIsMember = nil
	mock.lockSMIsMember.Unlock()

	mock.lockSMembers.Lock()
	mock.calls.SMembers = nil
	mock.lockSMembers.Unlock()

	mock.lockSMembersMap.Lock()
	mock.calls.SMembersMap = nil
	mock.lockSMembersMap.Unlock()

	mock.lockSMove.Lock()
	mock.calls.SMove = nil
	mock.lockSMove.Unlock()

	mock.lockSPop.Lock()
	mock.calls.SPop = nil
	mock.lockSPop.Unlock()

	mock.lockSPopN.Lock()
	mock.calls.SPopN = nil
	mock.lockSPopN.Unlock()

	mock.lockSPublish.Lock()
	mock.calls.SPublish = nil
	mock.lockSPublish.Unlock()

	mock.lockSRandMember.Lock()
	mock.calls.SRandMember = nil
	mock.lockSRandMember.Unlock()

	mock.lockSRandMemberN.Lock()
	mock.calls.SRandMemberN = nil
	mock.lockSRandMemberN.Unlock()

	mock.lockSRem.Lock()
	mock.calls.SRem = nil
	mock.lockSRem.Unlock()

	mock.lockSScan.Lock()
	mock.calls.SScan = nil
	mock.lockSScan.Unlock()

	mock.lockSUnion.Lock()
	mock.calls.SUnion = nil
	mock.lockSUnion.Unlock()

	mock.lockSUnionStore.Lock()
	mock.calls.SUnionStore = nil
	mock.lockSUnionStore.Unlock()

	mock.lockSave.Lock()
	mock.calls.Save = nil
	mock.lockSave.Unlock()

	mock.lockScan.Lock()
	mock.calls.Scan = nil
	mock.lockScan.Unlock()

	mock.lockScanType.Lock()
	mock.calls.ScanType = nil
	mock.lockScanType.Unlock()

	mock.lockScriptExists.Lock()
	mock.calls.ScriptExists = nil
	mock.lockScriptExists.Unlock()

	mock.lockScriptFlush.Lock()
	mock.calls.ScriptFlush = nil
	mock.lockScriptFlush.Unlock()

	mock.lockScriptKill.Lock()
	mock.calls.ScriptKill = nil
	mock.lockScriptKill.Unlock()

	mock.lockScriptLoad.Lock()
	mock.calls.ScriptLoad = nil
	mock.lockScriptLoad.Unlock()

	mock.lockSet.Lock()
	mock.calls.Set = nil
	mock.lockSet.Unlock()

	mock.lockSetArgs.Lock()
	mock.calls.SetArgs = nil
	mock.lockSetArgs.Unlock()

	mock.lockSetBit.Lock()
	mock.calls.SetBit = nil
	mock.lockSetBit.Unlock()

	mock.lockSetEx.Lock()
	mock.calls.SetEx = nil
	mock.lockSetEx.Unlock()

	mock.lockSetIFDEQ.Lock()
	mock.calls.SetIFDEQ = nil
	mock.lockSetIFDEQ.Unlock()

	mock.lockSetIFDEQGet.Lock()
	mock.calls.SetIFDEQGet = nil
	mock.lockSetIFDEQGet.Unlock()

	mock.lockSetIFDNE.Lock()
	mock.calls.SetIFDNE = nil
	mock.lockSetIFDNE.Unlock()

	mock.lockSetIFDNEGet.Lock()
	mock.calls.SetIFDNEGet = nil
	mock.lockSetIFDNEGet.Unlock()

	mock.lockSetIFEQ.Lock()
	mock.calls.SetIFEQ = nil
	mock.lockSetIFEQ.Unlock()

	mock.lockSetIFEQGet.Lock()
	mock.calls.SetIFEQGet = nil
	mock.lockSetIFEQGet.Unlock()

	mock.lockSetIFNE.Lock()
	mock.calls.SetIFNE = nil
	mock.lockSetIFNE.Unlock()

	mock.lockSetIFNEGet.Lock()
	mock.calls.SetIFNEGet = nil
	mock.lockSetIFNEGet.Unlock()

	mock.lockSetNX.Lock()
	mock.calls.SetNX = nil
	mock.lockSetNX.Unlock()

	mock.lockSetRange.Lock()
	mock.calls.SetRange = nil
	mock.lockSetRange.Unlock()

	mock.lockSetXX.Lock()
	mock.calls.SetXX = nil
	mock.lockSetXX.Unlock()

	mock.lockShutdown.Lock()
	mock.calls.Shutdown = nil
	mock.lockShutdown.Unlock()

	mock.lockShutdownNoSave.Lock()
	mock.calls.ShutdownNoSave = nil
	mock.lockShutdownNoSave.Unlock()

	mock.lockShutdownSave.Lock()
	mock.calls.ShutdownSave = nil
	mock.lockShutdownSave.Unlock()

	mock.lockSlaveOf.Lock()
	mock.calls.SlaveOf = nil
	mock.lockSlaveOf.Unlock()

	mock.lockSlowLogGet.Lock()
	mock.calls.SlowLogGet = nil
	mock.lockSlowLogGet.Unlock()

	mock.lockSlowLogLen.Lock()
	mock.calls.SlowLogLen = nil
	mock.lockSlowLogLen.Unlock()

	mock.lockSlowLogReset.Lock()
	mock.calls.SlowLogReset = nil
	mock.lockSlowLogReset.Unlock()

	mock.lockSort.Lock()
	mock.calls.Sort = nil
	mock.lockSort.Unlock()

	mock.lockSortInterfaces.Lock()
	mock.calls.SortInterfaces = nil
	mock.lockSortInterfaces.Unlock()

	mock.lockSortRO.Lock()
	mock.calls.SortRO = nil
	mock.lockSortRO.Unlock()

	mock.lockSortStore.Lock()
	mock.calls.SortStore = nil
	mock.lockSortStore.Unlock()

	mock.lockStrLen.Lock()
	mock.calls.StrLen = nil
	mock.lockStrLen.Unlock()

	mock.lockSubscribe.Lock()
	mock.calls.Subscribe = nil
	mock.lockSubscribe.Unlock()

	mock.lockTDigestAdd.Lock()
	mock.calls.TDigestAdd = nil
	mock.lockTDigestAdd.Unlock()

	mock.lockTDigestByRank.Lock()
	mock.calls.TDigestByRank = nil
	mock.lockTDigestByRank.Unlock()

	mock.lockTDigestByRevRank.Lock()
	mock.calls.TDigestByRevRank = nil
	mock.lockTDigestByRevRank.Unlock()

	mock.lockTDigestCDF.Lock()
	mock.calls.TDigestCDF = nil
	mock.lockTDigestCDF.Unlock()

	mock.lockTDigestCreate.Lock()
	mock.calls.TDigestCreate = nil
	mock.lockTDigestCreate.Unlock()

	mock.lockTDigestCreateWithCompression.Lock()
	mock.calls.TDigestCreateWithCompression = nil
	mock.lockTDigestCreateWithCompression.Unlock()

	mock.lockTDigestInfo.Lock()
	mock.calls.TDigestInfo = nil
	mock.lockTDigestInfo.Unlock()

	mock.lockTDigestMax.Lock()
	mock.calls.TDigestMax = nil
	mock.lockTDigestMax.Unlock()

	mock.lockTDigestMerge.Lock()
	mock.calls.TDigestMerge = nil
	mock.lockTDigestMerge.Unlock()

	mock.lockTDigestMin.Lock()
	mock.calls.TDigestMin = nil
	mock.lockTDigestMin.Unlock()

	mock.lockTDigestQuantile.Lock()
	mock.calls.TDigestQuantile = nil
	mock.lockTDigestQuantile.Unlock()

	mock.lockTDigestRank.Lock()
	mock.calls.TDigestRank = nil
	mock.lockTDigestRank.Unlock()

	mock.lockTDigestReset.Lock()
	mock.calls.TDigestReset = nil
	mock.lockTDigestReset.Unlock()

	mock.lockTDigestRevRank.Lock()
	mock.calls.TDigestRevRank = nil
	mock.lockTDigestRevRank.Unlock()

	mock.lockTDigestTrimmedMean.Lock()
	mock.calls.TDigestTrimmedMean = nil
	mock.lockTDigestTrimmedMean.Unlock()

	mock.lockTSAdd.Lock()
	mock.calls.TSAdd = nil
	mock.lockTSAdd.Unlock()

	mock.lockTSAddWithArgs.Lock()
	mock.calls.TSAddWithArgs = nil
	mock.lockTSAddWithArgs.Unlock()

	mock.lockTSAlter.Lock()
	mock.calls.TSAlter = nil
	mock.lockTSAlter.Unlock()

	mock.lockTSCreate.Lock()
	mock.calls.TSCreate = nil
	mock.lockTSCreate.Unlock()

	mock.lockTSCreateRule.Lock()
	mock.calls.TSCreateRule = nil
	mock.lockTSCreateRule.Unlock()

	mock.lockTSCreateRuleWithArgs.Lock()
	mock.calls.TSCreateRuleWithArgs = nil
	mock.lockTSCreateRuleWithArgs.Unlock()

	mock.lockTSCreateWithArgs.Lock()
	mock.calls.TSCreateWithArgs = nil
	mock.lockTSCreateWithArgs.Unlock()

	mock.lockTSDecrBy.Lock()
	mock.calls.TSDecrBy = nil
	mock.lockTSDecrBy.Unlock()

	mock.lockTSDecrByWithArgs.Lock()
	mock.calls.TSDecrByWithArgs = nil
	mock.lockTSDecrByWithArgs.Unlock()

	mock.lockTSDel.Lock()
	mock.calls.TSDel = nil
	mock.lockTSDel.Unlock()

	mock.lockTSDeleteRule.Lock()
	mock.calls.TSDeleteRule = nil
	mock.lockTSDeleteRule.Unlock()

	mock.lockTSGet.Lock()
	mock.calls.TSGet = nil
	mock.lockTSGet.Unlock()

	mock.lockTSGetWithArgs.Lock()
	mock.calls.TSGetWithArgs = nil
	mock.lockTSGetWithArgs.Unlock()

	mock.lockTSIncrBy.Lock()
	mock.calls.TSIncrBy = nil
	mock.lockTSIncrBy.Unlock()

	mock.lockTSIncrByWithArgs.Lock()
	mock.calls.TSIncrByWithArgs = nil
	mock.lockTSIncrByWithArgs.Unlock()

	mock.lockTSInfo.Lock()
	mock.calls.TSInfo = nil
	mock.lockTSInfo.Unlock()

	mock.lockTSInfoWithArgs.Lock()
	mock.calls.TSInfoWithArgs = nil
	mock.lockTSInfoWithArgs.Unlock()

	mock.lockTSMAdd.Lock()
	mock.calls.TSMAdd = nil
	mock.lockTSMAdd.Unlock()

	mock.lockTSMGet.Lock()
	mock.calls.TSMGet = nil
	mock.lockTSMGet.Unlock()

	mock.lockTSMGetWithArgs.Lock()
	mock.calls.TSMGetWithArgs = nil
	mock.lockTSMGetWithArgs.Unlock()

	mock.lockTSMRange.Lock()
	mock.calls.TSMRange = nil
	mock.lockTSMRange.Unlock()

	mock.lockTSMRangeWithArgs.Lock()
	mock.calls.TSMRangeWithArgs = nil
	mock.lockTSMRangeWithArgs.Unlock()

	mock.lockTSMRevRange.Lock()
	mock.calls.TSMRevRange = nil
	mock.lockTSMRevRange.Unlock()

	mock.lockTSMRevRangeWithArgs.Lock()
	mock.calls.TSMRevRangeWithArgs = nil
	mock.lockTSMRevRangeWithArgs.Unlock()

	mock.lockTSQueryIndex.Lock()
	mock.calls.TSQueryIndex = nil
	mock.lockTSQueryIndex.Unlock()

	mock.lockTSRange.Lock()
	mock.calls.TSRange = nil
	mock.lockTSRange.Unlock()

	mock.lockTSRangeWithArgs.Lock()
	mock.calls.TSRangeWithArgs = nil
	mock.lockTSRangeWithArgs.Unlock()

	mock.lockTSRevRange.Lock()
	mock.calls.TSRevRange = nil
	mock.lockTSRevRange.Unlock()

	mock.lockTSRevRangeWithArgs.Lock()
	mock.calls.TSRevRangeWithArgs = nil
	mock.lockTSRevRangeWithArgs.Unlock()

	mock.lockTTL.Lock()
	mock.calls.TTL = nil
	mock.lockTTL.Unlock()

	mock.lockTime.Lock()
	mock.calls.Time = nil
	mock.lockTime.Unlock()

	mock.lockTopKAdd.Lock()
	mock.calls.TopKAdd = nil
	mock.lockTopKAdd.Unlock()

	mock.lockTopKCount.Lock()
	mock.calls.TopKCount = nil
	mock.lockTopKCount.Unlock()

	mock.lockTopKIncrBy.Lock()
	mock.calls.TopKIncrBy = nil
	mock.lockTopKIncrBy.Unlock()

	mock.lockTopKInfo.Lock()
	mock.calls.TopKInfo = nil
	mock.lockTopKInfo.Unlock()

	mock.lockTopKList.Lock()
	mock.calls.TopKList = nil
	mock.lockTopKList.Unlock()

	mock.lockTopKListWithCount.Lock()
	mock.calls.TopKListWithCount = nil
	mock.lockTopKListWithCount.Unlock()

	mock.lockTopKQuery.Lock()
	mock.calls.TopKQuery = nil
	mock.lockTopKQuery.Unlock()

	mock.lockTopKReserve.Lock()
	mock.calls.TopKReserve = nil
	mock.lockTopKReserve.Unlock()

	mock.lockTopKReserveWithOptions.Lock()
	mock.calls.TopKReserveWithOptions = nil
	mock.lockTopKReserveWithOptions.Unlock()

	mock.lockTouch.Lock()
	mock.calls.Touch = nil
	mock.lockTouch.Unlock()

	mock.lockTxPipeline.Lock()
	mock.calls.TxPipeline = nil
	mock.lockTxPipeline.Unlock()

	mock.lockTxPipelined.Lock()
	mock.calls.TxPipelined = nil
	mock.lockTxPipelined.Unlock()

	mock.lockType.Lock()
	mock.calls.Type = nil
	mock.lockType.Unlock()

	mock.lockUnlink.Lock()
	mock.calls.Unlink = nil
	mock.lockUnlink.Unlock()

	mock.lockVAdd.Lock()
	mock.calls.VAdd = nil
	mock.lockVAdd.Unlock()

	mock.lockVAddWithArgs.Lock()
	mock.calls.VAddWithArgs = nil
	mock.lockVAddWithArgs.Unlock()

	mock.lockVCard.Lock()
	mock.calls.VCard = nil
	mock.lockVCard.Unlock()

	mock.lockVClearAttributes.Lock()
	mock.calls.VClearAttributes = nil
	mock.lockVClearAttributes.Unlock()

	mock.lockVDim.Lock()
	mock.calls.VDim = nil
	mock.lockVDim.Unlock()

	mock.lockVEmb.Lock()
	mock.calls.VEmb = nil
	mock.lockVEmb.Unlock()

	mock.lockVGetAttr.Lock()
	mock.calls.VGetAttr = nil
	mock.lockVGetAttr.Unlock()

	mock.lockVInfo.Lock()
	mock.calls.VInfo = nil
	mock.lockVInfo.Unlock()

	mock.lockVLinks.Lock()
	mock.calls.VLinks = nil
	mock.lockVLinks.Unlock()

	mock.lockVLinksWithScores.Lock()
	mock.calls.VLinksWithScores = nil
	mock.lockVLinksWithScores.Unlock()

	mock.lockVRandMember.Lock()
	mock.calls.VRandMember = nil
	mock.lockVRandMember.Unlock()

	mock.lockVRandMemberCount.Lock()
	mock.calls.VRandMemberCount = nil
	mock.lockVRandMemberCount.Unlock()

	mock.lockVRange.Lock()
	mock.calls.VRange = nil
	mock.lockVRange.Unlock()

	mock.lockVRem.Lock()
	mock.calls.VRem = nil
	mock.lockVRem.Unlock()

	mock.lockVSetAttr.Lock()
	mock.calls.VSetAttr = nil
	mock.lockVSetAttr.Unlock()

	mock.lockVSim.Lock()
	mock.calls.VSim = nil
	mock.lockVSim.Unlock()

	mock.lockVSimWithArgs.Lock()
	mock.calls.VSimWithArgs = nil
	mock.lockVSimWithArgs.Unlock()

	mock.lockVSimWithArgsWithScores.Lock()
	mock.calls.VSimWithArgsWithScores = nil
	mock.lockVSimWithArgsWithScores.Unlock()

	mock.lockVSimWithScores.Lock()
	mock.calls.VSimWithScores = nil
	mock.lockVSimWithScores.Unlock()

	mock.lockXAck.Lock()
	mock.calls.XAck = nil
	mock.lockXAck.Unlock()

	mock.lockXAckDel.Lock()
	mock.calls.XAckDel = nil
	mock.lockXAckDel.Unlock()

	mock.lockXAdd.Lock()
	mock.calls.XAdd = nil
	mock.lockXAdd.Unlock()

	mock.lockXAutoClaim.Lock()
	mock.calls.XAutoClaim = nil
	mock.lockXAutoClaim.Unlock()

	mock.lockXAutoClaimJustID.Lock()
	mock.calls.XAutoClaimJustID = nil
	mock.lockXAutoClaimJustID.Unlock()

	mock.lockXCfgSet.Lock()
	mock.calls.XCfgSet = nil
	mock.lockXCfgSet.Unlock()

	mock.lockXClaim.Lock()
	mock.calls.XClaim = nil
	mock.lockXClaim.Unlock()

	mock.lockXClaimJustID.Lock()
	mock.calls.XClaimJustID = nil
	mock.lockXClaimJustID.Unlock()

	mock.lockXDel.Lock()
	mock.calls.XDel = nil
	mock.lockXDel.Unlock()

	mock.lockXDelEx.Lock()
	mock.calls.XDelEx = nil
	mock.lockXDelEx.Unlock()

	mock.lockXGroupCreate.Lock()
	mock.calls.XGroupCreate = nil
	mock.lockXGroupCreate.Unlock()

	mock.lockXGroupCreateConsumer.Lock()
	mock.calls.XGroupCreateConsumer = nil
	mock.lockXGroupCreateConsumer.Unlock()

	mock.lockXGroupCreateMkStream.Lock()
	mock.calls.XGroupCreateMkStream = nil
	mock.lockXGroupCreateMkStream.Unlock()

	mock.lockXGroupDelConsumer.Lock()
	mock.calls.XGroupDelConsumer = nil
	mock.lockXGroupDelConsumer.Unlock()

	mock.lockXGroupDestroy.Lock()
	mock.calls.XGroupDestroy = nil
	mock.lockXGroupDestroy.Unlock()

	mock.lockXGroupSetID.Lock()
	mock.calls.XGroupSetID = nil
	mock.lockXGroupSetID.Unlock()

	mock.lockXInfoConsumers.Lock()
	mock.calls.XInfoConsumers = nil
	mock.lockXInfoConsumers.Unlock()

	mock.lockXInfoGroups.Lock()
	mock.calls.XInfoGroups = nil
	mock.lockXInfoGroups.Unlock()

	mock.lockXInfoStream.Lock()
	mock.calls.XInfoStream = nil
	mock.lockXInfoStream.Unlock()

	mock.lockXInfoStreamFull.Lock()
	mock.calls.XInfoStreamFull = nil
	mock.lockXInfoStreamFull.Unlock()

	mock.lockXLen.Lock()
	mock.calls.XLen = nil
	mock.lockXLen.Unlock()

	mock.lockXPending.Lock()
	mock.calls.XPending = nil
	mock.lockXPending.Unlock()

	mock.lockXPendingExt.Lock()
	mock.calls.XPendingExt = nil
	mock.lockXPendingExt.Unlock()

	mock.lockXRange.Lock()
	mock.calls.XRange = nil
	mock.lockXRange.Unlock()

	mock.lockXRangeN.Lock()
	mock.calls.XRangeN = nil
	mock.lockXRangeN.Unlock()

	mock.lockXRead.Lock()
	mock.calls.XRead = nil
	mock.lockXRead.Unlock()

	mock.lockXReadGroup.Lock()
	mock.calls.XReadGroup = nil
	mock.lockXReadGroup.Unlock()

	mock.lockXReadStreams.Lock()
	mock.calls.XReadStreams = nil
	mock.lockXReadStreams.Unlock()

	mock.lockXRevRange.Lock()
	mock.calls.XRevRange = nil
	mock.lockXRevRange.Unlock()

	mock.lockXRevRangeN.Lock()
	mock.calls.XRevRangeN = nil
	mock.lockXRevRangeN.Unlock()

	mock.lockXTrimMaxLen.Lock()
	mock.calls.XTrimMaxLen = nil
	mock.lockXTrimMaxLen.Unlock()

	mock.lockXTrimMaxLenApprox.Lock()
	mock.calls.XTrimMaxLenApprox = nil
	mock.lockXTrimMaxLenApprox.Unlock()

	mock.lockXTrimMaxLenApproxMode.Lock()
	mock.calls.XTrimMaxLenApproxMode = nil
	mock.lockXTrimMaxLenApproxMode.Unlock()

	mock.lockXTrimMaxLenMode.Lock()
	mock.calls.XTrimMaxLenMode = nil
	mock.lockXTrimMaxLenMode.Unlock()

	mock.lockXTrimMinID.Lock()
	mock.calls.XTrimMinID = nil
	mock.lockXTrimMinID.Unlock()

	mock.lockXTrimMinIDApprox.Lock()
	mock.calls.XTrimMinIDApprox = nil
	mock.lockXTrimMinIDApprox.Unlock()

	mock.lockXTrimMinIDApproxMode.Lock()
	mock.calls.XTrimMinIDApproxMode = nil
	mock.lockXTrimMinIDApproxMode.Unlock()

	mock.lockXTrimMinIDMode.Lock()
	mock.calls.XTrimMinIDMode = nil
	mock.lockXTrimMinIDMode.Unlock()

	mock.lockZAdd.Lock()
	mock.calls.ZAdd = nil
	mock.lockZAdd.Unlock()

	mock.lockZAddArgs.Lock()
	mock.calls.ZAddArgs = nil
	mock.lockZAddArgs.Unlock()

	mock.lockZAddArgsIncr.Lock()
	mock.calls.ZAddArgsIncr = nil
	mock.lockZAddArgsIncr.Unlock()

	mock.lockZAddGT.Lock()
	mock.calls.ZAddGT = nil
	mock.lockZAddGT.Unlock()

	mock.lockZAddLT.Lock()
	mock.calls.ZAddLT = nil
	mock.lockZAddLT.Unlock()

	mock.lockZAddNX.Lock()
	mock.calls.ZAddNX = nil
	mock.lockZAddNX.Unlock()

	mock.lockZAddXX.Lock()
	mock.calls.ZAddXX = nil
	mock.lockZAddXX.Unlock()

	mock.lockZCard.Lock()
	mock.calls.ZCard = nil
	mock.lockZCard.Unlock()

	mock.lockZCount.Lock()
	mock.calls.ZCount = nil
	mock.lockZCount.Unlock()

	mock.lockZDiff.Lock()
	mock.calls.ZDiff = nil
	mock.lockZDiff.Unlock()

	mock.lockZDiffStore.Lock()
	mock.calls.ZDiffStore = nil
	mock.lockZDiffStore.Unlock()

	mock.lockZDiffWithScores.Lock()
	mock.calls.ZDiffWithScores = nil
	mock.lockZDiffWithScores.Unlock()

	mock.lockZIncrBy.Lock()
	mock.calls.ZIncrBy = nil
	mock.lockZIncrBy.Unlock()

	mock.lockZInter.Lock()
	mock.calls.ZInter = nil
	mock.lockZInter.Unlock()

	mock.lockZInterCard.Lock()
	mock.calls.ZInterCard = nil
	mock.lockZInterCard.Unlock()

	mock.lockZInterStore.Lock()
	mock.calls.ZInterStore = nil
	mock.lockZInterStore.Unlock()

	mock.lockZInterWithScores.Lock()
	mock.calls.ZInterWithScores = nil
	mock.lockZInterWithScores.Unlock()

	mock.lockZLexCount.Lock()
	mock.calls.ZLexCount = nil
	mock.lockZLexCount.Unlock()

	mock.lockZMPop.Lock()
	mock.calls.ZMPop = nil
	mock.lockZMPop.Unlock()

	mock.lockZMScore.Lock()
	mock.calls.ZMScore = nil
	mock.lockZMScore.Unlock()

	mock.lockZPopMax.Lock()
	mock.calls.ZPopMax = nil
	mock.lockZPopMax.Unlock()

	mock.lockZPopMin.Lock()
	mock.calls.ZPopMin = nil
	mock.lockZPopMin.Unlock()

	mock.lockZRandMember.Lock()
	mock.calls.ZRandMember = nil
	mock.lockZRandMember.Unlock()

	mock.lockZRandMemberWithScores.Lock()
	mock.calls.ZRandMemberWithScores = nil
	mock.lockZRandMemberWithScores.Unlock()

	mock.lockZRange.Lock()
	mock.calls.ZRange = nil
	mock.lockZRange.Unlock()

	mock.lockZRangeArgs.Lock()
	mock.calls.ZRangeArgs = nil
	mock.lockZRangeArgs.Unlock()

	mock.lockZRangeArgsWithScores.Lock()
	mock.calls.ZRangeArgsWithScores = nil
	mock.lockZRangeArgsWithScores.Unlock()

	mock.lockZRangeByLex.Lock()
	mock.calls.ZRangeByLex = nil
	mock.lockZRangeByLex.Unlock()

	mock.lockZRangeByScore.Lock()
	mock.calls.ZRangeByScore = nil
	mock.lockZRangeByScore.Unlock()

	mock.lockZRangeByScoreWithScores.Lock()
	mock.calls.ZRangeByScoreWithScores = nil
	mock.lockZRangeByScoreWithScores.Unlock()

	mock.lockZRangeStore.Lock()
	mock.calls.ZRangeStore = nil
	mock.lockZRangeStore.Unlock()

	mock.lockZRangeWithScores.Lock()
	mock.calls.ZRangeWithScores = nil
	mock.lockZRangeWithScores.Unlock()

	mock.lockZRank.Lock()
	mock.calls.ZRank = nil
	mock.lockZRank.Unlock()

	mock.lockZRankWithScore.Lock()
	mock.calls.ZRankWithScore = nil
	mock.lockZRankWithScore.Unlock()

	mock.lockZRem.Lock()
	mock.calls.ZRem = nil
	mock.lockZRem.Unlock()

	mock.lockZRemRangeByLex.Lock()
	mock.calls.ZRemRangeByLex = nil
	mock.lockZRemRangeByLex.Unlock()

	mock.lockZRemRangeByRank.Lock()
	mock.calls.ZRemRangeByRank = nil
	mock.lockZRemRangeByRank.Unlock()

	mock.lockZRemRangeByScore.Lock()
	mock.calls.ZRemRangeByScore = nil
	mock.lockZRemRangeByScore.Unlock()

	mock.lockZRevRange.Lock()
	mock.calls.ZRevRange = nil
	mock.lockZRevRange.Unlock()

	mock.lockZRevRangeByLex.Lock()
	mock.calls.ZRevRangeByLex = nil
	mock.lockZRevRangeByLex.Unlock()

	mock.lockZRevRangeByScore.Lock()
	mock.calls.ZRevRangeByScore = nil
	mock.lockZRevRangeByScore.Unlock()

	mock.lockZRevRangeByScoreWithScores.Lock()
	mock.calls.ZRevRangeByScoreWithScores = nil
	mock.lockZRevRangeByScoreWithScores.Unlock()

	mock.lockZRevRangeWithScores.Lock()
	mock.calls.ZRevRangeWithScores = nil
	mock.lockZRevRangeWithScores.Unlock()

	mock.lockZRevRank.Lock()
	mock.calls.ZRevRank = nil
	mock.lockZRevRank.Unlock()

	mock.lockZRevRankWithScore.Lock()
	mock.calls.ZRevRankWithScore = nil
	mock.lockZRevRankWithScore.Unlock()

	mock.lockZScan.Lock()
	mock.calls.ZScan = nil
	mock.lockZScan.Unlock()

	mock.lockZScore.Lock()
	mock.calls.ZScore = nil
	mock.lockZScore.Unlock()

	mock.lockZUnion.Lock()
	mock.calls.ZUnion = nil
	mock.lockZUnion.Unlock()

	mock.lockZUnionStore.Lock()
	mock.calls.ZUnionStore = nil
	mock.lockZUnionStore.Unlock()

	mock.lockZUnionWithScores.Lock()
	mock.calls.ZUnionWithScores = nil
	mock.lockZUnionWithScores.Unlock()
}
